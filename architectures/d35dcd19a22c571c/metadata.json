{
  "hash": "d35dcd19a22c571c",
  "source_url": "https://github.com/aws-samples/aws-waf-automation-terraform-samples",
  "source_type": "github",
  "discovered_at": "2026-01-11T21:33:36.028035",
  "services": [
    "sns",
    "apigateway",
    "cloudwatch",
    "dynamodb",
    "cloudformation",
    "firehose",
    "lambda",
    "kms",
    "s3",
    "iam"
  ],
  "resource_count": 156,
  "name": "aws-waf-automation-terraform-samples",
  "description": "",
  "version": null,
  "skipped": false,
  "skip_reason": null,
  "original_format": null,
  "terraform_files": {
    "main.tf": "data \"aws_partition\" \"current\" {}\n\ndata \"aws_region\" \"current\" {}\n\ndata \"aws_caller_identity\" \"current\" {}\n\nresource \"random_uuid\" \"test\" {\n}\n\nresource \"random_id\" \"server\" {\n  byte_length = 8\n}\n\nlocals {\n  AppLogBucket = \"${var.AppAccessLogBucket}-${random_id.server.hex}\"\n}\n\n\nresource \"aws_kms_key\" \"wafkey\" {\n  description         = \"KMS key 1\"\n  enable_key_rotation = true\n  policy              = <<EOF\n{\n  \"Version\" : \"2012-10-17\",\n  \"Id\" : \"key-default-1\",\n  \"Statement\" : [ {\n      \"Sid\" : \"Enable IAM User Permissions\",\n      \"Effect\" : \"Allow\",\n      \"Principal\" : {\n        \"AWS\" : \"arn:aws:iam::${data.aws_caller_identity.current.account_id}:root\"\n      },\n        \"Action\": [ \n          \"kms:Create*\",\n          \"kms:Describe*\",\n          \"kms:Enable*\",\n          \"kms:List*\",\n          \"kms:Put*\",\n          \"kms:Update*\",\n          \"kms:Revoke*\",\n          \"kms:Disable*\",\n          \"kms:GenerateDataKey*\",\n          \"kms:Get*\",\n          \"kms:Delete*\",\n          \"kms:ScheduleKeyDeletion\",\n          \"kms:ListAliases\",\n          \"kms:CreateGrant\",\n          \"kms:Encrypt*\",\n          \"kms:Decrypt*\",\n          \"kms:ReEncrypt*\",\n          \"kms:CancelKeyDeletion\"\n      ],\n      \"Resource\" : \"*\"\n    },\n    {\n      \"Effect\": \"Allow\",\n      \"Principal\": { \"Service\": \"logs.${data.aws_region.current.name}.amazonaws.com\" },\n      \"Action\": [ \n        \"kms:Encrypt*\",\n        \"kms:Decrypt*\",\n        \"kms:ReEncrypt*\",\n        \"kms:GenerateDataKey*\",\n        \"kms:Describe*\"\n      ],\n      \"Resource\": \"*\"\n    }  \n  ]\n}\nEOF\n}\n\nresource \"aws_sns_topic\" \"user_updates\" {\n  count             = local.SNSEmail == \"yes\" ? 1 : 0\n  name              = join(\"-\", [\"AWS-WAF-Security-Automations-IP-Expiration-Notification\", \"${aws_cloudformation_stack.trigger_codebuild_stack.outputs.UUID}\"])\n  kms_master_key_id = \"alias/aws/sns\"\n}\n\nresource \"aws_sns_topic_subscription\" \"user_updates_sqs_target\" {\n  count     = local.SNSEmail == \"yes\" ? 1 : 0\n  topic_arn = aws_sns_topic.user_updates[0].arn\n  protocol  = \"email\"\n  endpoint  = var.SNSEmailParam\n  depends_on = [\n    aws_sns_topic.user_updates\n  ]\n}\n\nresource \"aws_sns_topic_policy\" \"default\" {\n  count  = local.SNSEmail == \"yes\" ? 1 : 0\n  arn    = aws_sns_topic.user_updates[0].arn\n  policy = data.aws_iam_policy_document.sns_topic_policy[0].json\n  depends_on = [\n    aws_sns_topic.user_updates\n  ]\n}\n\ndata \"aws_iam_policy_document\" \"sns_topic_policy\" {\n  count     = local.SNSEmail == \"yes\" ? 1 : 0\n  policy_id = \"__default_policy_ID\"\n\n  statement {\n    actions = [\n      \"SNS:Subscribe\",\n      \"SNS:SetTopicAttributes\",\n      \"SNS:RemovePermission\",\n      \"SNS:Receive\",\n      \"SNS:Publish\",\n      \"SNS:ListSubscriptionsByTopic\",\n      \"SNS:GetTopicAttributes\",\n      \"SNS:DeleteTopic\",\n      \"SNS:AddPermission\",\n    ]\n\n    condition {\n      test     = \"StringEquals\"\n      variable = \"AWS:SourceOwner\"\n\n      values = [\n        data.aws_caller_identity.current.account_id,\n      ]\n    }\n\n    effect = \"Allow\"\n\n    principals {\n      type        = \"AWS\"\n      identifiers = [\"*\"]\n    }\n\n    resources = [\n      aws_sns_topic.user_updates[0].arn,\n    ]\n\n    sid = \"__default_statement_ID\"\n  }\n}\n\n\n\n### S3 bucket Creation\n\nresource \"aws_s3_bucket\" \"WafLogBucket\" {\n  count         = local.HttpFloodProtectionLogParserActivated == \"yes\" ? 1 : 0\n  bucket        = \"${random_id.server.hex}-waflogbucket\"\n  acl           = \"private\"\n  force_destroy = true\n  versioning {\n    enabled = true\n  }\n  server_side_encryption_configuration {\n    rule {\n      apply_server_side_encryption_by_default {\n        sse_algorithm = var.sse_algorithm\n      }\n    }\n  }\n  logging {\n    target_bucket = aws_s3_bucket.accesslogbucket[0].bucket\n    target_prefix = \"WAF_Logs/\"\n  }\n}\n\nresource \"aws_s3_bucket_public_access_block\" \"WafLogBucket\" {\n  count                   = local.HttpFloodProtectionLogParserActivated == \"yes\" ? 1 : 0\n  bucket                  = aws_s3_bucket.WafLogBucket[0].id\n  block_public_acls       = true\n  block_public_policy     = true\n  ignore_public_acls      = true\n  restrict_public_buckets = true\n  depends_on = [\n    aws_s3_bucket.WafLogBucket\n  ]\n}\n\nresource \"aws_s3_bucket_policy\" \"wafbucketpolicy\" {\n  count         = local.HttpFloodProtectionLogParserActivated == \"yes\" ? 1 : 0\n  bucket = aws_s3_bucket.WafLogBucket[0].id\n\n  policy = <<POLICY\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Effect\": \"Allow\",\n            \"Principal\": {\n                \"AWS\": [\n                \"arn:${data.aws_partition.current.partition}:iam::${data.aws_caller_identity.current.account_id}:role/${aws_iam_role.s3bucketaccessrole.name}\"\n                ]\n            },\n            \"Action\": \"s3:*\",\n            \"Resource\": [\n                \"${aws_s3_bucket.WafLogBucket[0].arn}\",\n                \"${aws_s3_bucket.WafLogBucket[0].arn}/*\"\n            ]\n        },\n        {\n            \"Sid\": \"HttpsOnly\",\n            \"Effect\": \"Deny\",\n            \"Principal\": \"*\",\n            \"Action\": \"s3:*\",\n            \"Resource\": [\n                \"${aws_s3_bucket.WafLogBucket[0].arn}\",\n                \"${aws_s3_bucket.WafLogBucket[0].arn}/*\"\n            ],\n            \"Condition\": {\n                \"Bool\": {\n                    \"aws:SecureTransport\": \"false\"\n                }\n            }\n        }\n    ]\n}\nPOLICY\n  depends_on = [\n    aws_s3_bucket.WafLogBucket\n  ]\n}\n\n\ndata \"aws_iam_policy\" \"s3Access\" {\n  arn = \"arn:aws:iam::aws:policy/AmazonS3ReadOnlyAccess\"\n}\n\nresource \"aws_iam_role\" \"s3bucketaccessrole\" {\n  name  = \"s3-bucket-role-${random_id.server.hex}\"\n\n  assume_role_policy = <<POLICY\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Action\": \"sts:AssumeRole\",\n      \"Principal\": {\n        \"Service\": \"s3.amazonaws.com\"\n      },\n      \"Effect\": \"Allow\",\n      \"Sid\": \"\"\n    }\n  ]\n}\nPOLICY\n}\n\nresource \"aws_iam_role_policy_attachment\" \"s3bucketaccessrole-policy-attach\" {\n  role       = \"${aws_iam_role.s3bucketaccessrole.name}\"\n  policy_arn = \"${data.aws_iam_policy.s3Access.arn}\"\n}\n\nresource \"aws_iam_role\" \"replication\" {\n  count = local.HttpFloodProtectionLogParserActivated == \"yes\" ? 1 : 0\n  name  = \"tf-iam-role-${random_id.server.hex}\"\n\n  assume_role_policy = <<POLICY\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Action\": \"sts:AssumeRole\",\n      \"Principal\": {\n        \"Service\": \"s3.amazonaws.com\"\n      },\n      \"Effect\": \"Allow\",\n      \"Sid\": \"\"\n    }\n  ]\n}\nPOLICY\n}\n\nresource \"aws_iam_policy\" \"replication\" {\n  count = local.HttpFloodProtectionLogParserActivated == \"yes\" ? 1 : 0\n  name  = \"tf-iam-role-policy-${random_id.server.hex}\"\n\n  policy = <<POLICY\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Action\": [\n        \"s3:GetReplicationConfiguration\",\n        \"s3:ListBucket\"\n      ],\n      \"Effect\": \"Allow\",\n      \"Resource\": [\n        \"${aws_s3_bucket.WafLogBucket[0].arn}\"\n      ]\n    },\n    {\n      \"Action\": [\n        \"s3:GetObjectVersionForReplication\",\n        \"s3:GetObjectVersionAcl\",\n         \"s3:GetObjectVersionTagging\"\n      ],\n      \"Effect\": \"Allow\",\n      \"Resource\": [\n        \"${aws_s3_bucket.WafLogBucket[0].arn}/*\"\n      ]\n    }\n  ]\n}\nPOLICY\n}\n\nresource \"aws_iam_role_policy_attachment\" \"test-attach\" {\n  count = local.HttpFloodProtectionLogParserActivated == \"yes\" ? 1 : 0\n  role       = aws_iam_role.replication[0].name\n  policy_arn = aws_iam_policy.replication[0].arn\n}\n\n###AccessLoggingBucket\n\nresource \"aws_s3_bucket\" \"accesslogbucket\" {\n  count         = local.LogParser == \"yes\" ? 1 : 0\n  bucket        = \"${random_id.server.hex}-accesslogging\"\n  acl           = \"log-delivery-write\"\n  force_destroy = true\n  versioning {\n    enabled = true\n  }\n  server_side_encryption_configuration {\n    rule {\n      apply_server_side_encryption_by_default {\n        sse_algorithm = var.sse_algorithm\n      }\n    }\n  }\n}\n\nresource \"aws_s3_bucket_public_access_block\" \"accesslogbucket\" {\n  count                   = local.LogParser == \"yes\" ? 1 : 0\n  bucket                  = aws_s3_bucket.accesslogbucket[0].id\n  block_public_acls       = true\n  block_public_policy     = true\n  ignore_public_acls      = true\n  restrict_public_buckets = true\n  depends_on = [\n    aws_s3_bucket.accesslogbucket\n  ]\n}\n\nresource \"aws_s3_bucket_policy\" \"b\" {\n  count  = local.LogParser == \"yes\" ? 1 : 0\n  bucket = aws_s3_bucket.accesslogbucket[0].id\n\n  policy = <<POLICY\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n            {\n            \"Effect\": \"Allow\",\n            \"Principal\": {\n                \"AWS\": [\n                \"arn:${data.aws_partition.current.partition}:iam::${data.aws_caller_identity.current.account_id}:role/${aws_iam_role.s3bucketaccessrole.name}\"\n                ]\n            },\n            \"Action\": \"s3:*\",\n            \"Resource\": [\n                \"${aws_s3_bucket.accesslogbucket[0].arn}\",\n                \"${aws_s3_bucket.accesslogbucket[0].arn}/*\"\n            ]\n        },\n        {\n            \"Sid\": \"HttpsOnly\",\n            \"Effect\": \"Deny\",\n            \"Principal\": \"*\",\n            \"Action\": \"s3:*\",\n            \"Resource\": [\n                \"${aws_s3_bucket.accesslogbucket[0].arn}\",\n                \"${aws_s3_bucket.accesslogbucket[0].arn}/*\"\n            ],\n            \"Condition\": {\n                \"Bool\": {\n                    \"aws:SecureTransport\": \"false\"\n                }\n            }\n        }\n    ]\n}\nPOLICY\n  depends_on = [\n    aws_s3_bucket.accesslogbucket\n  ]\n}\n\nresource \"aws_iam_role\" \"replicationaccesslog\" {\n  count = local.LogParser == \"yes\" ? 1 : 0\n  name  = \"tf-iam-role-replication-${random_id.server.hex}\"\n\n  assume_role_policy = <<POLICY\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Action\": \"sts:AssumeRole\",\n      \"Principal\": {\n        \"Service\": \"s3.amazonaws.com\"\n      },\n      \"Effect\": \"Allow\",\n      \"Sid\": \"\"\n    }\n  ]\n}\nPOLICY\n}\n\nresource \"aws_iam_policy\" \"replicationaccesslog\" {\n  count  = local.LogParser == \"yes\" ? 1 : 0\n  name   = \"tf-iam-role-policy-repl-${random_id.server.hex}\"\n  policy = <<POLICY\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Action\": [\n        \"s3:GetReplicationConfiguration\",\n        \"s3:ListBucket\"\n      ],\n      \"Effect\": \"Allow\",\n      \"Resource\": [\n        \"${aws_s3_bucket.accesslogbucket[0].arn}\"\n      ]\n    },\n    {\n      \"Action\": [\n        \"s3:GetObjectVersionForReplication\",\n        \"s3:GetObjectVersionAcl\",\n         \"s3:GetObjectVersionTagging\"\n      ],\n      \"Effect\": \"Allow\",\n      \"Resource\": [\n        \"${aws_s3_bucket.accesslogbucket[0].arn}/*\"\n      ]\n    }\n  ]\n}\nPOLICY\n}\n\nresource \"aws_iam_role_policy_attachment\" \"test-attach-log\" {\n  count  = local.LogParser == \"yes\" ? 1 : 0\n  role       = aws_iam_role.replicationaccesslog[0].name\n  policy_arn = aws_iam_policy.replicationaccesslog[0].arn\n}\n\n# ----------------------------------------------------------------------------------------------------------------------\n# IP set Creation for WAF\n# ----------------------------------------------------------------------------------------------------------------------\n\n#IPV4 sets\n\nresource \"aws_wafv2_ip_set\" \"WAFWhitelistSetV4\" {\n  name               = \"WAFWhitelistSetV41\"\n  description        = \"Block Bad Bot IPV4 addresses\"\n  scope              = local.SCOPE\n  ip_address_version = \"IPV4\"\n  addresses          = []\n}\n\nresource \"aws_wafv2_ip_set\" \"WAFBlacklistSetV4\" {\n  name               = \"WAFBlacklistSetV41\"\n  description        = \"Block Bad Bot IPV6 addresses\"\n  scope              = local.SCOPE\n  ip_address_version = \"IPV6\"\n  addresses          = []\n}\n\nresource \"aws_wafv2_ip_set\" \"WAFBadBotSetV4\" {\n  count              = var.BadBotProtectionActivated == \"yes\" ? 1 : 0\n  name               = \"WAFBadBotSetV41\"\n  description        = \"Block Bad Bot IPV4 addresses\"\n  scope              = local.SCOPE\n  ip_address_version = \"IPV4\"\n  addresses          = []\n}\n\nresource \"aws_wafv2_ip_set\" \"WAFReputationListsSetV4\" {\n  count              = var.ReputationListsProtectionActivated == \"yes\" ? 1 : 0\n  name               = \"WAFReputationListsSetV41\"\n  description        = \"Block Reputation List IPV4 addresses\"\n  scope              = local.SCOPE\n  ip_address_version = \"IPV4\"\n  addresses          = []\n  lifecycle {\n    ignore_changes = [\n      addresses\n    ]\n  }\n}\n\nresource \"aws_wafv2_ip_set\" \"WAFHttpFloodSetV4\" {\n  name               = \"WAFHttpFloodSetV41\"\n  description        = \"Block HTTP Flood IPV4 addresses\"\n  scope              = local.SCOPE\n  ip_address_version = \"IPV4\"\n  addresses          = []\n}\n\nresource \"aws_wafv2_ip_set\" \"WAFScannersProbesSetV4\" {\n  count              = var.ScannersProbesProtectionActivated == \"yes\" ? 1 : 0\n  name               = \"WAFScannersProbesSetV41\"\n  description        = \"Block HTTP Flood IPV4 addresses\"\n  scope              = local.SCOPE\n  ip_address_version = \"IPV4\"\n  addresses          = []\n}\n\n#IPV6 sets\n\nresource \"aws_wafv2_ip_set\" \"WAFWhitelistSetV6\" {\n  name               = \"WAFWhitelistSetV61\"\n  description        = \"Block Bad Bot IPV4 addresses\"\n  scope              = local.SCOPE\n  ip_address_version = \"IPV4\"\n  addresses          = []\n}\n\nresource \"aws_wafv2_ip_set\" \"WAFBlacklistSetV6\" {\n  name               = \"WAFBlacklistSetV61\"\n  description        = \"Block Bad Bot IPV6 addresses\"\n  scope              = local.SCOPE\n  ip_address_version = \"IPV6\"\n  addresses          = []\n}\n\nresource \"aws_wafv2_ip_set\" \"WAFBadBotSetV6\" {\n  count              = var.BadBotProtectionActivated == \"yes\" ? 1 : 0\n  name               = \"WAFBadBotSetV61\"\n  description        = \"Block Bad Bot IPV6 addresses\"\n  scope              = local.SCOPE\n  ip_address_version = \"IPV6\"\n  addresses          = []\n}\n\nresource \"aws_wafv2_ip_set\" \"WAFReputationListsSetV6\" {\n  count              = var.ReputationListsProtectionActivated == \"yes\" ? 1 : 0\n  name               = \"WAFReputationListsSetV61\"\n  description        = \"Block Reputation List IPV6 addresses\"\n  scope              = local.SCOPE\n  ip_address_version = \"IPV4\"\n  addresses          = []\n  lifecycle {\n    ignore_changes = [\n      addresses\n    ]\n  }\n}\n\nresource \"aws_wafv2_ip_set\" \"WAFHttpFloodSetV6\" {\n  name               = \"WAFHttpFloodSetV61\"\n  description        = \"Block HTTP Flood IPV6 addresses\"\n  scope              = local.SCOPE\n  ip_address_version = \"IPV6\"\n  addresses          = []\n}\n\nresource \"aws_wafv2_ip_set\" \"WAFScannersProbesSetV6\" {\n  count              = var.ScannersProbesProtectionActivated == \"yes\" ? 1 : 0\n  name               = \"WAFScannersProbesSetV61\"\n  description        = \"Block HTTP Flood IPV6 addresses\"\n  scope              = local.SCOPE\n  ip_address_version = \"IPV6\"\n  addresses          = []\n}\n\n\n\n# ----------------------------------------------------------------------------------------------------------------------\n#   WAFWebACL:\n# ----------------------------------------------------------------------------------------------------------------------\n\nresource \"aws_wafv2_web_acl\" \"wafacl\" {\n  name        = \"wafwebacl-rules-${random_id.server.hex}\"\n  description = \"Custom WAFWebACL\"\n  scope       = local.SCOPE\n  default_action {\n    allow {}\n  }\n  visibility_config {\n    cloudwatch_metrics_enabled = true\n    metric_name                = \"WAFWebACL-metric\"\n    sampled_requests_enabled   = true\n  }\n\n  rule {\n    name     = \"AWS-AWSManagedRulesKnownBadInputsRuleSet\"\n    priority = 10\n\n    override_action {\n      none {}\n    }\n\n    statement {\n      managed_rule_group_statement {\n        name        = \"AWSManagedRulesKnownBadInputsRuleSet\"\n        vendor_name = \"AWS\"\n      }\n    }\n    visibility_config {\n      cloudwatch_metrics_enabled = true\n      metric_name                = \"WAFWebACL-metric\"\n      sampled_requests_enabled   = true\n    }\n  }\n  rule {\n    name     = \"aws-AWSManagedRulesCommonRuleSet\"\n    priority = 0\n    override_action {\n      none {}\n    }\n\n    statement {\n      managed_rule_group_statement {\n        vendor_name = \"AWS\"\n        name        = \"AWSManagedRulesCommonRuleSet\"\n      }\n    }\n\n    visibility_config {\n      cloudwatch_metrics_enabled = true\n      metric_name                = \"MetricForAMRCRS\"\n      sampled_requests_enabled   = true\n    }\n  }\n\n  rule {\n    name     = \"WAFWhitelistRule1\"\n    priority = 1\n    action {\n      allow {}\n    }\n\n    statement {\n      or_statement {\n        statement {\n          ip_set_reference_statement {\n            arn = aws_wafv2_ip_set.WAFWhitelistSetV4.arn\n          }\n        }\n        statement {\n          ip_set_reference_statement {\n            arn = aws_wafv2_ip_set.WAFWhitelistSetV4.arn\n          }\n        }\n      }\n    }\n\n    visibility_config {\n      cloudwatch_metrics_enabled = true\n      metric_name                = \"MetricForWhitelistRule\"\n      sampled_requests_enabled   = true\n    }\n  }\n\n  rule {\n    name     = \"WAFBlacklistRule1\"\n    priority = 2\n    action {\n      block {}\n    }\n\n    statement {\n      or_statement {\n        statement {\n          ip_set_reference_statement {\n            arn = aws_wafv2_ip_set.WAFBlacklistSetV4.arn\n          }\n        }\n        statement {\n          ip_set_reference_statement {\n            arn = aws_wafv2_ip_set.WAFBlacklistSetV4.arn\n          }\n        }\n      }\n    }\n\n    visibility_config {\n      cloudwatch_metrics_enabled = true\n      metric_name                = \"MetricForBlacklistRule\"\n      sampled_requests_enabled   = true\n    }\n  }\n\n  rule {\n    name     = \"HttpFloodRegularRule\"\n    priority = 3\n    action {\n      block {}\n    }\n\n    statement {\n      or_statement {\n        statement {\n          ip_set_reference_statement {\n            arn = local.WAFHttpFloodSetIPV4arn\n          }\n        }\n        statement {\n          ip_set_reference_statement {\n            arn = local.WAFHttpFloodSetIPV6arn\n          }\n        }\n      }\n    }\n\n    visibility_config {\n      cloudwatch_metrics_enabled = true\n      metric_name                = \"MetricForHttpFloodRegularRule\"\n      sampled_requests_enabled   = true\n    }\n  }\n\n  rule {\n    name     = \"HttpFloodRateBasedRule\"\n    priority = 4\n    action {\n      block {}\n    }\n\n    statement {\n      rate_based_statement {\n        aggregate_key_type = \"IP\"\n        limit              = var.RequestThreshold\n      }\n    }\n\n    visibility_config {\n      cloudwatch_metrics_enabled = true\n      metric_name                = \"MetricForHttpFloodRateBasedRule\"\n      sampled_requests_enabled   = true\n    }\n  }\n\n  rule {\n    name     = \"ScannersAndProbesRule\"\n    priority = 5\n    action {\n      block {}\n    }\n\n    statement {\n      or_statement {\n        statement {\n          ip_set_reference_statement {\n            arn = aws_wafv2_ip_set.WAFScannersProbesSetV4[0].arn\n          }\n        }\n        statement {\n          ip_set_reference_statement {\n            arn = aws_wafv2_ip_set.WAFScannersProbesSetV6[0].arn\n          }\n        }\n      }\n    }\n\n    visibility_config {\n      cloudwatch_metrics_enabled = true\n      metric_name                = \"MetricForScannersProbesRulee\"\n      sampled_requests_enabled   = true\n    }\n  }\n\n  rule {\n    name     = \"IPReputationListsRule\"\n    priority = 6\n    action {\n      block {}\n    }\n\n    statement {\n      or_statement {\n        statement {\n          ip_set_reference_statement {\n            arn = aws_wafv2_ip_set.WAFReputationListsSetV4[0].arn\n          }\n        }\n        statement {\n          ip_set_reference_statement {\n            arn = aws_wafv2_ip_set.WAFReputationListsSetV6[0].arn\n          }\n        }\n      }\n    }\n\n    visibility_config {\n      cloudwatch_metrics_enabled = true\n      metric_name                = \"MetricForIPReputationListsRule\"\n      sampled_requests_enabled   = true\n    }\n  }\n\n  rule {\n    name     = \"BadBotRule\"\n    priority = 7\n    action {\n      block {}\n    }\n\n    statement {\n      or_statement {\n        statement {\n          ip_set_reference_statement {\n            arn = aws_wafv2_ip_set.WAFBadBotSetV4[0].arn\n          }\n        }\n        statement {\n          ip_set_reference_statement {\n            arn = aws_wafv2_ip_set.WAFBadBotSetV6[0].arn\n          }\n        }\n      }\n    }\n\n    visibility_config {\n      cloudwatch_metrics_enabled = true\n      metric_name                = \"MetricForBadBotRule\"\n      sampled_requests_enabled   = true\n    }\n  }\n\n  rule {\n    name     = \"SqlInjectionRule\"\n    priority = 20\n    action {\n      block {}\n    }\n\n    statement {\n      or_statement {\n        statement {\n          sqli_match_statement {\n            field_to_match {\n              query_string {}\n            }\n            text_transformation {\n              priority = 1\n              type     = \"URL_DECODE\"\n            }\n\n            text_transformation {\n              priority = 2\n              type     = \"HTML_ENTITY_DECODE\"\n            }\n          }\n        }\n        statement {\n          sqli_match_statement {\n            field_to_match {\n              body {}\n            }\n            text_transformation {\n              priority = 1\n              type     = \"URL_DECODE\"\n            }\n\n            text_transformation {\n              priority = 2\n              type     = \"HTML_ENTITY_DECODE\"\n            }\n          }\n        }\n        statement {\n          sqli_match_statement {\n            field_to_match {\n              uri_path {}\n            }\n            text_transformation {\n              priority = 1\n              type     = \"URL_DECODE\"\n            }\n\n            text_transformation {\n              priority = 2\n              type     = \"HTML_ENTITY_DECODE\"\n            }\n          }\n        }\n        statement {\n          sqli_match_statement {\n            field_to_match {\n              single_header {\n                name = \"authorization\"\n              }\n            }\n            text_transformation {\n              priority = 1\n              type     = \"URL_DECODE\"\n            }\n\n            text_transformation {\n              priority = 2\n              type     = \"HTML_ENTITY_DECODE\"\n            }\n          }\n        }\n        statement {\n          sqli_match_statement {\n            field_to_match {\n              single_header {\n                name = \"cookie\"\n              }\n            }\n            text_transformation {\n              priority = 1\n              type     = \"URL_DECODE\"\n            }\n\n            text_transformation {\n              priority = 2\n              type     = \"HTML_ENTITY_DECODE\"\n            }\n          }\n        }\n      }\n    }\n\n    visibility_config {\n      cloudwatch_metrics_enabled = true\n      metric_name                = \"MetricForSqlInjectionRule\"\n      sampled_requests_enabled   = true\n    }\n  }\n\n  rule {\n    name     = \"XssRule\"\n    priority = 30\n    action {\n      block {}\n    }\n\n    statement {\n      or_statement {\n        statement {\n          xss_match_statement {\n            field_to_match {\n              query_string {}\n            }\n            text_transformation {\n              priority = 1\n              type     = \"URL_DECODE\"\n            }\n            text_transformation {\n              priority = 2\n              type     = \"HTML_ENTITY_DECODE\"\n            }\n          }\n        }\n        statement {\n          xss_match_statement {\n            field_to_match {\n              body {}\n            }\n            text_transformation {\n              priority = 1\n              type     = \"URL_DECODE\"\n            }\n\n            text_transformation {\n              priority = 2\n              type     = \"HTML_ENTITY_DECODE\"\n            }\n          }\n        }\n        statement {\n          xss_match_statement {\n            field_to_match {\n              uri_path {}\n            }\n            text_transformation {\n              priority = 1\n              type     = \"URL_DECODE\"\n            }\n\n            text_transformation {\n              priority = 2\n              type     = \"HTML_ENTITY_DECODE\"\n            }\n          }\n        }\n        statement {\n          xss_match_statement {\n            field_to_match {\n              single_header {\n                name = \"cookie\"\n              }\n            }\n            text_transformation {\n              priority = 1\n              type     = \"URL_DECODE\"\n            }\n\n            text_transformation {\n              priority = 2\n              type     = \"HTML_ENTITY_DECODE\"\n            }\n          }\n        }\n      }\n    }\n\n    visibility_config {\n      cloudwatch_metrics_enabled = true\n      metric_name                = \"MetricForXssRule\"\n      sampled_requests_enabled   = true\n    }\n  }\n}\n\n# ----------------------------------------------------------------------------------------------------------------------\n# Dynamo DB table -This DynamoDB table constains transactional ip retention data that will be expired by DynamoDB TTL. The data doesn't need to be retained after its lifecycle ends.\n# ----------------------------------------------------------------------------------------------------------------------\n\nresource \"aws_dynamodb_table\" \"IPRetentionDDBTable\" {\n  count            = var.IPRetentionPeriod == \"yes\" ? 1 : 0\n  name             = \"IPRetentionDDBTable-${random_id.server.hex}\"\n  billing_mode     = \"PAY_PER_REQUEST\"\n  stream_enabled   = true\n  stream_view_type = \"OLD_IMAGE\"\n  hash_key         = \"IPSetId\"\n  range_key        = \"ExpirationTime\"\n  attribute {\n    name = \"IPSetId\"\n    type = \"S\"\n  }\n\n  attribute {\n    name = \"ExpirationTime\"\n    type = \"N\"\n  }\n\n  server_side_encryption {\n    enabled     = true\n    kms_key_arn = aws_kms_key.wafkey.arn\n  }\n\n  ttl {\n    attribute_name = \"ExpirationTime\"\n    enabled        = true\n  }\n\n  point_in_time_recovery {\n    enabled = true\n  }\n}\n\n# ----------------------------------------------------------------------------------------------------------------------\n# Role Creation for Lambda functions\n# ----------------------------------------------------------------------------------------------------------------------\n\n#Role 1 - LambdaRoleHelper\n\nresource \"aws_iam_role\" \"LambdaRoleHelper\" {\n  name = \"LambdaRoleHelper1-${random_id.server.hex}\"\n\n  assume_role_policy = <<EOF\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Action\": \"sts:AssumeRole\",\n      \"Principal\": {\n        \"Service\": \"lambda.amazonaws.com\"\n      },\n      \"Effect\": \"Allow\",\n      \"Sid\": \"\"\n    }\n  ]\n}\nEOF\n}\n\nresource \"aws_iam_role_policy\" \"S3Accesshelper\" {\n  name   = \"S3Access1\"\n  role   = aws_iam_role.LambdaRoleHelper.id\n  policy = <<EOT\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Action\": [\n                \"s3:GetBucketLocation\",\n                \"s3:GetObject\",\n                \"s3:ListBucket\"\n            ],\n            \"Resource\": [\n                \"arn:${data.aws_partition.current.partition}:s3:::${local.AppLogBucket}\"\n            ],\n            \"Effect\": \"Allow\"\n        }\n    ]\n}\nEOT\n  depends_on = [\n    aws_iam_role.LambdaRoleHelper\n  ]\n}\n\nresource \"aws_iam_role_policy\" \"ec2helper\" {\n  name   = \"ec2helper\"\n  role   = aws_iam_role.LambdaRoleHelper.id\n  policy = <<EOT\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Action\": [\n                \"ec2:CreateNetworkInterface\"\n            ],\n            \"Resource\": [\n                \"arn:${data.aws_partition.current.partition}:lambda:${data.aws_region.current.name}:${data.aws_caller_identity.current.account_id}:/*\"\n            ],\n            \"Effect\": \"Allow\"\n        }\n    ]\n}\nEOT\n  depends_on = [\n    aws_iam_role.LambdaRoleHelper\n  ]\n}\n\nresource \"aws_iam_role_policy\" \"sqshelper\" {\n  name   = \"sqshelper\"\n  role   = aws_iam_role.LambdaRoleHelper.id\n  policy = <<EOT\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Action\": [\n                \"sqs:SendMessage\"\n            ],\n            \"Resource\": [\n                \"arn:${data.aws_partition.current.partition}:sqs:${data.aws_region.current.name}:${data.aws_caller_identity.current.account_id}:*\"\n            ],\n            \"Effect\": \"Allow\"\n        }\n    ]\n}\nEOT\n  depends_on = [\n    aws_iam_role.LambdaRoleHelper\n  ]\n}\n\nresource \"aws_iam_role_policy\" \"WAFAccesshelper\" {\n  name   = \"WAFAccess1\"\n  role   = aws_iam_role.LambdaRoleHelper.id\n  policy = <<EOT\n{\n    \"Statement\": [\n        {\n            \"Action\": [\n                \"wafv2:ListWebACLs\"\n            ],\n            \"Resource\": [\n                \"arn:${data.aws_partition.current.partition}:wafv2:${data.aws_region.current.name}:${data.aws_caller_identity.current.account_id}:regional/webacl/*\",\n                \"arn:${data.aws_partition.current.partition}:wafv2:${data.aws_region.current.name}:${data.aws_caller_identity.current.account_id}:global/webacl/*\"\n            ],\n            \"Effect\": \"Allow\"\n        }\n    ]\n}\nEOT\n  depends_on = [\n    aws_iam_role.LambdaRoleHelper\n  ]\n}\n\nresource \"aws_iam_role_policy\" \"LogsAccesshelper\" {\n  name   = \"LogsAccess1\"\n  role   = aws_iam_role.LambdaRoleHelper.id\n  policy = <<EOT\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Action\": [\n                \"logs:CreateLogGroup\",\n                \"logs:CreateLogStream\",\n                \"logs:PutLogEvents\"\n            ],\n            \"Resource\": [\n                \"arn:${data.aws_partition.current.partition}:logs:${data.aws_region.current.name}:${data.aws_caller_identity.current.account_id}:log-group:/aws/lambda/*Helper*\"\n            ],\n            \"Effect\": \"Allow\"\n        }\n    ]\n}\nEOT\n  depends_on = [\n    aws_iam_role.LambdaRoleHelper\n  ]\n}\n\n#Role 2 - LambdaRoleBadBot\n\nresource \"aws_iam_role\" \"LambdaRoleBadBot\" {\n  count = var.BadBotProtectionActivated == \"yes\" ? 1 : 0\n  name  = \"LambdaRoleBadBot1-${random_id.server.hex}\"\n\n  assume_role_policy = <<EOF\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Action\": \"sts:AssumeRole\",\n      \"Principal\": {\n        \"Service\": \"lambda.amazonaws.com\"\n      },\n      \"Effect\": \"Allow\",\n      \"Sid\": \"\"\n    }\n  ]\n}\nEOF\n}\n\nresource \"aws_iam_role_policy\" \"ec2badbot\" {\n  count  = var.BadBotProtectionActivated == \"yes\" ? 1 : 0\n  name   = \"ec2badbot\"\n  role   = aws_iam_role.LambdaRoleBadBot[0].id\n  policy = <<EOT\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Action\": [\n                \"ec2:CreateNetworkInterface\"\n            ],\n            \"Resource\": [\n                \"arn:${data.aws_partition.current.partition}:lambda:${data.aws_region.current.name}:${data.aws_caller_identity.current.account_id}:/*\"\n            ],\n            \"Effect\": \"Allow\"\n        }\n    ]\n}\nEOT\n  depends_on = [\n    aws_iam_role.LambdaRoleBadBot\n  ]\n}\n\nresource \"aws_iam_role_policy\" \"sqsbadbot\" {\n  count  = var.BadBotProtectionActivated == \"yes\" ? 1 : 0\n  name   = \"sqsbadbot\"\n  role   = aws_iam_role.LambdaRoleBadBot[0].id\n  policy = <<EOT\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Action\": [\n                \"sqs:SendMessage\"\n            ],\n            \"Resource\": [\n                \"arn:${data.aws_partition.current.partition}:sqs:${data.aws_region.current.name}:${data.aws_caller_identity.current.account_id}:*\"\n            ],\n            \"Effect\": \"Allow\"\n        }\n    ]\n}\nEOT\n  depends_on = [\n    aws_iam_role.LambdaRoleBadBot\n  ]\n}\n\nresource \"aws_iam_role_policy\" \"LogsAccessbadbot\" {\n  name   = \"LogsAccess1\"\n  role   = aws_iam_role.LambdaRoleBadBot[0].id\n  policy = <<EOT\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Action\": [\n                \"logs:CreateLogGroup\",\n                \"logs:CreateLogStream\",\n                \"logs:PutLogEvents\"\n            ],\n            \"Resource\": [\n                \"arn:${data.aws_partition.current.partition}:logs:${data.aws_region.current.name}:${data.aws_caller_identity.current.account_id}:log-group:/aws/lambda/*BadBotParser*\"\n            ],\n            \"Effect\": \"Allow\"\n        }\n    ]\n}\nEOT\n  depends_on = [\n    aws_iam_role.LambdaRoleBadBot\n  ]\n}\n\nresource \"aws_iam_role_policy\" \"CloudWatchAccessbadbot\" {\n  name   = \"CloudWatchAccess1\"\n  role   = aws_iam_role.LambdaRoleBadBot[0].id\n  policy = <<EOT\n{\n    \"Statement\": [\n        {\n            \"Action\": \"cloudwatch:GetMetricStatistics\",\n            \"Resource\": [\n                \"*\"\n            ],\n            \"Effect\": \"Allow\"\n        }\n    ]\n}\nEOT\n  depends_on = [\n    aws_iam_role.LambdaRoleBadBot\n  ]\n}\n\nresource \"aws_iam_role_policy\" \"WAFGetAndUpdateIPSetbadbot\" {\n  name   = \"WAFGetAndUpdateIPSet1\"\n  role   = aws_iam_role.LambdaRoleBadBot[0].id\n  policy = <<EOT\n{\n    \"Statement\": [\n        {\n            \"Action\": [\n                \"wafv2:GetIPSet\",\n                \"wafv2:UpdateIPSet\"\n            ],\n            \"Resource\": [\n                \"${aws_wafv2_ip_set.WAFBadBotSetV4[0].arn}\",\n                \"${aws_wafv2_ip_set.WAFBadBotSetV6[0].arn}\"\n                ],\n            \"Effect\": \"Allow\"\n        }\n    ]\n}\nEOT\n  depends_on = [\n    aws_iam_role.LambdaRoleBadBot\n  ]\n}\n\n#Role 3 - LambdaRolePartitionS3Logs\n\nresource \"aws_iam_role\" \"LambdaRolePartitionS3Logs\" {\n  count              = local.ScannersProbesAthenaLogParser == \"yes\" ? 1 : 0\n  name               = \"LambdaRolePartitionS3Logs1-${random_id.server.hex}\"\n  assume_role_policy = <<EOF\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Action\": \"sts:AssumeRole\",\n      \"Principal\": {\n        \"Service\": \"lambda.amazonaws.com\"\n      },\n      \"Effect\": \"Allow\",\n      \"Sid\": \"\"\n    }\n  ]\n}\nEOF\n}\n\nresource \"aws_iam_role_policy\" \"ec2Partition\" {\n  count  = local.ScannersProbesAthenaLogParser == \"yes\" ? 1 : 0\n  name   = \"ec2Partition\"\n  role   = aws_iam_role.LambdaRolePartitionS3Logs[0].id\n  policy = <<EOT\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Action\": [\n                \"ec2:CreateNetworkInterface\"\n            ],\n            \"Resource\": [\n                \"arn:${data.aws_partition.current.partition}:lambda:${data.aws_region.current.name}:${data.aws_caller_identity.current.account_id}:/*\"\n            ],\n            \"Effect\": \"Allow\"\n        }\n    ]\n}\nEOT\n  depends_on = [\n    aws_iam_role.LambdaRolePartitionS3Logs\n  ]\n}\n\nresource \"aws_iam_role_policy\" \"sqspartition\" {\n  count  = local.ScannersProbesAthenaLogParser == \"yes\" ? 1 : 0\n  name   = \"sqspartition\"\n  role   = aws_iam_role.LambdaRolePartitionS3Logs[0].id\n  policy = <<EOT\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Action\": [\n                \"sqs:SendMessage\"\n            ],\n            \"Resource\": [\n                \"arn:${data.aws_partition.current.partition}:sqs:${data.aws_region.current.name}:${data.aws_caller_identity.current.account_id}:*\"\n            ],\n            \"Effect\": \"Allow\"\n        }\n    ]\n}\nEOT\n  depends_on = [\n    aws_iam_role.LambdaRolePartitionS3Logs\n  ]\n}\n\n\nresource \"aws_iam_role_policy\" \"PartitionS3LogsAccess\" {\n  count  = local.ScannersProbesAthenaLogParser == \"yes\" ? 1 : 0\n  name   = \"PartitionS3LogsAccess1\"\n  role   = aws_iam_role.LambdaRolePartitionS3Logs[0].id\n  policy = <<EOT\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Action\": [\n                \"s3:GetObject\",\n                \"s3:DeleteObject\",\n                \"s3:PutObject\"\n            ],\n            \"Resource\": [\n                \"arn:${data.aws_partition.current.partition}:s3:::${local.AppLogBucket}/*\"\n            ],\n            \"Effect\": \"Allow\"\n        }\n    ]\n}\nEOT\n  depends_on = [\n    aws_iam_role.LambdaRolePartitionS3Logs\n  ]\n}\n\nresource \"aws_iam_role_policy\" \"LogsAccesshelperPartitions3\" {\n  count  = local.ScannersProbesAthenaLogParser == \"yes\" ? 1 : 0\n  name   = \"LogsAccess1\"\n  role   = aws_iam_role.LambdaRolePartitionS3Logs[0].id\n  policy = <<EOT\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Action\": [\n                \"logs:CreateLogGroup\",\n                \"logs:CreateLogStream\",\n                \"logs:PutLogEvents\"\n            ],\n            \"Resource\": [\n                \"arn:${data.aws_partition.current.partition}:logs:${data.aws_region.current.name}:${data.aws_caller_identity.current.account_id}:log-group:/aws/lambda/*MoveS3LogsForPartition*\"\n            ],\n            \"Effect\": \"Allow\"\n        }\n    ]\n}\nEOT\n  depends_on = [\n    aws_iam_role.LambdaRolePartitionS3Logs\n  ]\n}\n\n#Role 4 - LambdaRoleSetIPRetention\n\nresource \"aws_iam_role\" \"LambdaRoleSetIPRetention\" {\n  count = var.IPRetentionPeriod == \"yes\" ? 1 : 0\n  name  = \"LambdaRoleSetIPRetention1-${random_id.server.hex}\"\n\n  assume_role_policy = <<EOF\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Action\": \"sts:AssumeRole\",\n      \"Principal\": {\n        \"Service\": \"lambda.amazonaws.com\"\n      },\n      \"Effect\": \"Allow\",\n      \"Sid\": \"\"\n    }\n  ]\n}\nEOF\n}\n\nresource \"aws_iam_role_policy\" \"ec2retention\" {\n  count  = var.IPRetentionPeriod == \"yes\" ? 1 : 0\n  name   = \"ec2retention\"\n  role   = aws_iam_role.LambdaRoleSetIPRetention[0].id\n  policy = <<EOT\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Action\": [\n                \"ec2:CreateNetworkInterface\"\n            ],\n            \"Resource\": [\n                \"arn:${data.aws_partition.current.partition}:lambda:${data.aws_region.current.name}:${data.aws_caller_identity.current.account_id}:/*\"\n            ],\n            \"Effect\": \"Allow\"\n        }\n    ]\n}\nEOT\n  depends_on = [\n    aws_iam_role.LambdaRoleSetIPRetention\n  ]\n}\n\nresource \"aws_iam_role_policy\" \"sqsretention\" {\n  count  = var.IPRetentionPeriod == \"yes\" ? 1 : 0\n  name   = \"sqsretention\"\n  role   = aws_iam_role.LambdaRoleSetIPRetention[0].id\n  policy = <<EOT\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Action\": [\n                \"sqs:SendMessage\"\n            ],\n            \"Resource\": [\n                \"arn:${data.aws_partition.current.partition}:sqs:${data.aws_region.current.name}:${data.aws_caller_identity.current.account_id}:*\"\n            ],\n            \"Effect\": \"Allow\"\n        }\n    ]\n}\nEOT\n  depends_on = [\n    aws_iam_role.LambdaRoleSetIPRetention\n  ]\n}\n\nresource \"aws_iam_role_policy\" \"LogsAccessSetIPRetention\" {\n  count  = var.IPRetentionPeriod == \"yes\" ? 1 : 0\n  name   = \"LogsAccess1\"\n  role   = aws_iam_role.LambdaRoleSetIPRetention[0].id\n  policy = <<EOT\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Action\": [\n                \"logs:CreateLogGroup\",\n                \"logs:CreateLogStream\",\n                \"logs:PutLogEvents\"\n            ],\n            \"Resource\": [\n                \"arn:${data.aws_partition.current.partition}:logs:${data.aws_region.current.name}:${data.aws_caller_identity.current.account_id}:log-group:/aws/lambda/*SetIPRetention*\"\n            ],\n            \"Effect\": \"Allow\"\n        }\n    ]\n}\nEOT\n  depends_on = [\n    aws_iam_role.LambdaRoleSetIPRetention\n  ]\n}\n\nresource \"aws_iam_role_policy\" \"DDBAccess\" {\n  count  = var.IPRetentionPeriod == \"yes\" ? 1 : 0\n  name   = \"DDBAccess1\"\n  role   = aws_iam_role.LambdaRoleSetIPRetention[0].id\n  policy = <<EOT\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Action\": [\n                \"dynamodb:PutItem\"\n            ],\n            \"Resource\": [\n               \"${aws_dynamodb_table.IPRetentionDDBTable[0].arn}\"\n            ],\n            \"Effect\": \"Allow\"\n        }\n    ]\n}\nEOT\n  depends_on = [\n    aws_iam_role.LambdaRoleSetIPRetention\n  ]\n}\n\n#Role 5 - LambdaRoleRemoveExpiredIP\n\nresource \"aws_iam_role\" \"LambdaRoleRemoveExpiredIP\" {\n  count = var.IPRetentionPeriod == \"yes\" ? 1 : 0\n  name  = \"LambdaRoleRemoveExpiredIP1-${random_id.server.hex}\"\n\n  assume_role_policy = <<EOF\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Action\": \"sts:AssumeRole\",\n      \"Principal\": {\n        \"Service\": \"lambda.amazonaws.com\"\n      },\n      \"Effect\": \"Allow\",\n      \"Sid\": \"\"\n    }\n  ]\n}\nEOF\n}\n\nresource \"aws_iam_role_policy\" \"ec2expired\" {\n  count  = var.IPRetentionPeriod == \"yes\" ? 1 : 0\n  name   = \"ec2expired\"\n  role   = aws_iam_role.LambdaRoleRemoveExpiredIP[0].id\n  policy = <<EOT\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Action\": [\n                \"ec2:CreateNetworkInterface\"\n            ],\n            \"Resource\": [\n                \"arn:${data.aws_partition.current.partition}:lambda:${data.aws_region.current.name}:${data.aws_caller_identity.current.account_id}:/*\"\n            ],\n            \"Effect\": \"Allow\"\n        }\n    ]\n}\nEOT\n  depends_on = [\n    aws_iam_role.LambdaRoleRemoveExpiredIP\n  ]\n}\n\nresource \"aws_iam_role_policy\" \"SNSPublishPolicy\" {\n  count  = var.IPRetentionPeriod == \"yes\" ? 1 : 0\n  name   = \"LogsAccess1\"\n  role   = aws_iam_role.LambdaRoleRemoveExpiredIP[0].id\n  policy = <<EOT\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Action\": [\n                \"SNS:Publish\"\n            ],\n            \"Resource\": [\n                \"${aws_sns_topic.user_updates[0].arn}\"\n            ],\n            \"Effect\": \"Allow\"\n        }\n    ]\n}\nEOT\n  depends_on = [\n    aws_iam_role.LambdaRoleRemoveExpiredIP\n  ]\n}\n\nresource \"aws_iam_role_policy\" \"LogsAccessLambdaRoleRemoveExpiredIP\" {\n  count  = var.IPRetentionPeriod == \"yes\" ? 1 : 0\n  name   = \"LogsAccess1\"\n  role   = aws_iam_role.LambdaRoleRemoveExpiredIP[0].id\n  policy = <<EOT\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Action\": [\n                \"logs:CreateLogGroup\",\n                \"logs:CreateLogStream\",\n                \"logs:PutLogEvents\"\n            ],\n            \"Resource\": [\n                \"arn:${data.aws_partition.current.partition}:logs:${data.aws_region.current.name}:${data.aws_caller_identity.current.account_id}:log-group:/aws/lambda/*RemoveExpiredIP*\"\n            ],\n            \"Effect\": \"Allow\"\n        }\n    ]\n}\nEOT\n  depends_on = [\n    aws_iam_role.LambdaRoleRemoveExpiredIP\n  ]\n}\n\nresource \"aws_iam_role_policy\" \"WAFAccessLambdaRoleRemoveExpiredIP\" {\n  count  = var.IPRetentionPeriod == \"yes\" ? 1 : 0\n  name   = \"WAFAccess1\"\n  role   = aws_iam_role.LambdaRoleRemoveExpiredIP[0].id\n  policy = <<EOT\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Action\": [\n                \"dynamodb:GetShardIterator\",\n                \"dynamodb:DescribeStream\",\n                \"dynamodb:GetRecords\",\n                \"dynamodb:ListStreams\"\n            ],\n            \"Resource\": [\n                \"${aws_wafv2_ip_set.WAFWhitelistSetV4.arn}\",\n                \"${aws_wafv2_ip_set.WAFBlacklistSetV6.arn}\",\n                \"${aws_wafv2_ip_set.WAFWhitelistSetV6.arn}\",\n                \"${aws_wafv2_ip_set.WAFBlacklistSetV6.arn}\"\n            ],\n            \"Effect\": \"Allow\"\n        }\n    ]\n}\nEOT\n  depends_on = [\n    aws_iam_role.LambdaRoleRemoveExpiredIP\n  ]\n}\n\nresource \"aws_iam_role_policy\" \"sqsexpired\" {\n  count  = var.IPRetentionPeriod == \"yes\" ? 1 : 0\n  name   = \"sqsexpired\"\n  role   = aws_iam_role.LambdaRoleRemoveExpiredIP[0].id\n  policy = <<EOT\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Action\": [\n                \"sqs:SendMessage\"\n            ],\n            \"Resource\": [\n                \"arn:${data.aws_partition.current.partition}:sqs:${data.aws_region.current.name}:${data.aws_caller_identity.current.account_id}:*\"\n            ],\n            \"Effect\": \"Allow\"\n        }\n    ]\n}\nEOT\n  depends_on = [\n    aws_iam_role.LambdaRoleRemoveExpiredIP\n  ]\n}\n\nresource \"aws_iam_role_policy\" \"DDBStreamAccess\" {\n  count  = var.IPRetentionPeriod == \"yes\" ? 1 : 0\n  name   = \"DDBStreamAccess\"\n  role   = aws_iam_role.LambdaRoleRemoveExpiredIP[0].id\n  policy = <<EOT\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Action\": [\n                \"wafv2:GetIPSet\",\n                \"wafv2:UpdateIPSet\"\n            ],\n            \"Resource\": [\n               \"${aws_dynamodb_table.IPRetentionDDBTable[0].arn}\"\n            ],\n            \"Effect\": \"Allow\"\n        }\n    ]\n}\nEOT\n  depends_on = [\n    aws_iam_role.LambdaRoleRemoveExpiredIP\n  ]\n}\nresource \"aws_iam_role_policy\" \"InvokeLambda\" {\n  count  = var.IPRetentionPeriod == \"yes\" ? 1 : 0\n  name   = \"InvokeLambda1\"\n  role   = aws_iam_role.LambdaRoleRemoveExpiredIP[0].id\n  policy = <<EOT\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Action\": [\n                \"lambda:InvokeFunction\"\n            ],\n            \"Resource\": [\n               \"${aws_dynamodb_table.IPRetentionDDBTable[0].arn}\"\n            ],\n            \"Effect\": \"Allow\"\n        }\n    ]\n}\nEOT\n  depends_on = [\n    aws_iam_role.LambdaRoleRemoveExpiredIP\n  ]\n}\n\n#ROLE6  LambdaRoleReputationListsParser\n\nresource \"aws_iam_role\" \"LambdaRoleReputationListsParser\" {\n  count = var.ReputationListsProtectionActivated == \"yes\" ? 1 : 0\n  name  = \"LambdaRoleReputParser1-${random_id.server.hex}\"\n\n  assume_role_policy = <<EOF\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Action\": \"sts:AssumeRole\",\n      \"Principal\": {\n        \"Service\": \"lambda.amazonaws.com\"\n      },\n      \"Effect\": \"Allow\",\n      \"Sid\": \"\"\n    }\n  ]\n}\nEOF\n}\n\nresource \"aws_iam_role_policy\" \"ec2reputation\" {\n  count  = var.ReputationListsProtectionActivated == \"yes\" ? 1 : 0\n  name   = \"ec2reputation\"\n  role   = aws_iam_role.LambdaRoleReputationListsParser[0].id\n  policy = <<EOT\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Action\": [\n                \"ec2:CreateNetworkInterface\"\n            ],\n            \"Resource\": [\n                \"arn:${data.aws_partition.current.partition}:lambda:${data.aws_region.current.name}:${data.aws_caller_identity.current.account_id}:/*\"\n            ],\n            \"Effect\": \"Allow\"\n        }\n    ]\n}\nEOT\n  depends_on = [\n    aws_iam_role.LambdaRoleReputationListsParser\n  ]\n}\n\nresource \"aws_iam_role_policy\" \"CloudWatchLogsListsParser\" {\n  count  = var.ReputationListsProtectionActivated == \"yes\" ? 1 : 0\n  name   = \"CloudWatchLogs1\"\n  role   = aws_iam_role.LambdaRoleReputationListsParser[0].id\n  policy = <<EOT\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Action\": [\n                \"logs:CreateLogGroup\",\n                \"logs:CreateLogStream\",\n                \"logs:PutLogEvents\"\n            ],\n            \"Resource\": [\n                \"arn:${data.aws_partition.current.partition}:logs:${data.aws_region.current.name}:${data.aws_caller_identity.current.account_id}:log-group:/aws/lambda/*ReputationListsParser*\"\n            ],\n            \"Effect\": \"Allow\"\n        }\n    ]\n}\nEOT\n  depends_on = [\n    aws_iam_role.LambdaRoleReputationListsParser\n  ]\n}\n\nresource \"aws_iam_role_policy\" \"sqsreputation\" {\n  count  = var.ReputationListsProtectionActivated == \"yes\" ? 1 : 0\n  name   = \"sqsreputation\"\n  role   = aws_iam_role.LambdaRoleReputationListsParser[0].id\n  policy = <<EOT\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Action\": [\n                \"sqs:SendMessage\"\n            ],\n            \"Resource\": [\n                \"arn:${data.aws_partition.current.partition}:sqs:${data.aws_region.current.name}:${data.aws_caller_identity.current.account_id}:*\"\n            ],\n            \"Effect\": \"Allow\"\n        }\n    ]\n}\nEOT\n  depends_on = [\n    aws_iam_role.LambdaRoleReputationListsParser\n  ]\n}\n\nresource \"aws_iam_role_policy\" \"CloudWatchAccessListsParser\" {\n  count  = var.ReputationListsProtectionActivated == \"yes\" ? 1 : 0\n  name   = \"CloudWatchAccess1\"\n  role   = aws_iam_role.LambdaRoleReputationListsParser[0].id\n  policy = <<EOT\n{\n    \"Statement\": [\n        {\n            \"Action\": \"cloudwatch:GetMetricStatistics\",\n            \"Resource\": [\n                \"*\"\n            ],\n            \"Effect\": \"Allow\"\n        }\n    ]\n}\nEOT\n  depends_on = [\n    aws_iam_role.LambdaRoleReputationListsParser\n  ]\n}\n\nresource \"aws_iam_role_policy\" \"WAFGetAndUpdateIPListsParser\" {\n  name   = \"WAFGetAndUpdateIPSet1\"\n  role   = aws_iam_role.LambdaRoleReputationListsParser[0].id\n  policy = <<EOT\n{\n    \"Statement\": [\n        {\n            \"Action\": [\n                \"wafv2:GetIPSet\",\n                \"wafv2:UpdateIPSet\"\n            ],\n            \"Resource\": [\n                \"${aws_wafv2_ip_set.WAFReputationListsSetV4[0].arn}\",\n                \"${aws_wafv2_ip_set.WAFReputationListsSetV6[0].arn}\"\n                ],\n            \"Effect\": \"Allow\"\n        }\n    ]\n}\nEOT\n  depends_on = [\n    aws_iam_role.LambdaRoleReputationListsParser\n  ]\n}\n\n#Role 7 - LambdaRoleCustomResource\n\nresource \"aws_iam_role\" \"LambdaRoleCustomResource\" {\n  name = \"LambdaRoleCustomResource1-${random_id.server.hex}\"\n\n  assume_role_policy = <<EOF\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Action\": \"sts:AssumeRole\",\n      \"Principal\": {\n        \"Service\": \"lambda.amazonaws.com\"\n      },\n      \"Effect\": \"Allow\",\n      \"Sid\": \"\"\n    }\n  ]\n}\nEOF\n}\n\nresource \"aws_iam_role_policy\" \"ec2customresource\" {\n  name   = \"ec2customresource\"\n  role   = aws_iam_role.LambdaRoleCustomResource.id\n  policy = <<EOT\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Action\": [\n                \"ec2:CreateNetworkInterface\"\n            ],\n            \"Resource\": [\n                \"arn:${data.aws_partition.current.partition}:lambda:${data.aws_region.current.name}:${data.aws_caller_identity.current.account_id}:/*\"\n            ],\n            \"Effect\": \"Allow\"\n        }\n    ]\n}\nEOT\n  depends_on = [\n    aws_iam_role.LambdaRoleCustomResource\n  ]\n}\n\nresource \"aws_iam_role_policy\" \"sqscustomresource\" {\n  name   = \"sqscustomresource\"\n  role   = aws_iam_role.LambdaRoleCustomResource.id\n  policy = <<EOT\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Action\": [\n                \"sqs:SendMessage\"\n            ],\n            \"Resource\": [\n                \"arn:${data.aws_partition.current.partition}:sqs:${data.aws_region.current.name}:${data.aws_caller_identity.current.account_id}:*\"\n            ],\n            \"Effect\": \"Allow\"\n        }\n    ]\n}\nEOT\n  depends_on = [\n    aws_iam_role.LambdaRoleCustomResource\n  ]\n}\n\nresource \"aws_iam_role_policy\" \"S3AccessGeneralAppAccessLog\" {\n  name   = \"S3AccessGeneralAppAccessLog1\"\n  role   = aws_iam_role.LambdaRoleCustomResource.id\n  policy = <<EOT\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Action\": [\n                \"s3:CreateBucket\",\n                \"s3:GetBucketNotification\",\n                \"s3:PutBucketNotification\",\n                \"s3:PutEncryptionConfiguration\",\n                \"s3:PutBucketPublicAccessBlock\"\n            ],\n            \"Resource\": [\n                \"arn:${data.aws_partition.current.partition}:s3:::${local.AppLogBucket}\"\n            ],\n            \"Effect\": \"Allow\"\n        }\n    ]\n}\nEOT\n  depends_on = [\n    aws_iam_role.LambdaRoleCustomResource\n  ]\n}\n\nresource \"aws_iam_role_policy\" \"S3AccessGeneralWafLog\" {\n  count  = local.HttpFloodProtectionLogParserActivated == \"yes\" ? 1 : 0\n  name   = \"S3AccessGeneralWafLog1\"\n  role   = aws_iam_role.LambdaRoleCustomResource.id\n  policy = <<EOT\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Action\": [\n                \"s3:CreateBucket\",\n                \"s3:GetBucketNotification\",\n                \"s3:PutBucketNotification\"\n            ],\n            \"Resource\": [\n                \"arn:${data.aws_partition.current.partition}:s3:::${aws_s3_bucket.WafLogBucket[0].bucket}\"\n            ],\n            \"Effect\": \"Allow\"\n        }\n    ]\n}\nEOT\n  depends_on = [\n    aws_iam_role.LambdaRoleCustomResource\n  ]\n}\n\nresource \"aws_iam_role_policy\" \"S3Access\" {\n  name   = \"S3Access1\"\n  role   = aws_iam_role.LambdaRoleCustomResource.id\n  policy = <<EOT\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Action\": [\n                \"s3:GetBucketLocation\",\n                \"s3:GetObject\",\n                \"s3:ListBucket\"\n            ],\n            \"Resource\": [\n                \"arn:${data.aws_partition.current.partition}:s3:::${local.AppLogBucket}\"\n            ],\n            \"Effect\": \"Allow\"\n        }\n    ]\n}\nEOT\n  depends_on = [\n    aws_iam_role.LambdaRoleCustomResource\n  ]\n}\n\nresource \"aws_iam_role_policy\" \"S3AppAccessPut\" {\n  count  = local.ScannersProbesLambdaLogParser == \"yes\" ? 1 : 0\n  name   = \"S3AppAccessPut1\"\n  role   = aws_iam_role.LambdaRoleCustomResource.id\n  policy = <<EOT\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Action\": [\n                \"s3:PutObject\"\n            ],\n            \"Resource\": [\n                \"arn:${data.aws_partition.current.partition}:s3:::${local.AppLogBucket}/*app_log_conf.json\"\n            ],\n            \"Effect\": \"Allow\"\n        }\n    ]\n}\nEOT\n  depends_on = [\n    aws_iam_role.LambdaRoleCustomResource\n  ]\n}\n\nresource \"aws_iam_role_policy\" \"S3WafAccessPut\" {\n  count  = local.HttpFloodLambdaLogParser == \"yes\" ? 1 : 0\n  name   = \"S3WafAccessPut1\"\n  role   = aws_iam_role.LambdaRoleCustomResource.id\n  policy = <<EOT\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Action\": [\n                \"s3:PutObject\"\n            ],\n            \"Resource\": [\n                \"arn:${data.aws_partition.current.partition}:s3:::${local.AppLogBucket}/*waf_log_conf.json\"\n            ],\n            \"Effect\": \"Allow\"\n        }\n    ]\n}\nEOT\n  depends_on = [\n    aws_iam_role.LambdaRoleCustomResource\n  ]\n}\n\nresource \"aws_iam_role_policy\" \"CustomResourceLambdaAccess\" {\n  count  = local.CustomResourceLambdaAccess == \"yes\" ? 1 : 0\n  name   = \"LambdaAccess1\"\n  role   = aws_iam_role.LambdaRoleCustomResource.id\n  policy = <<EOT\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Action\": [\n                \"lambda:InvokeFunction\"\n            ],\n            \"Resource\": [\n                \"arn:${data.aws_partition.current.partition}:lambda:${data.aws_region.current.name}:${data.aws_caller_identity.current.account_id}:function:*AddAthenaPartitions*\",\n                \"arn:${data.aws_partition.current.partition}:lambda:${data.aws_region.current.name}:${data.aws_caller_identity.current.account_id}:function:*ReputationListsParser*\"\n            ],\n            \"Effect\": \"Allow\"\n        }\n    ]\n}\nEOT\n  depends_on = [\n    aws_iam_role.LambdaRoleCustomResource\n  ]\n}\n\nresource \"aws_iam_role_policy\" \"WAFAccess\" {\n  count  = local.HttpFloodProtectionLogParserActivated == \"yes\" ? 1 : 0\n  name   = \"WAFAccess1\"\n  role   = aws_iam_role.LambdaRoleCustomResource.id\n  policy = <<EOT\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Action\": [\n                \"wafv2:GetWebACL\",\n                \"wafv2:UpdateWebACL\",\n                \"wafv2:DeleteLoggingConfiguration\"\n            ],\n            \"Resource\": [\n                \"${aws_wafv2_web_acl.wafacl.arn}\"\n            ],\n            \"Effect\": \"Allow\"\n        }\n    ]\n}\nEOT\n  depends_on = [\n    aws_iam_role.LambdaRoleCustomResource\n  ]\n}\n\nresource \"aws_iam_role_policy\" \"IPSetAccess\" {\n  name   = \"IPSetAccess1\"\n  role   = aws_iam_role.LambdaRoleCustomResource.id\n  policy = <<EOT\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Action\": [\n                \"wafv2:GetIPSet\",\n                \"wafv2:UpdateIPSet\"\n            ],\n            \"Resource\": [\n                \"arn:${data.aws_partition.current.partition}:wafv2:${data.aws_region.current.name}:${data.aws_caller_identity.current.account_id}:regional/ipset/*\",\n                \"arn:${data.aws_partition.current.partition}:wafv2:${data.aws_region.current.name}:${data.aws_caller_identity.current.account_id}:global/ipset/*\"\n                ],\n            \"Effect\": \"Allow\"\n        }\n    ]\n}\nEOT\n  depends_on = [\n    aws_iam_role.LambdaRoleCustomResource\n  ]\n}\n\nresource \"aws_iam_role_policy\" \"WAFLogsAccess\" {\n  name   = \"WAFLogsAccess1\"\n  role   = aws_iam_role.LambdaRoleCustomResource.id\n  policy = <<EOT\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Action\": [\n                \"wafv2:PutLoggingConfiguration\"\n            ],\n            \"Resource\": [\n                \"${aws_wafv2_web_acl.wafacl.arn}\"\n                ],\n            \"Effect\": \"Allow\"\n        },\n        {\n            \"Effect\": \"Allow\",\n            \"Action\": \"iam:CreateServiceLinkedRole\",\n            \"Resource\": \"arn:${data.aws_partition.current.partition}:iam::*:role/aws-service-role/wafv2.amazonaws.com/AWSServiceRoleForWAFV2Logging\",\n            \"Condition\": {\n                \"ForAnyValue:StringLike\": {\n                    \"iam:AWSServiceName\": \"wafv2.amazonaws.com\"\n                }\n            }\n        }        \n    ]\n}\nEOT\n  depends_on = [\n    aws_iam_role.LambdaRoleCustomResource\n  ]\n}\n\nresource \"aws_iam_role_policy\" \"CustomResourceLogsAccess\" {\n  name   = \"LogsAccess1\"\n  role   = aws_iam_role.LambdaRoleCustomResource.id\n  policy = <<EOT\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Action\": [\n                \"logs:CreateLogGroup\",\n                \"logs:CreateLogStream\",\n                \"logs:PutLogEvents\"\n            ],\n            \"Resource\": [\n                \"arn:${data.aws_partition.current.partition}:logs:${data.aws_region.current.name}:${data.aws_caller_identity.current.account_id}:log-group:/aws/lambda/*CustomResource*\"\n            ],\n            \"Effect\": \"Allow\"\n        }\n    ]\n}\nEOT\n  depends_on = [\n    aws_iam_role.LambdaRoleCustomResource\n  ]\n}\n\nresource \"aws_iam_role_policy\" \"CustomResourceS3BucketLoggingAccess\" {\n  count  = var.ScannersProbesProtectionActivated == \"yes\" ? 1 : 0\n  name   = \"S3BucketLoggingAccess1\"\n  role   = aws_iam_role.LambdaRoleCustomResource.id\n  policy = <<EOT\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Action\": [\n                \"s3:GetBucketLogging\",\n                \"s3:PutBucketLogging\"\n            ],\n            \"Resource\": [\n                \"arn:${data.aws_partition.current.partition}:s3:::${local.AppLogBucket}\"\n            ],\n            \"Effect\": \"Allow\"\n        }\n    ]\n}\nEOT\n  depends_on = [\n    aws_iam_role.LambdaRoleCustomResource\n  ]\n}\n\n#Role 8 - LambdaRoleLogParser\n\nresource \"aws_iam_role\" \"LambdaRoleLogParser\" {\n  count = local.LogParser == \"yes\" ? 1 : 0\n  name  = \"LambdaRoleLogParser1-${random_id.server.hex}\"\n\n  assume_role_policy = <<EOF\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Action\": \"sts:AssumeRole\",\n      \"Principal\": {\n        \"Service\": \"lambda.amazonaws.com\"\n      },\n      \"Effect\": \"Allow\",\n      \"Sid\": \"\"\n    }\n  ]\n}\nEOF\n}\n\nresource \"aws_iam_role_policy\" \"ec2logparser\" {\n  name   = \"ec2logparser\"\n  role   = aws_iam_role.LambdaRoleLogParser[0].id\n  policy = <<EOT\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Action\": [\n                \"ec2:CreateNetworkInterface\"\n            ],\n            \"Resource\": [\n                \"arn:${data.aws_partition.current.partition}:lambda:${data.aws_region.current.name}:${data.aws_caller_identity.current.account_id}:/*\"\n            ],\n            \"Effect\": \"Allow\"\n        }\n    ]\n}\nEOT\n  depends_on = [\n    aws_iam_role.LambdaRoleLogParser\n  ]\n}\n\nresource \"aws_iam_role_policy\" \"sqslogparser\" {\n  count  = local.LogParser == \"yes\" ? 1 : 0\n  name   = \"sqslogparser\"\n  role   = aws_iam_role.LambdaRoleLogParser[0].id\n  policy = <<EOT\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Action\": [\n                \"sqs:SendMessage\"\n            ],\n            \"Resource\": [\n                \"arn:${data.aws_partition.current.partition}:sqs:${data.aws_region.current.name}:${data.aws_caller_identity.current.account_id}:*\"\n            ],\n            \"Effect\": \"Allow\"\n        }\n    ]\n}\nEOT\n  depends_on = [\n    aws_iam_role.LambdaRoleLogParser\n  ]\n}\nresource \"aws_iam_role_policy\" \"S3LogParser\" {\n  count  = var.ScannersProbesProtectionActivated == \"yes\" ? 1 : 0\n  name   = \"ScannersProbesProtectionActivatedAccess\"\n  role   = aws_iam_role.LambdaRoleLogParser[0].id\n  policy = <<EOT\n{\n    \"Statement\": [\n        {\n            \"Action\": \"s3:GetObject\",\n            \"Resource\": [\n                \"arn:${data.aws_partition.current.partition}:s3:::${local.AppLogBucket}/*\"\n            ],\n            \"Effect\": \"Allow\"\n        },\n        {\n            \"Action\": \"s3:PutObject\",\n            \"Resource\": [\n                \"arn:${data.aws_partition.current.partition}:s3:::${local.AppLogBucket}/*app_log_out.json\",\n                \"arn:${data.aws_partition.current.partition}:s3:::${local.AppLogBucket}/*app_log_conf.json\"\n            ],\n            \"Effect\": \"Allow\"\n        },\n        {\n            \"Action\": [\n                \"wafv2:GetIPSet\",\n                \"wafv2:UpdateIPSet\"\n            ],\n            \"Resource\": [\n                \"${aws_wafv2_ip_set.WAFScannersProbesSetV4[0].arn}\",\n                \"${aws_wafv2_ip_set.WAFScannersProbesSetV6[0].arn}\"\n            ],\n            \"Effect\": \"Allow\"\n        }\n    ]\n}\n\nEOT\n  depends_on = [\n    aws_iam_role.LambdaRoleLogParser\n  ]\n}\n\nresource \"aws_iam_role_policy\" \"ScannersProbesAthenaLogParser\" {\n  count  = local.ScannersProbesAthenaLogParser == \"yes\" ? 1 : 0\n  name   = \"ScannersProbesAthenaLogParserAccess1\"\n  role   = aws_iam_role.LambdaRoleLogParser[0].id\n  policy = <<EOT\n{\n    \"Statement\": [\n        {\n            \"Action\": [\n            \"athena:GetNamedQuery\",\n            \"athena:StartQueryExecution\"\n            ],\n            \"Resource\": [\n                \"arn:${data.aws_partition.current.partition}:athena:${data.aws_region.current.name}:${data.aws_caller_identity.current.account_id}:workgroup/WAF*\"\n            ],\n            \"Effect\": \"Allow\"\n        },\n        {\n            \"Action\": [\n            \"s3:GetBucketLocation\",\n            \"s3:GetObject\",\n            \"s3:ListBucket\",\n            \"s3:ListBucketMultipartUploads\",\n            \"s3:ListMultipartUploadParts\",\n            \"s3:AbortMultipartUpload\",\n            \"s3:CreateBucket\",\n            \"s3:PutObject\"\n            ],\n            \"Resource\": [\n                \"arn:${data.aws_partition.current.partition}:s3:::${local.AppLogBucket}/athena_results/*\",\n                \"arn:${data.aws_partition.current.partition}:s3:::${local.AppLogBucket}\"\n            ],\n            \"Effect\": \"Allow\"\n        },\n        {\n            \"Action\": [\n                \"glue:GetTable\",\n                \"glue:GetPartitions\"\n            ],\n            \"Resource\": [\n                \"arn:${data.aws_partition.current.partition}:glue:${data.aws_region.current.name}:${data.aws_caller_identity.current.account_id}:catalog\",\n                \"arn:${data.aws_partition.current.partition}:glue:${data.aws_region.current.name}:${data.aws_caller_identity.current.account_id}:database/*\",\n                \"arn:${data.aws_partition.current.partition}:glue:${data.aws_region.current.name}:${data.aws_caller_identity.current.account_id}:table/*\"\n            ],\n            \"Effect\": \"Allow\"\n        }\n    ]\n}\n\nEOT\n  depends_on = [\n    aws_iam_role.LambdaRoleLogParser\n  ]\n}\n\nresource \"aws_iam_role_policy\" \"HttpFloodProtectionLogParser\" {\n  count  = local.HttpFloodProtectionLogParserActivated == \"yes\" ? 1 : 0\n  name   = \"HttpFloodProtectionLogParserActivatedAccess1\"\n  role   = aws_iam_role.LambdaRoleLogParser[0].id\n  policy = <<EOT\n{\n    \"Statement\": [\n        {\n            \"Action\": [\n            \"s3:GetObject\"\n            ],\n            \"Resource\": [\n                \"arn:${data.aws_partition.current.partition}:s3:::${aws_s3_bucket.WafLogBucket[0].bucket}\"\n            ],\n            \"Effect\": \"Allow\"\n        },\n        {\n            \"Action\": [\n            \"s3:PutObject\"\n            ],\n            \"Resource\": [\n                \"arn:${data.aws_partition.current.partition}:s3:::${aws_s3_bucket.WafLogBucket[0].bucket}/*log_out.json\",\n                \"arn:${data.aws_partition.current.partition}:s3:::${aws_s3_bucket.WafLogBucket[0].bucket}/*log_conf.json\"\n            ],\n            \"Effect\": \"Allow\"\n        },\n        {\n            \"Action\": [\n                \"wafv2:GetIPSet\",\n                \"wafv2:UpdateIPSet\"\n            ],\n            \"Resource\": [\n                \"${aws_wafv2_ip_set.WAFHttpFloodSetV4.arn}\",\n                \"${aws_wafv2_ip_set.WAFHttpFloodSetV6.arn}\"\n            ],\n            \"Effect\": \"Allow\"\n        }\n    ]\n}\n\nEOT\n  depends_on = [\n    aws_iam_role.LambdaRoleLogParser\n  ]\n}\n\nresource \"aws_iam_role_policy\" \"HttpFloodAthenaLogParser\" {\n  count  = local.HttpFloodAthenaLogParser == \"yes\" ? 1 : 0\n  name   = \"HttpFloodAthenaLogParserAccess1\"\n  role   = aws_iam_role.LambdaRoleLogParser[0].id\n  policy = <<EOT\n{\n    \"Statement\": [\n        {\n            \"Action\": [\n            \"athena:GetNamedQuery\",\n            \"athena:StartQueryExecution\"\n            ],\n            \"Resource\": [\n                \"arn:${data.aws_partition.current.partition}:athena:::${data.aws_region.current.name}:${data.aws_caller_identity.current.account_id}:workgroup/WAF*\"\n            ],\n            \"Effect\": \"Allow\"\n        },\n        {\n            \"Action\": [\n            \"s3:GetBucketLocation\",\n            \"s3:GetObject\",\n            \"s3:ListBucket\",\n            \"s3:ListBucketMultipartUploads\",\n            \"s3:ListMultipartUploadParts\",\n            \"s3:AbortMultipartUpload\",\n            \"s3:CreateBucket\",\n            \"s3:PutObject\"\n            ],\n            \"Resource\": [\n                \"arn:${data.aws_partition.current.partition}:s3:::${aws_s3_bucket.WafLogBucket[0].bucket}/athena_results/*\",\n                \"arn:${data.aws_partition.current.partition}:s3:::${aws_s3_bucket.WafLogBucket[0].bucket}\"\n            ],\n            \"Effect\": \"Allow\"\n        },\n        {\n            \"Action\": [\n                \"glue:GetTable\",\n                \"glue:GetPartitions\"\n            ],\n            \"Resource\": [\n                \"arn:${data.aws_partition.current.partition}:glue:${data.aws_region.current.name}:${data.aws_caller_identity.current.account_id}:catalog\",\n                \"arn:${data.aws_partition.current.partition}:glue:${data.aws_region.current.name}:${data.aws_caller_identity.current.account_id}:database/*\",\n                \"arn:${data.aws_partition.current.partition}:glue:${data.aws_region.current.name}:${data.aws_caller_identity.current.account_id}:table/*\"\n            ],\n            \"Effect\": \"Allow\"\n        }\n    ]\n}\n\nEOT\n  depends_on = [\n    aws_iam_role.LambdaRoleLogParser\n  ]\n}\n\nresource \"aws_iam_role_policy\" \"LambdaRoleLogsAccess1\" {\n  name   = \"LogsAccess1\"\n  role   = aws_iam_role.LambdaRoleLogParser[0].id\n  policy = <<EOT\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Action\": [\n                \"logs:CreateLogGroup\",\n                \"logs:CreateLogStream\",\n                \"logs:PutLogEvents\"\n            ],\n            \"Resource\": [\n                \"arn:${data.aws_partition.current.partition}:logs:${data.aws_region.current.name}:${data.aws_caller_identity.current.account_id}:log-group:/aws/lambda/*LogParser*\"\n            ],\n            \"Effect\": \"Allow\"\n        }\n    ]\n}\nEOT\n  depends_on = [\n    aws_iam_role.LambdaRoleLogParser\n  ]\n}\n\nresource \"aws_iam_role_policy\" \"LambdaRoleCloudWatchAccess\" {\n  name   = \"CloudWatchAccess1\"\n  role   = aws_iam_role.LambdaRoleLogParser[0].id\n  policy = <<EOT\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Action\": [\n                \"cloudwatch:GetMetricStatistics\"\n            ],\n            \"Resource\": [\n                \"*\"\n            ],\n            \"Effect\": \"Allow\"\n        }\n    ]\n}\nEOT\n  depends_on = [\n    aws_iam_role.LambdaRoleLogParser[0]\n  ]\n}\n\n#Role 9 - LambdaRoleAddAthenaPartitions\n\nresource \"aws_iam_role\" \"LambdaRoleAddAthenaPartitions\" {\n  count = local.AthenaLogParser == \"yes\" ? 1 : 0\n  name  = \"LambdaRoleAddAthenaPartitions1-${random_id.server.hex}\"\n\n  assume_role_policy = <<EOF\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Action\": \"sts:AssumeRole\",\n      \"Principal\": {\n        \"Service\": \"lambda.amazonaws.com\"\n      },\n      \"Effect\": \"Allow\",\n      \"Sid\": \"\"\n    }\n  ]\n}\nEOF\n}\n\nresource \"aws_iam_role_policy\" \"AddAthenaPartitionsForAppAccessLog\" {\n  count  = local.ScannersProbesAthenaLogParser == \"yes\" ? 1 : 0\n  name   = \"AddAthenaPartitionsForAppAccessLog1\"\n  role   = aws_iam_role.LambdaRoleAddAthenaPartitions[0].id\n  policy = <<EOT\n{\n    \"Statement\": [\n        {\n            \"Action\": [\n            \"athena:StartQueryExecution\"\n            ],\n            \"Resource\": [\n                \"arn:${data.aws_partition.current.partition}:athena:${data.aws_region.current.name}:${data.aws_caller_identity.current.account_id}:workgroup/WAF*\"\n            ],\n            \"Effect\": \"Allow\"\n        },\n        {\n            \"Action\": [\n            \"s3:GetBucketLocation\",\n            \"s3:GetObject\",\n            \"s3:ListBucket\",\n            \"s3:ListBucketMultipartUploads\",\n            \"s3:ListMultipartUploadParts\",\n            \"s3:AbortMultipartUpload\",\n            \"s3:CreateBucket\",\n            \"s3:PutObject\"\n            ],\n            \"Resource\": [\n                \"arn:${data.aws_partition.current.partition}:s3:::${local.AppLogBucket}/athena_results/*\",\n                \"arn:${data.aws_partition.current.partition}:s3:::${local.AppLogBucket}\",\n                \"arn:${data.aws_partition.current.partition}:s3:::${local.AppLogBucket}/*\"\n            ],\n            \"Effect\": \"Allow\"\n        },\n        {\n            \"Action\": [\n                \"glue:GetTable\",\n                \"glue:GetDatabase\",\n                \"glue:UpdateDatabase\",\n                \"glue:CreateDatabase\",\n                \"glue:BatchCreatePartition\"\n            ],\n            \"Resource\": [\n                \"arn:${data.aws_partition.current.partition}:glue:${data.aws_region.current.name}:${data.aws_caller_identity.current.account_id}:catalog\",\n                \"arn:${data.aws_partition.current.partition}:glue:${data.aws_region.current.name}:${data.aws_caller_identity.current.account_id}:database/default\",\n                \"arn:${data.aws_partition.current.partition}:glue:${data.aws_region.current.name}:${data.aws_caller_identity.current.account_id}:database/*\",\n                \"arn:${data.aws_partition.current.partition}:glue:${data.aws_region.current.name}:${data.aws_caller_identity.current.account_id}:table/*\"\n            ],\n            \"Effect\": \"Allow\"\n        }\n    ]\n}\n\nEOT\n  depends_on = [\n    aws_iam_role.LambdaRoleAddAthenaPartitions\n  ]\n}\n\nresource \"aws_iam_role_policy\" \"AddAthenaPartitionsForWAFLog\" {\n  count  = local.HttpFloodAthenaLogParser == \"yes\" ? 1 : 0\n  name   = \"AddAthenaPartitionsForWAFLog1\"\n  role   = aws_iam_role.LambdaRoleAddAthenaPartitions[0].id\n  policy = <<EOT\n{\n    \"Statement\": [\n        {\n            \"Action\": [\n            \"athena:StartQueryExecution\"\n            ],\n            \"Resource\": [\n                \"arn:${data.aws_partition.current.partition}:athena:${data.aws_region.current.name}:${data.aws_caller_identity.current.account_id}:workgroup/WAF*\"\n            ],\n            \"Effect\": \"Allow\"\n        },\n        {\n            \"Action\": [\n            \"s3:GetBucketLocation\",\n            \"s3:GetObject\",\n            \"s3:ListBucket\",\n            \"s3:ListBucketMultipartUploads\",\n            \"s3:ListMultipartUploadParts\",\n            \"s3:AbortMultipartUpload\",\n            \"s3:CreateBucket\",\n            \"s3:PutObject\"\n            ],\n            \"Resource\": [\n                \"arn:${data.aws_partition.current.partition}:s3:::${aws_s3_bucket.WafLogBucket[0].bucket}/athena_results/*\",\n                \"arn:${data.aws_partition.current.partition}:s3:::${aws_s3_bucket.WafLogBucket[0].bucket}\",\n                \"arn:${data.aws_partition.current.partition}:s3:::${aws_s3_bucket.WafLogBucket[0].bucket}/*\"\n            ],\n            \"Effect\": \"Allow\"\n        },\n        {\n            \"Action\": [\n                \"glue:GetTable\",\n                \"glue:GetDatabase\",\n                \"glue:UpdateDatabase\",\n                \"glue:CreateDatabase\",\n                \"glue:BatchCreatePartition\"\n            ],\n            \"Resource\": [\n                \"arn:${data.aws_partition.current.partition}:glue:${data.aws_region.current.name}:${data.aws_caller_identity.current.account_id}:catalog\",\n                \"arn:${data.aws_partition.current.partition}:glue:${data.aws_region.current.name}:${data.aws_caller_identity.current.account_id}:database/default\",\n                \"arn:${data.aws_partition.current.partition}:glue:${data.aws_region.current.name}:${data.aws_caller_identity.current.account_id}:database/*\",\n                \"arn:${data.aws_partition.current.partition}:glue:${data.aws_region.current.name}:${data.aws_caller_identity.current.account_id}:table/*\"\n            ],\n            \"Effect\": \"Allow\"\n        }\n    ]\n}\n\nEOT\n  depends_on = [\n    aws_iam_role.LambdaRoleAddAthenaPartitions\n  ]\n}\n\nresource \"aws_iam_role_policy\" \"ec2athena\" {\n  count  = local.AthenaLogParser == \"yes\" ? 1 : 0\n  name   = \"ec2athena\"\n  role   = aws_iam_role.LambdaRoleAddAthenaPartitions[0].id\n  policy = <<EOT\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Action\": [\n                \"ec2:CreateNetworkInterface\"\n            ],\n            \"Resource\": [\n                \"arn:${data.aws_partition.current.partition}:lambda:${data.aws_region.current.name}:${data.aws_caller_identity.current.account_id}:/*\"\n            ],\n            \"Effect\": \"Allow\"\n        }\n    ]\n}\nEOT\n  depends_on = [\n    aws_iam_role.LambdaRoleAddAthenaPartitions\n  ]\n}\n\nresource \"aws_iam_role_policy\" \"sqsathena\" {\n  count  = local.AthenaLogParser == \"yes\" ? 1 : 0\n  name   = \"sqsathena\"\n  role   = aws_iam_role.LambdaRoleAddAthenaPartitions[0].id\n  policy = <<EOT\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Action\": [\n                \"sqs:SendMessage\"\n            ],\n            \"Resource\": [\n                \"arn:${data.aws_partition.current.partition}:sqs:${data.aws_region.current.name}:${data.aws_caller_identity.current.account_id}:*\"\n            ],\n            \"Effect\": \"Allow\"\n        }\n    ]\n}\nEOT\n  depends_on = [\n    aws_iam_role.LambdaRoleAddAthenaPartitions\n  ]\n}\n\nresource \"aws_iam_role_policy\" \"HttpFloodAthenaLogParserLogsAccess\" {\n  count  = local.AthenaLogParser == \"yes\" ? 1 : 0\n  name   = \"LogsAccess1\"\n  role   = aws_iam_role.LambdaRoleAddAthenaPartitions[0].id\n  policy = <<EOT\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Action\": [\n                \"logs:CreateLogGroup\",\n                \"logs:CreateLogStream\",\n                \"logs:PutLogEvents\"\n            ],\n            \"Resource\": [\n                \"arn:${data.aws_partition.current.partition}:logs:${data.aws_region.current.name}:${data.aws_caller_identity.current.account_id}:log-group:/aws/lambda/*AddAthenaPartitions*\"\n            ],\n            \"Effect\": \"Allow\"\n        }\n    ]\n}\nEOT\n  depends_on = [\n    aws_iam_role.LambdaRoleAddAthenaPartitions\n  ]\n}\n\n\n\n#Role 10 - CustomTimerrole\n\nresource \"aws_iam_role\" \"LambdaRoleCustomTimer\" {\n  name = \"LambdaRoleCustomTimer-${random_id.server.hex}\"\n\n  assume_role_policy = <<EOF\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Action\": \"sts:AssumeRole\",\n      \"Principal\": {\n        \"Service\": \"lambda.amazonaws.com\"\n      },\n      \"Effect\": \"Allow\"\n    }\n  ]\n}\nEOF\n}\n\nresource \"aws_iam_role_policy\" \"ec2customtimer\" {\n  name   = \"ec2customtimer\"\n  role   = aws_iam_role.LambdaRoleCustomTimer.id\n  policy = <<EOT\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Action\": [\n                \"ec2:CreateNetworkInterface\"\n            ],\n            \"Resource\": [\n                \"arn:${data.aws_partition.current.partition}:lambda:${data.aws_region.current.name}:${data.aws_caller_identity.current.account_id}:/*\"\n            ],\n            \"Effect\": \"Allow\"\n        }\n    ]\n}\nEOT\n  depends_on = [\n    aws_iam_role.LambdaRoleCustomTimer\n  ]\n}\n\n\nresource \"aws_iam_role_policy\" \"sqscustomtimer\" {\n  name   = \"sqscustomtimer\"\n  role   = aws_iam_role.LambdaRoleCustomTimer.id\n  policy = <<EOT\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Action\": [\n                \"sqs:SendMessage\"\n            ],\n            \"Resource\": [\n                \"arn:${data.aws_partition.current.partition}:sqs:${data.aws_region.current.name}:${data.aws_caller_identity.current.account_id}:*\"\n            ],\n            \"Effect\": \"Allow\"\n        }\n    ]\n}\nEOT\n  depends_on = [\n    aws_iam_role.LambdaRoleCustomTimer\n  ]\n}\n\nresource \"aws_iam_role_policy\" \"CloudWatchLogstimer\" {\n  name   = \"CloudWatchLogstimerpolicy\"\n  role   = aws_iam_role.LambdaRoleCustomTimer.id\n  policy = <<EOT\n{\n    \"Statement\": [\n        {\n            \"Action\": [\n            \"logs:CreateLogGroup\",\n            \"logs:CreateLogGroup\",\n            \"logs:CreateLogStream\",\n            \"logs:PutLogEvents\"\n            ],\n            \"Resource\": [\n                \"arn:${data.aws_partition.current.partition}:athena:${data.aws_region.current.name}:${data.aws_caller_identity.current.account_id}:log-group:/aws/lambda/*CustomTimer*\"\n            ],\n            \"Effect\": \"Allow\"\n        }\n    ]\n}\n\nEOT\n  depends_on = [\n    aws_iam_role.LambdaRoleCustomTimer\n  ]\n}\n\n# ----------------------------------------------------------------------------------------------------------------------\n# CREATE A LAMBDA FUNCTIONS\n# ----------------------------------------------------------------------------------------------------------------------\n\n\nresource \"aws_lambda_function\" \"helper\" {\n  function_name = \"Helper-Lambda-${random_id.server.hex}\"\n  description                    = \"This lambda function verifies the main project's dependencies, requirements and implement auxiliary functions\"\n  role                           = aws_iam_role.LambdaRoleHelper.arn\n  handler                        = \"helper.lambda_handler\"\n  s3_bucket                      = \"${var.SourceBucket}-${data.aws_region.current.name}\"\n  s3_key                         = \"${var.KeyPrefix}/helper.zip\"\n  runtime                        = \"python3.8\"\n  timeout                        = 300\n  memory_size                    = 128\n  kms_key_arn                    = aws_kms_key.wafkey.arn\n  reserved_concurrent_executions = 1\n  tracing_config {\n    mode = \"Active\"\n  }\n  environment {\n    variables = {\n      LOG_LEVEL        = var.LOG_LEVEL\n      SCOPE            = local.SCOPE\n      USER_AGENT_EXTRA = var.USER_AGENT_EXTRA\n    }\n  }\n}\n\nresource \"aws_lambda_function\" \"BadBotParser\" {\n  count = var.BadBotProtectionActivated == \"yes\" ? 1 : 0\n  function_name                  = \"BadBotParser-Lambda-${random_id.server.hex}\"\n  description                    = \"This lambda function verifies the main project's dependencies, requirements and implement auxiliary functions\"\n  role                           = aws_iam_role.LambdaRoleBadBot[0].arn\n  handler                        = \"BadBotParser.lambda_handler\"\n  s3_bucket                      = \"${var.SourceBucket}-${data.aws_region.current.name}\"\n  s3_key                         = \"${var.KeyPrefix}/access_handler.zip\"\n  runtime                        = \"python3.8\"\n  timeout                        = 300\n  memory_size                    = 128\n  kms_key_arn                    = aws_kms_key.wafkey.arn\n  reserved_concurrent_executions = 1\n  tracing_config {\n    mode = \"Active\"\n  }\n  environment {\n    variables = {\n      LOG_LEVEL                 = var.LOG_LEVEL\n      SCOPE                     = local.SCOPE\n      USER_AGENT_EXTRA          = var.USER_AGENT_EXTRA\n      IP_SET_ID_BAD_BOTV4       = aws_wafv2_ip_set.WAFBadBotSetV4[0].arn\n      IP_SET_ID_BAD_BOTV6       = aws_wafv2_ip_set.WAFBadBotSetV4[0].arn\n      IP_SET_NAME_BAD_BOTV4     = aws_wafv2_ip_set.WAFBadBotSetV4[0].name\n      IP_SET_NAME_BAD_BOTV6     = aws_wafv2_ip_set.WAFBadBotSetV4[0].name\n      SEND_ANONYMOUS_USAGE_DATA = var.SEND_ANONYMOUS_USAGE_DATA\n      REGION                    = data.aws_region.current.name\n      LOG_TYPE                  = local.LOG_TYPE\n      SOLUTION_ID               = var.SolutionID\n      METRICS_URL               = var.MetricsURL\n      STACK_NAME                = \"custom-resources-stack-${random_id.server.hex}\"\n      METRIC_NAME_PREFIX        = \"customresourcesstack\"\n      UUID                      = aws_cloudformation_stack.trigger_codebuild_stack.outputs.UUID\n    }\n  }\n}\n\nresource \"aws_lambda_function\" \"MoveS3LogsForPartition\" {\n  count = local.ScannersProbesAthenaLogParser == \"yes\" ? 1 : 0\n  function_name                  = \"MoveS3LogsForPartition-Lambda-${random_id.server.hex}\"\n  description                    = \"This function is triggered by S3 event to move log files(upon their arrival in s3) from their original location to a partitioned folder structure created per timestamps in file names, hence allowing the usage of partitioning within AWS Athena.\"\n  role                           = aws_iam_role.LambdaRolePartitionS3Logs[0].arn\n  handler                        = \"partition_s3_logs.lambda_handler\"\n  s3_bucket                      = \"${var.SourceBucket}-${data.aws_region.current.name}\"\n  s3_key                         = \"${var.KeyPrefix}/log_parser.zip\"\n  runtime                        = \"python3.8\"\n  timeout                        = 300\n  memory_size                    = 512\n  kms_key_arn                    = aws_kms_key.wafkey.arn\n  reserved_concurrent_executions = 1\n  tracing_config {\n    mode = \"Active\"\n  }\n  environment {\n    variables = {\n      LOG_LEVEL          = var.LOG_LEVEL\n      ENDPOINT           = var.ENDPOINT\n      USER_AGENT_EXTRA   = var.USER_AGENT_EXTRA\n      KEEP_ORIGINAL_DATA = var.KEEP_ORIGINAL_DATA\n    }\n  }\n}\n\nresource \"aws_lambda_function\" \"SetIPRetention\" {\n  count         = var.IPRetentionPeriod == \"yes\" ? 1 : 0\n  function_name = \"SetIPRetention-Lambda-${random_id.server.hex}\"\n  description                    = \"This lambda function processes CW events for WAF UpdateIPSet API calls. It writes relevant ip retention data into a DynamoDB table.\"\n  role                           = aws_iam_role.LambdaRoleSetIPRetention[0].arn\n  handler                        = \"set_ip_retention.lambda_handler\"\n  s3_bucket                      = \"${var.SourceBucket}-${data.aws_region.current.name}\"\n  s3_key                         = \"${var.KeyPrefix}/ip_retention_handler.zip\"\n  runtime                        = \"python3.8\"\n  timeout                        = 300\n  memory_size                    = 128\n  kms_key_arn                    = aws_kms_key.wafkey.arn\n  reserved_concurrent_executions = 1\n  tracing_config {\n    mode = \"Active\"\n  }\n  environment {\n    variables = {\n      LOG_LEVEL                          = var.LOG_LEVEL\n      USER_AGENT_EXTRA                   = var.USER_AGENT_EXTRA\n      TABLE_NAME                         = aws_dynamodb_table.IPRetentionDDBTable[0].name\n      IP_RETENTION_PEROID_ALLOWED_MINUTE = var.IPRetentionPeriodAllowedParam\n      IP_RETENTION_PEROID_DENIED_MINUTE  = var.IPRetentionPeriodDeniedParam\n      REMOVE_EXPIRED_IP_LAMBDA_ROLE_NAME = aws_iam_role.LambdaRoleRemoveExpiredIP[0].name\n      STACK_NAME                         = \"custom-resources-stack-${random_id.server.hex}\"\n      METRIC_NAME_PREFIX                 = \"customresourcesstack\"\n    }\n  }\n}\n\nresource \"aws_lambda_function\" \"ReputationListsParser\" {\n  count = var.ReputationListsProtectionActivated == \"yes\" ? 1 : 0\n  function_name                  = \"ReputationListsParser-Lambda-${random_id.server.hex}\"\n  description                    = \"This lambda function checks third-party IP reputation lists hourly for new IP ranges to block. These lists include the Spamhaus Dont Route Or Peer (DROP) and Extended Drop (EDROP) lists, the Proofpoint Emerging Threats IP list, and the Tor exit node list.\"\n  role                           = aws_iam_role.LambdaRoleReputationListsParser[0].arn\n  handler                        = \"reputation-lists.lambda_handler\"\n  s3_bucket                      = \"${var.SourceBucket}-${data.aws_region.current.name}\"\n  s3_key                         = \"${var.KeyPrefix}/reputation_lists_parser.zip\"\n  runtime                        = \"python3.8\"\n  timeout                        = 300\n  memory_size                    = 512\n  kms_key_arn                    = aws_kms_key.wafkey.arn\n  reserved_concurrent_executions = 1\n  tracing_config {\n    mode = \"Active\"\n  }\n  environment {\n    variables = {\n      LOG_LEVEL                   = var.LOG_LEVEL\n      USER_AGENT_EXTRA            = var.USER_AGENT_EXTRA\n      IP_SET_ID_REPUTATIONV4      = aws_wafv2_ip_set.WAFReputationListsSetV4[0].arn\n      IP_SET_ID_REPUTATIONV6      = aws_wafv2_ip_set.WAFReputationListsSetV6[0].arn\n      IP_SET_NAME_REPUTATIONV4    = aws_wafv2_ip_set.WAFReputationListsSetV4[0].name\n      IP_SET_NAME_REPUTATIONV6    = aws_wafv2_ip_set.WAFReputationListsSetV6[0].name\n      SCOPE                       = local.SCOPE\n      LOG_TYPE                    = local.LOG_TYPE\n      SOLUTION_ID                 = var.SolutionID\n      METRICS_URL                 = var.MetricsURL\n      SEND_ANONYMOUS_USAGE_DATA   = var.SEND_ANONYMOUS_USAGE_DATA\n      IPREPUTATIONLIST_METRICNAME = \"MetricForIPReputationListsRule\"\n      STACK_NAME                  = \"custom-resources-stack-${random_id.server.hex}\"\n      METRIC_NAME_PREFIX          = \"customresourcesstack\"\n      URL_LIST                    = <<EOF\n      [\n                  {\"url\":\"https://www.spamhaus.org/drop/drop.txt\"},\n                  {\"url\":\"https://www.spamhaus.org/drop/edrop.txt\"},\n                  {\"url\":\"https://check.torproject.org/exit-addresses\", \"prefix\":\"ExitAddress\"},\n                  {\"url\":\"https://rules.emergingthreats.net/fwrules/emerging-Block-IPs.txt\"}\n                ]\n                EOF\n    }\n  }\n}\n\n\nresource \"aws_lambda_function\" \"CustomResource\" {\n  function_name = \"CustomResource-Lambda-${random_id.server.hex}\"\n  description                    = \"Log permissions are defined in the LambdaRoleCustomResource policies\"\n  role                           = aws_iam_role.LambdaRoleCustomResource.arn\n  handler                        = \"custom-resource.lambda_handler\"\n  s3_bucket                      = \"${var.SourceBucket}-${data.aws_region.current.name}\"\n  s3_key                         = \"${var.KeyPrefix}/custom_resource.zip\"\n  runtime                        = \"python3.8\"\n  timeout                        = 300\n  memory_size                    = 128\n  kms_key_arn                    = aws_kms_key.wafkey.arn\n  reserved_concurrent_executions = 1\n  tracing_config {\n    mode = \"Active\"\n  }\n  environment {\n    variables = {\n      LOG_LEVEL        = var.LOG_LEVEL\n      USER_AGENT_EXTRA = var.USER_AGENT_EXTRA\n      SCOPE            = local.SCOPE\n      SOLUTION_ID      = var.SolutionID\n      METRICS_URL      = var.MetricsURL\n    }\n  }\n}\n\nresource \"aws_lambda_function\" \"LogParser\" {\n  count         = local.LogParser == \"yes\" ? 1 : 0\n  function_name = \"LogParser-Lambda-${random_id.server.hex}\"\n  description                    = \"This function parses access logs to identify suspicious behavior, such as an abnormal amount of errors.It then blocks those IP addresses for a customer-defined period of time.\"\n  role                           = aws_iam_role.LambdaRoleLogParser[0].arn\n  handler                        = \"log-parser.lambda_handler\"\n  s3_bucket                      = \"${var.SourceBucket}-${data.aws_region.current.name}\"\n  s3_key                         = \"${var.KeyPrefix}/log_parser.zip\"\n  runtime                        = \"python3.8\"\n  timeout                        = 300\n  memory_size                    = 512\n  kms_key_arn                    = aws_kms_key.wafkey.arn\n  reserved_concurrent_executions = 1\n  tracing_config {\n    mode = \"Active\"\n  }\n  environment {\n    variables = {\n      APP_ACCESS_LOG_BUCKET                          = local.AppLogBucket\n      WAF_ACCESS_LOG_BUCKET                          = local.WafLogBucket\n      LIMIT_IP_ADDRESS_RANGES_PER_IP_MATCH_CONDITION = 10000\n      MAX_AGE_TO_UPDATE                              = 30\n      LOG_LEVEL                                      = var.LOG_LEVEL\n      SCOPE                                          = local.SCOPE\n      USER_AGENT_EXTRA                               = var.USER_AGENT_EXTRA\n      SEND_ANONYMOUS_USAGE_DATA                      = var.SEND_ANONYMOUS_USAGE_DATA\n      REGION                                         = data.aws_region.current.name\n      LOG_TYPE                                       = local.LOG_TYPE\n      SOLUTION_ID                                    = var.SolutionID\n      METRICS_URL                                    = var.MetricsURL\n      IP_SET_ID_HTTP_FLOODV4                         = local.WAFHttpFloodSetIPV4arn\n      IP_SET_ID_HTTP_FLOODV6                         = local.WAFHttpFloodSetIPV6arn\n      IP_SET_NAME_HTTP_FLOODV4                       = local.WAFHttpFloodSetIPV4Name\n      IP_SET_NAME_HTTP_FLOODV6                       = local.WAFHttpFloodSetIPV6Name\n      IP_SET_ID_SCANNERS_PROBESV4                    = aws_wafv2_ip_set.WAFScannersProbesSetV4[0].arn\n      IP_SET_ID_SCANNERS_PROBESV6                    = aws_wafv2_ip_set.WAFScannersProbesSetV6[0].arn\n      IP_SET_NAME_SCANNERS_PROBESV4                  = aws_wafv2_ip_set.WAFScannersProbesSetV4[0].name\n      IP_SET_NAME_SCANNERS_PROBESV6                  = aws_wafv2_ip_set.WAFScannersProbesSetV6[0].name\n      WAF_BLOCK_PERIOD                               = var.WAFBlockPeriod\n      ERROR_THRESHOLD                                = var.ErrorThreshold\n      REQUEST_THRESHOLD                              = var.RequestThreshold\n      STACK_NAME                                     = \"custom-resources-stack-${random_id.server.hex}\"\n      METRIC_NAME_PREFIX                             = \"customresourcesstack\"\n    }\n  }\n}\n\nresource \"aws_lambda_function\" \"AddAthenaPartitions\" {\n  count = local.AthenaLogParser == \"yes\" ? 1 : 0\n  function_name                  = \"AthenaLogParser-Lambda-${random_id.server.hex}\"\n  description                    = \"This function adds a new hourly partition to athena table. It runs every hour, triggered by a CloudWatch event.\"\n  role                           = aws_iam_role.LambdaRoleAddAthenaPartitions[0].arn\n  handler                        = \"add_athena_partitions.lambda_handler\"\n  s3_bucket                      = \"${var.SourceBucket}-${data.aws_region.current.name}\"\n  s3_key                         = \"${var.KeyPrefix}/log_parser.zip\"\n  runtime                        = \"python3.8\"\n  timeout                        = 300\n  memory_size                    = 512\n  kms_key_arn                    = aws_kms_key.wafkey.arn\n  reserved_concurrent_executions = 1\n  tracing_config {\n    mode = \"Active\"\n  }\n  environment {\n    variables = {\n      LOG_LEVEL        = var.LOG_LEVEL\n      USER_AGENT_EXTRA = var.USER_AGENT_EXTRA\n    }\n  }\n}\n\nresource \"aws_lambda_function\" \"RemoveExpiredIP\" {\n  count = var.IPRetentionPeriod == \"yes\" ? 1 : 0\n  function_name                  = \"RemoveExpiredIP-Lambda-${random_id.server.hex}\"\n  description                    = \"This function adds a new hourly partition to athena table. It runs every hour, triggered by a CloudWatch event.\"\n  role                           = aws_iam_role.LambdaRoleRemoveExpiredIP[0].arn\n  handler                        = \"add_athena_partitions.lambda_handler\"\n  s3_bucket                      = \"${var.SourceBucket}-${data.aws_region.current.name}\"\n  s3_key                         = \"${var.KeyPrefix}/ip_retention_handler.zip\"\n  runtime                        = \"python3.8\"\n  timeout                        = 300\n  memory_size                    = 512\n  kms_key_arn                    = aws_kms_key.wafkey.arn\n  reserved_concurrent_executions = 1\n  tracing_config {\n    mode = \"Active\"\n  }\n  environment {\n    variables = {\n      LOG_LEVEL                 = var.LOG_LEVEL\n      USER_AGENT_EXTRA          = var.USER_AGENT_EXTRA\n      METRICS_URL               = var.MetricsURL\n      SOLUTION_ID               = var.SolutionID\n      SEND_ANONYMOUS_USAGE_DATA = var.SEND_ANONYMOUS_USAGE_DATA\n      SNS_EMAIL                 = local.SNSEmail\n      SNS_TOPIC_ARN             = aws_sns_topic.user_updates[0].arn\n    }\n  }\n}\n\nresource \"aws_lambda_function\" \"CustomTimer\" {\n  function_name = \"CustomTimer-Lambda-${random_id.server.hex}\"\n  description                    = \"This lambda function counts X seconds and can be used to slow down component creation in CloudFormation\"\n  role                           = aws_iam_role.LambdaRoleCustomTimer.arn\n  handler                        = \"timer.lambda_handler\"\n  s3_bucket                      = \"${var.SourceBucket}-${data.aws_region.current.name}\"\n  s3_key                         = \"${var.KeyPrefix}/timer.zip\"\n  runtime                        = \"python3.8\"\n  timeout                        = 300\n  memory_size                    = 128\n  kms_key_arn                    = aws_kms_key.wafkey.arn\n  reserved_concurrent_executions = 1\n  tracing_config {\n    mode = \"Active\"\n  }\n  environment {\n    variables = {\n      LOG_LEVEL = var.LOG_LEVEL\n      SECONDS   = \"2\"\n    }\n  }\n}\n\nlocals {\n  MoveS3LogsForPartitionarn     = length(aws_lambda_function.MoveS3LogsForPartition) != 0 ? \"${aws_lambda_function.MoveS3LogsForPartition[0].arn}\" : \"0\"\n  WAFHttpFloodSetIPV4           = length(aws_wafv2_ip_set.WAFHttpFloodSetV4) != 0 ? \"${aws_wafv2_ip_set.WAFHttpFloodSetV4.id}\" : \"0\"\n  WAFScannersProbesSetIPV4      = length(aws_wafv2_ip_set.WAFScannersProbesSetV4) != 0 ? \"${aws_wafv2_ip_set.WAFScannersProbesSetV4[0].id}\" : \"0\"\n  WAFReputationListsSetIPV4     = length(aws_wafv2_ip_set.WAFReputationListsSetV4) != 0 ? \"${aws_wafv2_ip_set.WAFReputationListsSetV4[0].id}\" : \"0\"\n  WAFBadBotSetIPV4              = length(aws_wafv2_ip_set.WAFBadBotSetV4) != 0 ? \"${aws_wafv2_ip_set.WAFBadBotSetV4[0].id}\" : \"0\"\n  WAFHttpFloodSetIPV6           = length(aws_wafv2_ip_set.WAFHttpFloodSetV6) != 0 ? \"${aws_wafv2_ip_set.WAFHttpFloodSetV6.id}\" : \"0\"\n  WAFScannersProbesSetIPV6      = length(aws_wafv2_ip_set.WAFScannersProbesSetV6) != 0 ? \"${aws_wafv2_ip_set.WAFScannersProbesSetV6[0].id}\" : \"0\"\n  WAFReputationListsSetIPV6     = length(aws_wafv2_ip_set.WAFReputationListsSetV6) != 0 ? \"${aws_wafv2_ip_set.WAFReputationListsSetV6[0].id}\" : \"0\"\n  WAFBadBotSetIPV6              = length(aws_wafv2_ip_set.WAFBadBotSetV6) != 0 ? \"${aws_wafv2_ip_set.WAFBadBotSetV6[0].id}\" : \"0\"\n  WAFHttpFloodSetIPV4Name       = length(aws_wafv2_ip_set.WAFHttpFloodSetV4) != 0 ? \"${aws_wafv2_ip_set.WAFHttpFloodSetV4.name}\" : \"0\"\n  WAFScannersProbesSetIPV4Name  = length(aws_wafv2_ip_set.WAFScannersProbesSetV4) != 0 ? \"${aws_wafv2_ip_set.WAFScannersProbesSetV4[0].name}\" : \"0\"\n  WAFReputationListsSetIPV4Name = length(aws_wafv2_ip_set.WAFReputationListsSetV4) != 0 ? \"${aws_wafv2_ip_set.WAFReputationListsSetV4[0].name}\" : \"0\"\n  WAFBadBotSetIPV4Name          = length(aws_wafv2_ip_set.WAFBadBotSetV4) != 0 ? \"${aws_wafv2_ip_set.WAFBadBotSetV4[0].name}\" : \"0\"\n  WAFHttpFloodSetIPV6Name       = length(aws_wafv2_ip_set.WAFHttpFloodSetV6) != 0 ? \"${aws_wafv2_ip_set.WAFHttpFloodSetV6.name}\" : \"0\"\n  WAFScannersProbesSetIPV6Name  = length(aws_wafv2_ip_set.WAFScannersProbesSetV6) != 0 ? \"${aws_wafv2_ip_set.WAFScannersProbesSetV6[0].name}\" : \"0\"\n  WAFReputationListsSetIPV6Name = length(aws_wafv2_ip_set.WAFReputationListsSetV6) != 0 ? \"${aws_wafv2_ip_set.WAFReputationListsSetV6[0].name}\" : \"0\"\n  WAFBadBotSetIPV6Name          = length(aws_wafv2_ip_set.WAFBadBotSetV6) != 0 ? \"${aws_wafv2_ip_set.WAFBadBotSetV6[0].name}\" : \"0\"\n  AddAthenaPartitionsLambdaarn  = length(aws_lambda_function.AddAthenaPartitions) != 0 ? \"${aws_lambda_function.AddAthenaPartitions[0].arn}\" : \"0\"\n  LogParserarn                  = length(aws_lambda_function.LogParser) != 0 ? \"${aws_lambda_function.LogParser[0].arn}\" : \"0\"\n  GlueAccessLogsDatabase        = length(aws_glue_catalog_database.mydatabase) != 0 ? \"${aws_glue_catalog_database.mydatabase[0].name}\" : \"0\"\n  GlueWafAccessLogsTable        = length(aws_glue_catalog_table.waf_access_logs_table) != 0 ? \"${aws_glue_catalog_table.waf_access_logs_table[0].name}\" : \"0\"\n  AthenaWorkGroup               = length(aws_athena_workgroup.WAFAddPartitionAthenaQueryWorkGroup) != 0 ? \"${aws_athena_workgroup.WAFAddPartitionAthenaQueryWorkGroup[0].name}\" : \"0\"\n  AppAccessLogsTable            = (local.CloudFrontScannersProbesAthenaLogParser == \"yes\" ? \"${aws_glue_catalog_table.cloudfrontGlueAppAccessLogsTable[0].name}\" : (local.ALBScannersProbesAthenaLogParser == \"yes\" ? \"${aws_glue_catalog_table.ALBGlueAppAccessLogsTable[0].name}\" : \"0\"))\n  WAFHttpFloodSetIPV4arn        = length(aws_wafv2_ip_set.WAFHttpFloodSetV4) != 0 ? \"${aws_wafv2_ip_set.WAFHttpFloodSetV4.arn}\" : \"0\"\n  WAFHttpFloodSetIPV6arn        = length(aws_wafv2_ip_set.WAFHttpFloodSetV6) != 0 ? \"${aws_wafv2_ip_set.WAFHttpFloodSetV6.arn}\" : \"0\"\n  DeliveryStreamArn             = length(aws_kinesis_firehose_delivery_stream.extended_s3_stream) != 0 ? \"${aws_kinesis_firehose_delivery_stream.extended_s3_stream[0].arn}\" : \"0\"\n  WafLogBucket                  = length(aws_s3_bucket.WafLogBucket) != 0 ? \"${aws_s3_bucket.WafLogBucket[0].bucket}\" : \"0\"\n}\n\n# ----------------------------------------------------------------------------------------------------------------------\n# Custom Resources\n# ----------------------------------------------------------------------------------------------------------------------\n\nresource \"aws_cloudformation_stack\" \"trigger_codebuild_stack\" {\n  name = \"custom-resources-stack-${random_id.server.hex}\"\n  parameters = {\n    AthenaLogParser                           = local.AthenaLogParser\n    Helperarn                                 = aws_lambda_function.helper.arn\n    HttpFloodProtectionRateBasedRuleActivated = local.HttpFloodProtectionRateBasedRuleActivated\n    HttpFloodProtectionLogParserActivated     = local.HttpFloodProtectionLogParserActivated\n    ProtectionActivatedScannersProbes         = var.ScannersProbesProtectionActivated\n    AppAccessLogBucket                        = local.AppLogBucket\n    Region                                    = data.aws_region.current.name\n    EndpointType                              = var.ENDPOINT\n    RequestThreshold                          = var.RequestThreshold\n    ReputationListsParserarn                  = aws_lambda_function.ReputationListsParser[0].arn\n    ReputationListsProtectionActivated        = var.ReputationListsProtectionActivated\n    CustomResourcearn                         = aws_lambda_function.CustomResource.arn\n    WAFWebACLArn                              = aws_wafv2_web_acl.wafacl.arn\n    DeliveryStreamArn                         = local.DeliveryStreamArn\n    LogParser                                 = local.LogParserarn\n    ScannersProbesAthenaLogParser             = local.ScannersProbesAthenaLogParser\n    ScannersProbesLambdaLogParser             = local.ScannersProbesLambdaLogParser\n    AccessLoggingBucket                       = aws_s3_bucket.accesslogbucket[0].bucket\n    MoveS3LogsForPartitionarn                 = local.MoveS3LogsForPartitionarn\n    ScannersProbesProtectionActivated         = var.ScannersProbesProtectionActivated\n    BadBotProtectionActivated                 = var.BadBotProtectionActivated\n    HttpFloodAthenaLogParser                  = local.HttpFloodAthenaLogParser\n    HttpFloodLambdaLogParser                  = local.HttpFloodLambdaLogParser\n    ScannersProbesLambdaLogParser             = local.ScannersProbesLambdaLogParser\n    WafLogBucket                              = local.WafLogBucket\n    WAFBlockPeriod                            = var.WAFBlockPeriod\n    ActivateSqlInjectionProtectionParam       = var.ActivateSqlInjectionProtectionParam\n    ActivateCrossSiteScriptingProtectionParam = var.ActivateCrossSiteScriptingProtectionParam\n    ActivateHttpFloodProtectionParam          = var.ActivateHttpFloodProtectionParam\n    ActivateScannersProbesProtectionParam     = var.ActivateScannersProbesProtectionParam\n    ActivateReputationListsProtectionParam    = var.ActivateReputationListsProtectionParam\n    ActivateBadBotProtectionParam             = var.ActivateBadBotProtectionParam\n    ActivateAWSManagedRulesParam              = var.ActivateAWSManagedRulesParam\n    KeepDataInOriginalS3Location              = var.KEEP_ORIGINAL_DATA\n    IPRetentionPeriodAllowedParam             = var.IPRetentionPeriodAllowedParam\n    IPRetentionPeriodDeniedParam              = var.IPRetentionPeriodDeniedParam\n    SendAnonymousUsageData                    = var.SendAnonymousUsageData\n    SNSEmailParam                             = var.SNSEmailParam\n    version                                   = \"v3.2.0\"\n    ErrorThreshold                            = var.ErrorThreshold\n    WAFWhitelistSetIPV4                       = aws_wafv2_ip_set.WAFWhitelistSetV4.id\n    WAFBlacklistSetIPV4                       = aws_wafv2_ip_set.WAFBlacklistSetV4.id\n    WAFHttpFloodSetIPV4                       = local.WAFHttpFloodSetIPV4\n    WAFScannersProbesSetIPV4                  = local.WAFScannersProbesSetIPV4\n    WAFReputationListsSetIPV4                 = local.WAFReputationListsSetIPV4\n    WAFBadBotSetIPV4                          = local.WAFBadBotSetIPV4\n    WAFWhitelistSetIPV6                       = aws_wafv2_ip_set.WAFWhitelistSetV6.id\n    WAFBlacklistSetIPV6                       = aws_wafv2_ip_set.WAFBlacklistSetV6.id\n    WAFHttpFloodSetIPV6                       = local.WAFHttpFloodSetIPV6\n    WAFScannersProbesSetIPV6                  = local.WAFScannersProbesSetIPV6\n    WAFReputationListsSetIPV6                 = local.WAFReputationListsSetIPV6\n    WAFBadBotSetIPV6                          = local.WAFBadBotSetIPV6\n    WAFWhitelistSetIPV4Name                   = aws_wafv2_ip_set.WAFWhitelistSetV4.name\n    WAFBlacklistSetIPV4Name                   = aws_wafv2_ip_set.WAFBlacklistSetV4.name\n    WAFHttpFloodSetIPV4Name                   = local.WAFHttpFloodSetIPV4Name\n    WAFScannersProbesSetIPV4Name              = local.WAFScannersProbesSetIPV4Name\n    WAFReputationListsSetIPV4Name             = local.WAFReputationListsSetIPV4Name\n    WAFBadBotSetIPV4Name                      = local.WAFBadBotSetIPV4Name\n    WAFWhitelistSetIPV6Name                   = aws_wafv2_ip_set.WAFWhitelistSetV6.name\n    WAFBlacklistSetIPV6Name                   = aws_wafv2_ip_set.WAFBlacklistSetV6.name\n    WAFHttpFloodSetIPV6Name                   = local.WAFHttpFloodSetIPV6Name\n    WAFScannersProbesSetIPV6Name              = local.WAFScannersProbesSetIPV6Name\n    WAFReputationListsSetIPV6Name             = local.WAFReputationListsSetIPV6Name\n    WAFBadBotSetIPV6Name                      = local.WAFBadBotSetIPV6Name\n    wafwebacl                                 = aws_wafv2_web_acl.wafacl.name\n    AddAthenaPartitionsLambdaarn              = local.AddAthenaPartitionsLambdaarn\n    ResourceType                              = \"CustomResource\"\n    GlueAccessLogsDatabase                    = local.GlueAccessLogsDatabase\n    GlueAppAccessLogsTable                    = local.AppAccessLogsTable\n    GlueWafAccessLogsTable                    = local.GlueWafAccessLogsTable\n    AthenaWorkGroup                           = local.AthenaWorkGroup\n  }\n\n  template_body = <<STACK\n{\n  \"AWSTemplateFormatVersion\": \"2010-09-09\",\n  \"Parameters\" : {\n    \"Helperarn\" : {\n      \"Type\" : \"String\",\n      \"Description\" : \"Lambda Function ARN\"\n    },\n    \"ErrorThreshold\" : {\n      \"Type\" : \"Number\",\n      \"Description\" : \"IP Set names\"\n    },\n    \"version\" : {\n      \"Type\" : \"String\",\n      \"Description\" : \"IP Set names\"\n    },\n    \"SNSEmailParam\" : {\n      \"Type\" : \"String\",\n      \"Description\" : \"IP Set names\"\n    },\n    \"AthenaWorkGroup\" : {\n      \"Type\" : \"String\",\n      \"Description\" : \"IP Set names\"\n    },\n    \"WAFWhitelistSetIPV4\" : {\n      \"Type\" : \"String\",\n      \"Description\" : \"IP Set names\"\n    },\n    \"WAFBlacklistSetIPV4\" : {\n      \"Type\" : \"String\",\n      \"Description\" : \"IP Set names\"\n    },\n    \"WAFHttpFloodSetIPV4\" : {\n      \"Type\" : \"String\",\n      \"Description\" : \"IP Set names\"\n    },\n    \"WAFScannersProbesSetIPV4\" : {\n      \"Type\" : \"String\",\n      \"Description\" : \"IP Set names\"\n    },\n    \"WAFReputationListsSetIPV4\" : {\n      \"Type\" : \"String\",\n      \"Description\" : \"IP Set names\"\n    },\n    \"WAFBadBotSetIPV4\" : {\n      \"Type\" : \"String\",\n      \"Description\" : \"IP Set names\"\n    },\n    \"WAFWhitelistSetIPV6\" : {\n      \"Type\" : \"String\",\n      \"Description\" : \"IP Set names\"\n    },\n    \"WAFBlacklistSetIPV6\" : {\n      \"Type\" : \"String\",\n      \"Description\" : \"IP Set names\"\n    },\n    \"WAFHttpFloodSetIPV6\" : {\n      \"Type\" : \"String\",\n      \"Description\" : \"IP Set names\"\n    },\n    \"WAFScannersProbesSetIPV6\" : {\n      \"Type\" : \"String\",\n      \"Description\" : \"IP Set names\"\n    },\n    \"WAFReputationListsSetIPV6\" : {\n      \"Type\" : \"String\",\n      \"Description\" : \"IP Set names\"\n    },\n    \"AddAthenaPartitionsLambdaarn\" : {\n      \"Type\" : \"String\",\n      \"Description\" : \"IP Set names\"\n    },\n    \"ResourceType\" : {\n      \"Type\" : \"String\",\n      \"Description\" : \"IP Set names\"\n    },\n    \"GlueAccessLogsDatabase\" : {\n      \"Type\" : \"String\",\n      \"Description\" : \"IP Set names\"\n    },\n    \"GlueAppAccessLogsTable\" : {\n      \"Type\" : \"String\",\n      \"Description\" : \"IP Set names\"\n    },\n    \"GlueWafAccessLogsTable\" : {\n      \"Type\" : \"String\",\n      \"Description\" : \"IP Set names\"\n    },\n    \"WAFBadBotSetIPV6\" : {\n      \"Type\" : \"String\",\n      \"Description\" : \"IP Set names\"\n    },\n    \"WAFWhitelistSetIPV4Name\" : {\n      \"Type\" : \"String\",\n      \"Description\" : \"IP Set names\"\n    },\n    \"WAFBlacklistSetIPV4Name\" : {\n      \"Type\" : \"String\",\n      \"Description\" : \"IP Set names\"\n    },\n    \"WAFHttpFloodSetIPV4Name\" : {\n      \"Type\" : \"String\",\n      \"Description\" : \"IP Set names\"\n    },\n    \"WAFScannersProbesSetIPV4Name\" : {\n      \"Type\" : \"String\",\n      \"Description\" : \"IP Set names\"\n    },\n    \"WAFReputationListsSetIPV4Name\" : {\n      \"Type\" : \"String\",\n      \"Description\" : \"IP Set names\"\n    },\n    \"WAFBadBotSetIPV4Name\" : {\n      \"Type\" : \"String\",\n      \"Description\" : \"IP Set names\"\n    },\n    \"WAFWhitelistSetIPV6Name\" : {\n      \"Type\" : \"String\",\n      \"Description\" : \"IP Set names\"\n    },\n    \"WAFBlacklistSetIPV6Name\" : {\n      \"Type\" : \"String\",\n      \"Description\" : \"IP Set names\"\n    },\n    \"WAFHttpFloodSetIPV6Name\" : {\n      \"Type\" : \"String\",\n      \"Description\" : \"IP Set names\"\n    },\n    \"WAFScannersProbesSetIPV6Name\" : {\n      \"Type\" : \"String\",\n      \"Description\" : \"IP Set names\"\n    },\n    \"WAFReputationListsSetIPV6Name\" : {\n      \"Type\" : \"String\",\n      \"Description\" : \"IP Set names\"\n    },\n    \"WAFScannersProbesSetIPV6Name\" : {\n      \"Type\" : \"String\",\n      \"Description\" : \"IP Set names\"\n    },\n    \"AthenaLogParser\" : {\n      \"Type\" : \"String\",\n      \"Description\" : \"Code Build Project Name\"\n    },\n    \"WAFBlockPeriod\" : {\n      \"Type\" : \"Number\",\n      \"Description\" : \"Code Build Project Name\"\n    },\n    \"HttpFloodProtectionRateBasedRuleActivated\" : {\n      \"Type\" : \"String\",\n      \"Description\" : \"Lambda Function ARN\"\n    },\n    \"HttpFloodAthenaLogParser\" : {\n      \"Type\" : \"String\",\n      \"Description\" : \"Lambda Function ARN\"\n    },\n    \"WafLogBucket\" : {\n      \"Type\" : \"String\",\n      \"Description\" : \"Lambda Function ARN\"\n    },\n    \"HttpFloodLambdaLogParser\" : {\n      \"Type\" : \"String\",\n      \"Description\" : \"Lambda Function ARN\"\n    },\n    \"ScannersProbesLambdaLogParser\" : {\n      \"Type\" : \"String\",\n      \"Description\" : \"Lambda Function ARN\"\n    },\n    \"HttpFloodProtectionLogParserActivated\" : {\n      \"Type\" : \"String\",\n      \"Description\" : \"Lambda Function ARN\"\n    },\n    \"ScannersProbesProtectionActivated\" : {\n      \"Type\" : \"String\",\n      \"Description\" : \"Lambda Function ARN\"\n    },\n    \"BadBotProtectionActivated\" : {\n      \"Type\" : \"String\",\n      \"Description\" : \"Lambda Function ARN\"\n    },\n    \"ProtectionActivatedScannersProbes\" : {\n      \"Type\" : \"String\",\n      \"Description\" : \"Lambda Function ARN\"\n    },\n    \"AppAccessLogBucket\" : {\n      \"Type\" : \"String\",\n      \"Description\" : \"Lambda Function ARN\"\n    },\n    \"Region\" : {\n      \"Type\" : \"String\",\n      \"Description\" : \"Lambda Function ARN\"\n    },\n    \"EndpointType\" : {\n      \"Type\" : \"String\",\n      \"Description\" : \"Lambda Function ARN\"\n    },\n    \"RequestThreshold\" : {\n      \"Type\" : \"Number\",\n      \"Description\" : \"Lambda Function ARN\"\n    },\n    \"ReputationListsParserarn\" : {\n      \"Type\" : \"String\",\n      \"Description\" : \"Lambda Function ARN\"\n    },\n    \"ReputationListsProtectionActivated\" : {\n      \"Type\" : \"String\",\n      \"Description\" : \"Lambda Function ARN\"\n    },\n    \"ScannersProbesLambdaLogParser\" : {\n      \"Type\" : \"String\",\n      \"Description\" : \"Lambda Function ARN\"\n    },\n    \"LogParser\" : {\n      \"Type\" : \"String\",\n      \"Description\" : \"Lambda Function ARN\"\n    },\n    \"IPRetentionPeriodAllowedParam\" : {\n      \"Type\" : \"String\",\n      \"Description\" : \"IP Set names\"\n    },\n    \"IPRetentionPeriodDeniedParam\" : {\n      \"Type\" : \"String\",\n      \"Description\" : \"IP Set names\"\n    },\n    \"KeepDataInOriginalS3Location\" : {\n      \"Type\" : \"String\",\n      \"Description\" : \"IP Set names\"\n    },\n    \"ActivateHttpFloodProtectionParam\" : {\n      \"Type\" : \"String\",\n      \"Description\" : \"IP Set names\"\n    },\n    \"ActivateAWSManagedRulesParam\" : {\n      \"Type\" : \"String\",\n      \"Description\" : \"IP Set names\"\n    },\n    \"wafwebacl\" : {\n      \"Type\" : \"String\",\n      \"Description\" : \"IP Set names\"\n    },\n    \"ActivateSqlInjectionProtectionParam\" : {\n      \"Type\" : \"String\",\n      \"Description\" : \"IP Set names\"\n    },\n    \"WAFBadBotSetIPV6Name\" : {\n      \"Type\" : \"String\",\n      \"Description\" : \"IP Set names\"\n    },\n    \"SendAnonymousUsageData\" : {\n      \"Type\" : \"String\",\n      \"Description\" : \"IP Set names\"\n    },\n    \"ActivateReputationListsProtectionParam\" : {\n      \"Type\" : \"String\",\n      \"Description\" : \"IP Set names\"\n    },\n    \"ActivateBadBotProtectionParam\" : {\n      \"Type\" : \"String\",\n      \"Description\" : \"IP Set names\"\n    },\n    \"ActivateCrossSiteScriptingProtectionParam\" : {\n      \"Type\" : \"String\",\n      \"Description\" : \"IP Set names\"\n    },\n    \"ActivateScannersProbesProtectionParam\" : {\n      \"Type\" : \"String\",\n      \"Description\" : \"IP Set names\"\n    },\n    \"AccessLoggingBucket\" : {\n      \"Type\" : \"String\",\n      \"Description\" : \"Lambda Function ARN\"\n    },\n    \"ScannersProbesAthenaLogParser\" : {\n      \"Type\" : \"String\",\n      \"Description\" : \"Lambda Function ARN\"\n    },\n    \"MoveS3LogsForPartitionarn\" : {\n      \"Type\" : \"String\",\n      \"Description\" : \"Lambda Function ARN\"\n    },\n    \"WAFWebACLArn\" : {\n      \"Type\" : \"String\",\n      \"Description\" : \"Lambda Function ARN\"\n    },\n    \"DeliveryStreamArn\" : {\n      \"Type\" : \"String\",\n      \"Description\" : \"Lambda Function ARN\"\n    },\n    \"CustomResourcearn\" : {\n      \"Type\" : \"String\",\n      \"Description\" : \"Lambda Function ARN\"\n    }\n  },\n  \"Conditions\": {\n        \"HttpFloodProtectionLogParserActivated\": {\n            \"Fn::Equals\": [\n                {\n                    \"Ref\": \"HttpFloodProtectionLogParserActivated\"\n                },\n                \"yes\"\n            ]\n        },\n          \"HttpFloodLambdaLogParser\": {\n            \"Fn::Equals\": [\n                {\n                    \"Ref\": \"HttpFloodLambdaLogParser\"\n                },\n                \"yes\"\n            ]\n        },\n          \"ReputationListsProtectionActivated\": {\n            \"Fn::Equals\": [\n                {\n                    \"Ref\": \"ReputationListsProtectionActivated\"\n                },\n                \"yes\"\n            ]\n        },\n          \"ScannersProbesAthenaLogParser\": {\n            \"Fn::Equals\": [\n                {\n                    \"Ref\": \"ScannersProbesAthenaLogParser\"\n                },\n                \"yes\"\n            ]\n        },\n          \"ScannersProbesLambdaLogParser\": {\n            \"Fn::Equals\": [\n                {\n                    \"Ref\": \"ScannersProbesLambdaLogParser\"\n                },\n                \"yes\"\n            ]\n        },\n          \"ScannersProbesProtectionActivated\": {\n            \"Fn::Equals\": [\n                {\n                    \"Ref\": \"ScannersProbesProtectionActivated\"\n                },\n                \"yes\"\n            ]\n        },\n          \"BadBotProtectionActivated\": {\n            \"Fn::Equals\": [\n                {\n                    \"Ref\": \"BadBotProtectionActivated\"\n                },\n                \"yes\"\n            ]\n        },\n          \"AthenaLogParser\": {\n            \"Fn::Equals\": [\n                {\n                    \"Ref\": \"AthenaLogParser\"\n                },\n                \"yes\"\n            ]\n        }\n    },\n  \"Resources\" : {\n    \"CheckRequirements\": {\n      \"Type\" : \"Custom::CheckRequirements\",\n      \"Properties\" : {\n        \"AthenaLogParser\" : { \"Ref\" : \"AthenaLogParser\" },\n        \"ServiceToken\" : { \"Ref\" : \"Helperarn\" },\n        \"HttpFloodProtectionRateBasedRuleActivated\" : { \"Ref\" : \"HttpFloodProtectionRateBasedRuleActivated\" },\n        \"HttpFloodProtectionLogParserActivated\" : { \"Ref\" : \"HttpFloodProtectionLogParserActivated\" },\n        \"ProtectionActivatedScannersProbes\" : { \"Ref\" : \"ProtectionActivatedScannersProbes\" },\n        \"AppAccessLogBucket\" : { \"Ref\" : \"AppAccessLogBucket\" },\n        \"Region\" : { \"Ref\" : \"Region\" },\n        \"EndpointType\" : { \"Ref\" : \"EndpointType\" },\n        \"RequestThreshold\" : { \"Ref\" : \"RequestThreshold\" }\n      }\n    },\n      \"CreateUniqueID\": {\n        \"Type\" : \"Custom::CreateUUID\",\n        \"DependsOn\" : \"CheckRequirements\",\n        \"Properties\" : {\n          \"ServiceToken\" : { \"Ref\" : \"Helperarn\" }\n      }\n    },\n      \"CreateDeliveryStreamName\": {\n        \"Type\" : \"Custom::CreateDeliveryStreamName\",\n        \"Condition\" : \"HttpFloodProtectionLogParserActivated\",\n        \"DependsOn\" : \"CheckRequirements\",\n        \"Properties\" : {\n          \"ServiceToken\" : { \"Ref\" : \"Helperarn\" },\n          \"StackName\" : { \"Ref\" : \"AWS::StackName\" }\n      }\n    },\n      \"CreateGlueDatabaseName\": {\n        \"Type\" : \"Custom::CreateGlueDatabaseName\",\n        \"Condition\" : \"AthenaLogParser\",\n        \"DependsOn\" : \"CheckRequirements\",\n        \"Properties\" : {\n          \"ServiceToken\" : { \"Ref\" : \"Helperarn\" },\n          \"StackName\" : { \"Ref\" : \"AWS::StackName\" }\n      }\n    },\n      \"UpdateReputationListsOnLoad\": {\n        \"Type\" : \"Custom::UpdateReputationLists\",\n        \"Condition\" : \"ReputationListsProtectionActivated\",\n        \"Properties\" : {\n          \"ServiceToken\" : { \"Ref\" : \"ReputationListsParserarn\" }\n      }\n    },\n      \"ConfigureAWSWAFLogs\": {\n        \"Type\" : \"Custom::ConfigureAWSWAFLogs\",\n        \"Condition\" : \"HttpFloodProtectionLogParserActivated\",\n        \"Properties\" : {\n          \"ServiceToken\" : { \"Ref\" : \"CustomResourcearn\" },\n          \"WAFWebACLArn\" : { \"Ref\" : \"WAFWebACLArn\" },\n          \"DeliveryStreamArn\" : { \"Ref\" : \"DeliveryStreamArn\" }\n      }\n    },\n      \"ConfigureAppAccessLogBucket\": {\n        \"Type\" : \"Custom::ConfigureAppAccessLogBucket\",\n        \"Condition\" : \"ScannersProbesProtectionActivated\",\n        \"Properties\" : {\n          \"ServiceToken\" : { \"Ref\" : \"CustomResourcearn\" },\n          \"Region\" : { \"Ref\" : \"Region\" },\n          \"AppAccessLogBucket\" : { \"Ref\" : \"AppAccessLogBucket\" },\n          \"LogParser\" : { \"Ref\" : \"LogParser\" },\n          \"ScannersProbesLambdaLogParser\" : { \"Ref\" : \"ScannersProbesLambdaLogParser\" },\n          \"ScannersProbesAthenaLogParser\" : { \"Ref\" : \"ScannersProbesAthenaLogParser\" },\n          \"MoveS3LogsForPartition\" : { \"Fn::If\" : [\n                                            \"ScannersProbesAthenaLogParser\",\n                                            {\"Ref\" : \"MoveS3LogsForPartitionarn\"},\n                                            {\"Ref\" : \"AWS::NoValue\"}\n                                          ] },\n          \"AccessLoggingBucket\" : { \"Fn::If\" : [\n                                            \"ScannersProbesProtectionActivated\",\n                                            {\"Ref\" : \"AccessLoggingBucket\"},\n                                            {\"Ref\" : \"AWS::NoValue\"}\n                                          ] }\n      }\n    },\n      \"ConfigureWafLogBucket\": {\n        \"Type\" : \"Custom::ConfigureWafLogBucket\",\n        \"Condition\" : \"HttpFloodProtectionLogParserActivated\",\n        \"Properties\" : {\n          \"ServiceToken\" : { \"Ref\" : \"CustomResourcearn\" },\n          \"WafLogBucket\" : { \"Ref\" : \"WafLogBucket\" },\n          \"LogParser\" : { \"Ref\" : \"LogParser\" },\n          \"HttpFloodLambdaLogParser\" : { \"Ref\" : \"HttpFloodLambdaLogParser\" },\n          \"HttpFloodAthenaLogParser\" : { \"Ref\" : \"HttpFloodAthenaLogParser\" }\n      }\n    },\n      \"GenerateAppLogParserConfFile\": {\n        \"Type\" : \"Custom::GenerateAppLogParserConfFile\",\n        \"DependsOn\" : \"ConfigureAppAccessLogBucket\",\n        \"Condition\" : \"ScannersProbesLambdaLogParser\",\n        \"Properties\" : {\n          \"ServiceToken\" : { \"Ref\" : \"CustomResourcearn\" },\n          \"AppAccessLogBucket\" : { \"Ref\" : \"AppAccessLogBucket\" },\n          \"StackName\" : { \"Ref\" : \"AWS::StackName\" },\n          \"ErrorThreshold\" : { \"Ref\" : \"ErrorThreshold\" },\n          \"WAFBlockPeriod\" : { \"Ref\" : \"WAFBlockPeriod\" }\n      }\n    },\n      \"GenerateWafLogParserConfFile\": {\n        \"Type\" : \"Custom::GenerateWafLogParserConfFil\",\n        \"Condition\" : \"HttpFloodLambdaLogParser\",\n        \"Properties\" : {\n          \"ServiceToken\" : { \"Ref\" : \"CustomResourcearn\" },\n          \"WafAccessLogBucket\" : { \"Ref\" : \"WafLogBucket\" },\n          \"StackName\" : { \"Ref\" : \"AWS::StackName\" },\n          \"RequestThreshold\" : { \"Ref\" : \"RequestThreshold\" },\n          \"WAFBlockPeriod\" : { \"Ref\" : \"WAFBlockPeriod\" }\n      }\n    },\n      \"ConfigureWebAcl\": {\n        \"Type\" : \"Custom::ConfigureWebAcl\",\n        \"Condition\" : \"HttpFloodLambdaLogParser\",\n        \"Properties\" : {\n          \"ServiceToken\" : { \"Ref\" : \"CustomResourcearn\" },\n          \"ActivateSqlInjectionProtectionParam\" : { \"Ref\" : \"ActivateSqlInjectionProtectionParam\" },\n          \"ActivateCrossSiteScriptingProtectionParam\" : { \"Ref\" : \"ActivateCrossSiteScriptingProtectionParam\" },\n          \"ActivateHttpFloodProtectionParam\" : { \"Ref\" : \"ActivateHttpFloodProtectionParam\" },\n          \"ActivateScannersProbesProtectionParam\" : { \"Ref\" : \"ActivateScannersProbesProtectionParam\" },\n          \"ActivateReputationListsProtectionParam\" : { \"Ref\" : \"ActivateReputationListsProtectionParam\" },\n          \"ActivateBadBotProtectionParam\" : { \"Ref\" : \"ActivateBadBotProtectionParam\" },\n          \"ActivateAWSManagedRulesParam\" : { \"Ref\" : \"ActivateAWSManagedRulesParam\" },\n          \"KeepDataInOriginalS3Location\" : { \"Ref\" : \"KeepDataInOriginalS3Location\" },\n          \"IPRetentionPeriodAllowedParam\" : { \"Ref\" : \"IPRetentionPeriodAllowedParam\" },\n          \"IPRetentionPeriodDeniedParam\" : { \"Ref\" : \"IPRetentionPeriodDeniedParam\" },\n          \"SNSEmailParam\" : { \"Ref\" : \"SNSEmailParam\" },\n          \"WAFWebACL\" : { \"Ref\" : \"wafwebacl\" },\n          \"WAFWhitelistSetIPV4\" : { \"Ref\" : \"WAFWhitelistSetIPV4\" },\n          \"WAFBlacklistSetIPV4\" : { \"Ref\" : \"WAFBlacklistSetIPV4\" },\n          \"WAFHttpFloodSetIPV4\" : { \"Fn::If\" : [\n                                            \"HttpFloodProtectionLogParserActivated\",\n                                            {\"Ref\" : \"WAFHttpFloodSetIPV4\"},\n                                            {\"Ref\" : \"AWS::NoValue\"}\n                                          ] },\n          \"WAFScannersProbesSetIPV4\" : { \"Fn::If\" : [\n                                            \"ScannersProbesProtectionActivated\",\n                                            {\"Ref\" : \"WAFScannersProbesSetIPV4\"},\n                                            {\"Ref\" : \"AWS::NoValue\"}\n                                          ] },\n          \"WAFReputationListsSetIPV4\" : { \"Fn::If\" : [\n                                            \"ReputationListsProtectionActivated\",\n                                            {\"Ref\" : \"WAFReputationListsSetIPV4\"},\n                                            {\"Ref\" : \"AWS::NoValue\"}\n                                          ] },\n          \"WAFBadBotSetIPV4\" : { \"Fn::If\" : [\n                                            \"BadBotProtectionActivated\",\n                                            {\"Ref\" : \"WAFBadBotSetIPV4\"},\n                                            {\"Ref\" : \"AWS::NoValue\"}\n                                          ] },\n          \"WAFWhitelistSetIPV6\" : { \"Ref\" : \"WAFWhitelistSetIPV6\" },\n          \"WAFBlacklistSetIPV6\" : { \"Ref\" : \"WAFBlacklistSetIPV6\" },\n          \"WAFHttpFloodSetIPV6\" : { \"Fn::If\" : [\n                                            \"HttpFloodProtectionLogParserActivated\",\n                                            {\"Ref\" : \"WAFHttpFloodSetIPV6\"},\n                                            {\"Ref\" : \"AWS::NoValue\"}\n                                          ] },\n          \"WAFScannersProbesSetIPV6\" : { \"Fn::If\" : [\n                                            \"ScannersProbesProtectionActivated\",\n                                            {\"Ref\" : \"WAFHttpFloodSetIPV6\"},\n                                            {\"Ref\" : \"AWS::NoValue\"}\n                                          ] },\n          \"WAFReputationListsSetIPV6\" : { \"Fn::If\" : [\n                                            \"ReputationListsProtectionActivated\",\n                                            {\"Ref\" : \"WAFHttpFloodSetIPV6\"},\n                                            {\"Ref\" : \"AWS::NoValue\"}\n                                          ] },\n          \"WAFBadBotSetIPV6\" : { \"Fn::If\" : [\n                                            \"BadBotProtectionActivated\",\n                                            {\"Ref\" : \"WAFHttpFloodSetIPV6\"},\n                                            {\"Ref\" : \"AWS::NoValue\"}\n                                          ] },\n          \"WAFWhitelistSetIPV4Name\" : { \"Ref\" : \"WAFWhitelistSetIPV4Name\" },\n          \"WAFBlacklistSetIPV4Name\" : { \"Ref\" : \"WAFBlacklistSetIPV4Name\" },\n          \"WAFHttpFloodSetIPV4Name\" : { \"Fn::If\" : [\n                                            \"HttpFloodProtectionLogParserActivated\",\n                                            {\"Ref\" : \"WAFHttpFloodSetIPV6Name\"},\n                                            {\"Ref\" : \"AWS::NoValue\"}\n                                          ] },\n          \"WAFScannersProbesSetIPV4Name\" : { \"Fn::If\" : [\n                                            \"ScannersProbesProtectionActivated\",\n                                            {\"Ref\" : \"WAFHttpFloodSetIPV6Name\"},\n                                            {\"Ref\" : \"AWS::NoValue\"}\n                                          ] },\n          \"WAFReputationListsSetIPV4Name\" : { \"Fn::If\" : [\n                                            \"ReputationListsProtectionActivated\",\n                                            {\"Ref\" : \"WAFHttpFloodSetIPV6Name\"},\n                                            {\"Ref\" : \"AWS::NoValue\"}\n                                          ] },\n          \"WAFBadBotSetIPV4Name\" : { \"Fn::If\" : [\n                                            \"BadBotProtectionActivated\",\n                                            {\"Ref\" : \"WAFHttpFloodSetIPV6Name\"},\n                                            {\"Ref\" : \"AWS::NoValue\"}\n                                          ] },\n          \"WAFWhitelistSetIPV6Name\" : { \"Ref\" : \"WAFWhitelistSetIPV6Name\" },\n          \"WAFBlacklistSetIPV6Name\" : { \"Ref\" : \"WAFBlacklistSetIPV6Name\" },\n          \"WAFHttpFloodSetIPV6Name\" : { \"Fn::If\" : [\n                                            \"HttpFloodProtectionLogParserActivated\",\n                                            {\"Ref\" : \"WAFHttpFloodSetIPV6Name\"},\n                                            {\"Ref\" : \"AWS::NoValue\"}\n                                          ] },\n          \"WAFScannersProbesSetIPV6Name\" : { \"Fn::If\" : [\n                                            \"ScannersProbesProtectionActivated\",\n                                            {\"Ref\" : \"WAFHttpFloodSetIPV6Name\"},\n                                            {\"Ref\" : \"AWS::NoValue\"}\n                                          ] },\n          \"WAFReputationListsSetIPV6Name\" : { \"Fn::If\" : [\n                                            \"ReputationListsProtectionActivated\",\n                                            {\"Ref\" : \"WAFHttpFloodSetIPV6Name\"},\n                                            {\"Ref\" : \"AWS::NoValue\"}\n                                          ] },\n          \"WAFBadBotSetIPV6Name\" : { \"Fn::If\" : [\n                                            \"BadBotProtectionActivated\",\n                                            {\"Ref\" : \"WAFHttpFloodSetIPV6Name\"},\n                                            {\"Ref\" : \"AWS::NoValue\"}\n                                          ] },\n          \"UUID\" : { \"Fn::GetAtt\" : [ \"CreateUniqueID\", \"UUID\" ] },\n          \"Region\" : { \"Ref\" : \"Region\" },\n          \"RequestThreshold\" : { \"Ref\" : \"RequestThreshold\" },\n          \"ErrorThreshold\" : { \"Ref\" : \"ErrorThreshold\" },\n          \"WAFBlockPeriod\" : { \"Ref\" : \"WAFBlockPeriod\" },\n          \"Version\" : { \"Ref\" : \"version\" },\n          \"SendAnonymousUsageData\" : { \"Ref\" : \"SendAnonymousUsageData\" }\n      }\n    },\n      \"CustomAddAthenaPartitions\": {\n        \"Type\" : \"Custom::AddAthenaPartition\",\n        \"Condition\" : \"AthenaLogParser\",\n        \"Properties\" : {\n          \"ServiceToken\" : { \"Ref\" : \"CustomResourcearn\" },\n          \"AddAthenaPartitionsLambda\" : { \"Ref\" : \"AddAthenaPartitionsLambdaarn\" },\n          \"ResourceType\" : { \"Ref\" : \"ResourceType\" },\n          \"GlueAccessLogsDatabase\" : { \"Ref\" : \"GlueAccessLogsDatabase\" },\n          \"AppAccessLogBucket\" : { \"Ref\" : \"AppAccessLogBucket\" },\n          \"GlueAppAccessLogsTable\" : { \"Ref\" : \"GlueAppAccessLogsTable\" },\n          \"GlueWafAccessLogsTable\" : { \"Ref\" : \"GlueWafAccessLogsTable\" },\n          \"WafLogBucket\" : { \"Ref\" : \"WafLogBucket\" },\n          \"AthenaWorkGroup\" : { \"Ref\" : \"AthenaWorkGroup\" }\n      }\n    }\n  },\n  \"Outputs\" : {\n  \n      \"UUID\" : {\n  \n        \"Description\" : \"UUID of the newly created  instance\",\n  \n        \"Value\" : { \"Fn::GetAtt\" : [ \"CreateUniqueID\", \"UUID\" ] }\n  \n    }\n  }\n}\nSTACK\n  depends_on = [\n    aws_iam_role_policy.CloudWatchAccessListsParser,\n    aws_iam_role_policy.WAFGetAndUpdateIPListsParser,\n    aws_iam_role_policy.CloudWatchLogsListsParser,\n    aws_lambda_function.helper,\n    aws_lambda_function.MoveS3LogsForPartition,\n    aws_lambda_function.SetIPRetention,\n    aws_lambda_function.ReputationListsParser,\n    aws_lambda_function.CustomResource,\n    aws_lambda_function.LogParser,\n    aws_lambda_function.AddAthenaPartitions,\n    aws_lambda_function.CustomTimer\n  ]\n}\n\n# ----------------------------------------------------------------------------------------------------------------------\n# Firehose Athena \n# ----------------------------------------------------------------------------------------------------------------------\n\nresource \"aws_iam_role\" \"FirehoseWAFLogsDeliveryStreamRole\" {\n  count = local.HttpFloodProtectionLogParserActivated == \"yes\" ? 1 : 0\n  name  = \"FirehoseWAFLogsDeliveryStreamRole1-${random_id.server.hex}\"\n\n  assume_role_policy = <<EOF\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Action\": \"sts:AssumeRole\",\n      \"Principal\": {\n        \"Service\": \"firehose.amazonaws.com\"\n      },\n      \"Effect\": \"Allow\",\n      \"Sid\": \"\"\n    }\n  ]\n}\nEOF\n}\n\nresource \"aws_iam_role_policy\" \"S3AccessFirehoseWAFLogs\" {\n  count  = local.HttpFloodProtectionLogParserActivated == \"yes\" ? 1 : 0\n  name   = \"S3Access1\"\n  role   = aws_iam_role.FirehoseWAFLogsDeliveryStreamRole[0].id\n  policy = <<EOT\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Action\": [\n                \"s3:GetBucketLocation\",\n                \"s3:GetObject\",\n                \"s3:ListBucket\",\n                \"s3:AbortMultipartUpload\",\n                \"s3:ListBucketMultipartUploads\",\n                \"s3:PutObject\"\n            ],\n            \"Resource\": [\n                \"arn:${data.aws_partition.current.partition}:s3:::${aws_s3_bucket.WafLogBucket[0].bucket}\",\n                \"arn:${data.aws_partition.current.partition}:s3:::${aws_s3_bucket.WafLogBucket[0].bucket}/*\"\n            ],\n            \"Effect\": \"Allow\"\n        }\n    ]\n}\nEOT\n  depends_on = [\n    aws_iam_role.FirehoseWAFLogsDeliveryStreamRole[0]\n  ]\n}\n\nresource \"aws_iam_role_policy\" \"KinesisAccess\" {\n  count  = local.HttpFloodProtectionLogParserActivated == \"yes\" ? 1 : 0\n  name   = \"KinesisAccess1\"\n  role   = aws_iam_role.FirehoseWAFLogsDeliveryStreamRole[0].id\n  policy = <<EOT\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Action\": [\n                \"kinesis:DescribeStream\",\n                \"kinesis:GetShardIterator\",\n                \"kinesis:GetRecords\"\n            ],\n            \"Resource\": [\n                  \"arn:${data.aws_partition.current.partition}:kinesis:${data.aws_region.current.name}:${data.aws_caller_identity.current.account_id}:stream/${var.DeliveryStreamName}\"\n            ],\n            \"Effect\": \"Allow\"\n        }\n    ]\n}\nEOT\n  depends_on = [\n    aws_iam_role.FirehoseWAFLogsDeliveryStreamRole[0]\n  ]\n}\n\nresource \"aws_iam_role_policy\" \"CloudWatchAccess\" {\n  count  = local.HttpFloodProtectionLogParserActivated == \"yes\" ? 1 : 0\n  name   = \"CloudWatchAccess1\"\n  role   = aws_iam_role.FirehoseWAFLogsDeliveryStreamRole[0].id\n  policy = <<EOT\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Action\": [\n                \"logs:PutLogEvents\"\n            ],\n            \"Resource\": [\n                  \"arn:${data.aws_partition.current.partition}:kinesis:${data.aws_region.current.name}:${data.aws_caller_identity.current.account_id}:log-group:/aws/kinesisfirehose/${var.DeliveryStreamName}:*\"\n            ],\n            \"Effect\": \"Allow\"\n        }\n    ]\n}\nEOT\n  depends_on = [\n    aws_iam_role.FirehoseWAFLogsDeliveryStreamRole[0]\n  ]\n}\n\n\nresource \"aws_kinesis_firehose_delivery_stream\" \"extended_s3_stream\" {\n  count       = local.HttpFloodProtectionLogParserActivated == \"yes\" ? 1 : 0\n  name        = var.DeliveryStreamName\n  destination = \"extended_s3\"\n  server_side_encryption {\n    key_type = \"CUSTOMER_MANAGED_CMK\"\n    enabled  = \"true\"\n    key_arn  = aws_kms_key.wafkey.arn\n  }\n  extended_s3_configuration {\n    bucket_arn          = aws_s3_bucket.WafLogBucket[0].arn\n    compression_format  = \"GZIP\"\n    error_output_prefix = \"AWSErrorLogs/result=!{firehose:error-output-type}/year=!{timestamp:yyyy}/month=!{timestamp:MM}/day=!{timestamp:dd}/hour=!{timestamp:HH}/\"\n    role_arn            = aws_iam_role.FirehoseWAFLogsDeliveryStreamRole[0].arn\n    buffer_size         = 5\n    buffer_interval     = 300\n  }\n}\n\n\n# ----------------------------------------------------------------------------------------------------------------------\n# Glue Database and tables\n# ----------------------------------------------------------------------------------------------------------------------\n\nresource \"aws_glue_catalog_database\" \"mydatabase\" {\n  count      = local.AthenaLogParser == \"yes\" ? 1 : 0\n  name       = \"mygluedatabase-${random_id.server.hex}\"\n  catalog_id = data.aws_caller_identity.current.account_id\n}\n\nresource \"aws_glue_catalog_table\" \"waf_access_logs_table\" {\n  count         = local.HttpFloodAthenaLogParser == \"yes\" ? 1 : 0\n  name          = \"waf_access_logs-${random_id.server.hex}\"\n  database_name = aws_glue_catalog_database.mydatabase[0].name\n  catalog_id    = data.aws_caller_identity.current.account_id\n  parameters = {\n    EXTERNAL = \"TRUE\"\n  }\n  partition_keys {\n    name = \"year\"\n    type = \"int\"\n  }\n  partition_keys {\n    name = \"month\"\n    type = \"init\"\n  }\n  partition_keys {\n    name = \"day\"\n    type = \"int\"\n  }\n  partition_keys {\n    name = \"hour\"\n    type = \"int\"\n  }\n  storage_descriptor {\n    location      = \"s3://${aws_s3_bucket.WafLogBucket[0].bucket}/AWSLogs/\"\n    input_format  = \"org.apache.hadoop.mapred.TextInputFormat\"\n    output_format = \"org.apache.hadoop.hive.ql.io.IgnoreKeyTextOutputFormat\"\n\n    ser_de_info {\n      serialization_library = \"org.openx.data.jsonserde.JsonSerDe\"\n\n      parameters = {\n        \"paths\" = \"action,formatVersion,httpRequest,httpSourceId,httpSourceName,nonTerminatingMatchingRules,rateBasedRuleList,ruleGroupList,terminatingRuleId,terminatingRuleType,timestamp,webaclId\"\n      }\n    }\n    compressed                = \"true\"\n    stored_as_sub_directories = \"false\"\n    dynamic \"columns\" {\n      for_each = var.waf_access_logs_columns\n\n      content {\n        name = columns.key\n        type = columns.value\n      }\n    }\n  }\n}\n\n\nresource \"aws_glue_catalog_table\" \"ALBGlueAppAccessLogsTable\" {\n  count         = local.AthenaLogParser == \"yes\" && local.ALBScannersProbesAthenaLogParser == \"yes\" ? 1 : 0\n  name          = \"app_access_logs-${random_id.server.hex}\"\n  database_name = aws_glue_catalog_database.mydatabase[0].name\n  catalog_id    = data.aws_caller_identity.current.account_id\n  parameters = {\n    EXTERNAL = \"TRUE\"\n  }\n  partition_keys {\n    name = \"year\"\n    type = \"int\"\n  }\n  partition_keys {\n    name = \"month\"\n    type = \"init\"\n  }\n  partition_keys {\n    name = \"day\"\n    type = \"int\"\n  }\n  partition_keys {\n    name = \"hour\"\n    type = \"int\"\n  }\n  storage_descriptor {\n    location      = \"s3://${local.AppLogBucket}/AWSLogs-Partitioned/\"\n    input_format  = \"org.apache.hadoop.mapred.TextInputFormat\"\n    output_format = \"org.apache.hadoop.hive.ql.io.IgnoreKeyTextOutputFormat\"\n\n    ser_de_info {\n      serialization_library = \"org.apache.hadoop.hive.serde2.RegexSerDe\"\n\n      parameters = {\n        \"serialization.format\" = \"1\",\n        \"input.regex\"          = \"([^ ]*) ([^ ]*) ([^ ]*) ([^ ]*):([0-9]*) ([^ ]*)[:-]([0-9]*) ([-.0-9]*) ([-.0-9]*) ([-.0-9]*) (|[-0-9]*) (-|[-0-9]*) ([-0-9]*) ([-0-9]*) \\\"([^ ]*) ([^ ]*) (- |[^ ]*)\\\" \\\"([^\\\"]*)\\\" ([A-Z0-9-]+) ([A-Za-z0-9.-]*) ([^ ]*) \\\"([^\\\"]*)\\\" \\\"([^\\\"]*)\\\" \\\"([^\\\"]*)\\\" ([-.0-9]*) ([^ ]*) \\\"([^\\\"]*)\\\" \\\"([^\\\"]*)\\\"($| \\\"[^ ]*\\\")(.*)\"\n      }\n    }\n    compressed                = \"true\"\n    stored_as_sub_directories = \"false\"\n    dynamic \"columns\" {\n      for_each = var.app_access_logs_columns\n      content {\n        name = columns.key\n        type = columns.value\n      }\n    }\n  }\n}\n\nresource \"aws_glue_catalog_table\" \"cloudfrontGlueAppAccessLogsTable\" {\n  count         = local.AthenaLogParser == \"yes\" && local.CloudFrontScannersProbesAthenaLogParser == \"yes\" ? 1 : 0\n  name          = \"app_access_logs-${random_id.server.hex}\"\n  database_name = aws_glue_catalog_database.mydatabase[0].name\n  catalog_id    = data.aws_caller_identity.current.account_id\n  parameters = {\n    \"skip.header.line.count\" = \"2\",\n    \"EXTERNAL\"               = \"TRUE\"\n  }\n  partition_keys {\n    name = \"year\"\n    type = \"int\"\n  }\n  partition_keys {\n    name = \"month\"\n    type = \"init\"\n  }\n  partition_keys {\n    name = \"day\"\n    type = \"int\"\n  }\n  partition_keys {\n    name = \"hour\"\n    type = \"int\"\n  }\n  storage_descriptor {\n    location      = \"s3://${local.AppLogBucket}/AWSLogs-Partitioned/\"\n    input_format  = \"org.apache.hadoop.mapred.TextInputFormat\"\n    output_format = \"org.apache.hadoop.hive.ql.io.IgnoreKeyTextOutputFormat\"\n\n    ser_de_info {\n      serialization_library = \"org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\"\n\n      parameters = {\n        \"serialization.format\" = \"\\t\",\n        \"field.delim\"          = \"\\t\"\n      }\n    }\n    compressed                = \"true\"\n    stored_as_sub_directories = \"true\"\n    dynamic \"columns\" {\n      for_each = var.cloudfront_app_access_logs_columns\n      content {\n        name = columns.key\n        type = columns.value\n      }\n    }\n  }\n}\n\n\nresource \"aws_athena_workgroup\" \"WAFAddPartitionAthenaQueryWorkGroup\" {\n  count         = local.AthenaLogParser == \"yes\" ? 1 : 0\n  name          = \"WAFAddPartitionAthenaQueryWorkGroup-${random_id.server.hex}\"\n  description   = \"Athena WorkGroup for adding Athena partition queries used by AWS WAF Security Automations Solution\"\n  state         = \"ENABLED\"\n  force_destroy = \"true\"\n\n  configuration {\n    publish_cloudwatch_metrics_enabled = true\n    result_configuration {\n      output_location = \"s3://${local.AppLogBucket}/outputWAFAppAccessLogAthenaQueryWorkGroup/\"\n      encryption_configuration {\n        encryption_option = \"SSE_KMS\"\n        kms_key_arn       = aws_kms_key.wafkey.arn\n      }\n    }\n  }\n}\n\nresource \"aws_athena_workgroup\" \"WAFLogAthenaQueryWorkGroup\" {\n  count         = local.HttpFloodAthenaLogParser == \"yes\" ? 1 : 0\n  name          = \"WAFLogAthenaQueryWorkGroup-${random_id.server.hex}\"\n  description   = \"Athena WorkGroup for adding Athena partition queries used by AWS WAF Security Automations Solution\"\n  state         = \"ENABLED\"\n  force_destroy = \"true\"\n\n  configuration {\n    publish_cloudwatch_metrics_enabled = true\n    result_configuration {\n      output_location = \"s3://${local.AppLogBucket}/outputWAFAppAccessLogAthenaQueryWorkGroup/\"\n      encryption_configuration {\n        encryption_option = \"SSE_KMS\"\n        kms_key_arn       = aws_kms_key.wafkey.arn\n      }\n    }\n  }\n}\n\nresource \"aws_athena_workgroup\" \"WAFAppAccessLogAthenaQueryWorkGroup\" {\n  count         = local.ScannersProbesAthenaLogParser == \"yes\" ? 1 : 0\n  name          = \"WAFAppAccessLogAthenaQueryWorkGroup-${random_id.server.hex}\"\n  description   = \"Athena WorkGroup for adding Athena partition queries used by AWS WAF Security Automations Solution\"\n  state         = \"ENABLED\"\n  force_destroy = \"true\"\n\n  configuration {\n    publish_cloudwatch_metrics_enabled = true\n    result_configuration {\n      output_location = \"s3://${local.AppLogBucket}/outputWAFAppAccessLogAthenaQueryWorkGroup/\"\n      encryption_configuration {\n        encryption_option = \"SSE_KMS\"\n        kms_key_arn       = aws_kms_key.wafkey.arn\n      }\n    }\n  }\n}\n\n\n# ----------------------------------------------------------------------------------------------------------------------\n# CREATE A EVENT RULES\n# ----------------------------------------------------------------------------------------------------------------------\n\nresource \"aws_cloudwatch_event_rule\" \"LambdaAddAthenaPartitionsEventsRule\" {\n  count               = local.AthenaLogParser == \"yes\" ? 1 : 0\n  name                = \"LambdaAddAthenaPartitionsEventsRule-${random_id.server.hex}\"\n  description         = \"Security Automations - Add partitions to Athena table\"\n  schedule_expression = \"cron(* ? * * * *)\"\n  is_enabled          = true\n}\n\n\nresource \"aws_cloudwatch_event_target\" \"LambdaAddAthenaPartitionstarget\" {\n  count     = local.AthenaLogParser == \"yes\" && local.ALBScannersProbesAthenaLogParser == \"yes\" ? 1 : 0\n  target_id = \"LambdaAddAthenaPartitions\"\n  arn       = aws_lambda_function.AddAthenaPartitions[0].arn\n  rule      = aws_cloudwatch_event_rule.LambdaAddAthenaPartitionsEventsRule[0].name\n  input     = <<EOF\n                {\n                \"resourceType\": \"LambdaAddAthenaPartitionsEventsRule\",\n                \"glueAccessLogsDatabase\": \"${aws_glue_catalog_database.mydatabase[0].name}\",\n                \"accessLogBucket\": \"${local.AppLogBucket}\",\n                \"glueAppAccessLogsTable\": \"${aws_glue_catalog_table.ALBGlueAppAccessLogsTable[0].name}\",\n                \"glueWafAccessLogsTable\": \"${aws_glue_catalog_table.waf_access_logs_table[0].name}\",\n                \"wafLogBucket\": \"${aws_s3_bucket.WafLogBucket[0].bucket}\",\n                \"athenaWorkGroup\": \"${aws_athena_workgroup.WAFAddPartitionAthenaQueryWorkGroup[0].name}\"\n              }\nEOF\n  depends_on = [\n    aws_cloudwatch_event_rule.LambdaAddAthenaPartitionsEventsRule\n  ]\n}\n\nresource \"aws_cloudwatch_event_rule\" \"LambdaAthenaWAFLogParserrule\" {\n  count               = local.HttpFloodAthenaLogParser == \"yes\" ? 1 : 0\n  name                = \"LambdaAthenaWAFLogParserrule-${random_id.server.hex}\"\n  description         = \"Security Automations - WAF Logs Athena parser\"\n  schedule_expression = \"rate(5 minutes)\"\n  is_enabled          = true\n}\n\nresource \"aws_cloudwatch_event_target\" \"LogParsertarget\" {\n  count     = local.HttpFloodAthenaLogParser == \"yes\" ? 1 : 0\n  target_id = \"LogParser\"\n  arn       = aws_lambda_function.LogParser[0].arn\n  rule      = aws_cloudwatch_event_rule.LambdaAthenaWAFLogParserrule[0].name\n  input     = <<EOF\n            {\n              \"resourceType\": \"LambdaAthenaWAFLogParser\",\n              \"glueAccessLogsDatabase\": \"${aws_glue_catalog_database.mydatabase[0].name}\",\n              \"accessLogBucket\": \"${local.AppLogBucket}\",\n              \"glueWafAccessLogsTable\": \"${aws_glue_catalog_table.waf_access_logs_table[0].name}\",\n              \"athenaWorkGroup\":\"${aws_athena_workgroup.WAFAppAccessLogAthenaQueryWorkGroup[0].name}\"\n            }\nEOF\n  depends_on = [\n    aws_cloudwatch_event_rule.LambdaAthenaWAFLogParserrule\n  ]\n}\n\nresource \"aws_cloudwatch_event_rule\" \"LambdaAthenaAppLogParserrule\" {\n  count               = local.ScannersProbesAthenaLogParser == \"yes\" ? 1 : 0\n  name                = \"LambdaAthenaAppLogParserrule-${random_id.server.hex}\"\n  description         = \"Security Automation - App Logs Athena parser\"\n  schedule_expression = \"rate(5 minutes)\"\n  is_enabled          = true\n}\n\nresource \"aws_cloudwatch_event_target\" \"LogParsertarget1\" {\n  count     = local.ScannersProbesAthenaLogParser == \"yes\" && local.ALBScannersProbesAthenaLogParser == \"yes\" ? 1 : 0\n  target_id = \"LogParser\"\n  arn       = aws_lambda_function.LogParser[0].arn\n  rule      = aws_cloudwatch_event_rule.LambdaAthenaAppLogParserrule[0].name\n  input     = <<EOF\n            {\n              \"resourceType\": \"LambdaAthenaAppLogParser\",\n              \"glueAccessLogsDatabase\": \"${aws_glue_catalog_database.mydatabase[0].name}\",\n              \"accessLogBucket\": \"${local.AppLogBucket}\",\n              \"glueAppAccessLogsTable\": \"${local.AppAccessLogsTable}\",\n              \"athenaWorkGroup\": \"${aws_athena_workgroup.WAFAppAccessLogAthenaQueryWorkGroup[0].name}\"\n            }\nEOF\n  depends_on = [\n    aws_cloudwatch_event_rule.LambdaAthenaAppLogParserrule[0]\n  ]\n}\n\n\nresource \"aws_cloudwatch_event_rule\" \"ReputationListsParserEventsRule\" {\n  count               = var.ReputationListsProtectionActivated == \"yes\" ? 1 : 0\n  name                = \"ReputationEventsRule-${random_id.server.hex}\"\n  description         = \"Security Automation - WAF Reputation Lists\"\n  schedule_expression = \"rate(1 hour)\"\n  is_enabled          = true\n}\n\nresource \"aws_cloudwatch_event_target\" \"ReputationListsParsertarget\" {\n  target_id = \"ReputationListsParser\"\n  arn       = aws_lambda_function.ReputationListsParser[0].arn\n  rule      = aws_cloudwatch_event_rule.ReputationListsParserEventsRule[0].name\n  input     = <<EOF\n              {\n                \"URL_LIST\": [\n                  {\"url\":\"https://www.spamhaus.org/drop/drop.txt\"},\n                  {\"url\":\"https://www.spamhaus.org/drop/edrop.txt\"},\n                  {\"url\":\"https://check.torproject.org/exit-addresses\", \"prefix\":\"ExitAddress\"},\n                  {\"url\":\"https://rules.emergingthreats.net/fwrules/emerging-Block-IPs.txt\"}\n                ],\n                \"IP_SET_ID_REPUTATIONV4\": \"${aws_wafv2_ip_set.WAFReputationListsSetV4[0].arn}\",\n                \"IP_SET_ID_REPUTATIONV6\": \"${aws_wafv2_ip_set.WAFReputationListsSetV6[0].arn}\",\n                \"IP_SET_NAME_REPUTATIONV4\": \"${aws_wafv2_ip_set.WAFReputationListsSetV4[0].name}\",\n                \"IP_SET_NAME_REPUTATIONV6\": \"${aws_wafv2_ip_set.WAFReputationListsSetV6[0].name}\",\n                \"SCOPE\": \"${local.SCOPE}\"\n              }\nEOF\n  depends_on = [\n    aws_cloudwatch_event_rule.ReputationListsParserEventsRule\n  ]\n}\n\nresource \"aws_cloudwatch_event_rule\" \"SetIPRetentionEventsRule\" {\n  count         = var.IPRetentionPeriod == \"yes\" ? 1 : 0\n  name          = \"IPRetentionPeriodsRule-${random_id.server.hex}\"\n  description   = \"AWS WAF Security Automations - Events rule for setting IP retention\"\n  is_enabled    = true\n  event_pattern = <<EOF\n{\n  \"detail-type\": [\"AWS API Call via CloudTrail\"],\n  \"source\": [\"aws.wafv2\"],\n  \"detail\": {\n    \"eventSource\": [\"wafv2.amazonaws.com\"],\n    \"eventName\": [\"UpdateIPSet\"],\n    \"requestParameters\" : [\n        \"${aws_wafv2_ip_set.WAFWhitelistSetV4.name}\",\n        \"${aws_wafv2_ip_set.WAFBlacklistSetV4.name}\",\n        \"${aws_wafv2_ip_set.WAFWhitelistSetV6.name}\",\n        \"${aws_wafv2_ip_set.WAFBlacklistSetV6.name}\"\n    ]\n\n  }\n}\n  EOF\n}\n\nresource \"aws_cloudwatch_event_target\" \"SetIPRetentionEventstarget\" {\n  count     = var.IPRetentionPeriod == \"yes\" ? 1 : 0\n  target_id = \"SetIPRetentionLambda\"\n  arn       = aws_lambda_function.SetIPRetention[0].arn\n  rule      = aws_cloudwatch_event_rule.SetIPRetentionEventsRule[0].name\n  depends_on = [\n    aws_cloudwatch_event_rule.SetIPRetentionEventsRule[0]\n  ]\n}\n\n\n# ----------------------------------------------------------------------------------------------------------------------\n# CREATE A LAMBDA PERMISSION\n# ----------------------------------------------------------------------------------------------------------------------\n\nresource \"aws_lambda_permission\" \"LambdaInvokePermissionAppLogParserS3\" {\n  count          = local.LogParser == \"yes\" ? 1 : 0\n  action         = \"lambda:InvokeFunction\"\n  function_name  = aws_lambda_function.LogParser[0].function_name\n  principal      = \"s3.amazonaws.com\"\n  source_account = data.aws_caller_identity.current.account_id\n}\n\nresource \"aws_lambda_permission\" \"LambdaInvokePermissionMoveS3LogsForPartition\" {\n  count          = local.ScannersProbesAthenaLogParser == \"yes\" ? 1 : 0\n  action         = \"lambda:InvokeFunction\"\n  function_name  = aws_lambda_function.MoveS3LogsForPartition[0].function_name\n  principal      = \"s3.amazonaws.com\"\n  source_account = data.aws_caller_identity.current.account_id\n}\n\nresource \"aws_lambda_permission\" \"LambdaPermissionAddAthenaPartitions\" {\n  count         = local.AthenaLogParser == \"yes\" ? 1 : 0\n  action        = \"lambda:InvokeFunction\"\n  function_name = aws_lambda_function.AddAthenaPartitions[0].function_name\n  principal     = \"events.amazonaws.com\"\n  source_arn    = aws_cloudwatch_event_rule.LambdaAddAthenaPartitionsEventsRule[0].arn\n}\n\nresource \"aws_lambda_permission\" \"LambdaInvokePermissionSetIPRetention\" {\n  count         = var.IPRetentionPeriod == \"yes\" ? 1 : 0\n  action        = \"lambda:InvokeFunction\"\n  function_name = aws_lambda_function.SetIPRetention[0].function_name\n  principal     = \"events.amazonaws.com\"\n  source_arn    = aws_cloudwatch_event_rule.SetIPRetentionEventsRule[0].arn\n}\n\nresource \"aws_lambda_permission\" \"LambdaInvokePermissionWafLogParserCloudWatch\" {\n  count         = local.HttpFloodAthenaLogParser == \"yes\" ? 1 : 0\n  action        = \"lambda:InvokeFunction\"\n  function_name = aws_lambda_function.LogParser[0].function_name\n  principal     = \"events.amazonaws.com\"\n  source_arn    = aws_cloudwatch_event_rule.LambdaAthenaWAFLogParserrule[0].arn\n}\n\nresource \"aws_lambda_permission\" \"LambdaInvokePermissionAppLogParserCloudWatch\" {\n  count         = local.ScannersProbesAthenaLogParser == \"yes\" ? 1 : 0\n  action        = \"lambda:InvokeFunction\"\n  function_name = aws_lambda_function.LogParser[0].function_name\n  principal     = \"events.amazonaws.com\"\n  source_arn    = aws_cloudwatch_event_rule.LambdaAthenaAppLogParserrule[0].arn\n}\n\nresource \"aws_lambda_permission\" \"LambdaInvokePermissionReputationListsParser\" {\n  count         = var.ReputationListsProtectionActivated == \"yes\" ? 1 : 0\n  action        = \"lambda:InvokeFunction\"\n  function_name = aws_lambda_function.ReputationListsParser[0].function_name\n  principal     = \"events.amazonaws.com\"\n  source_arn    = aws_cloudwatch_event_rule.ReputationListsParserEventsRule[0].arn\n}\n\nresource \"aws_lambda_permission\" \"LambdaInvokePermissionBadBot\" {\n  count         = var.BadBotProtectionActivated == \"yes\" ? 1 : 0\n  action        = \"lambda:InvokeFunction\"\n  function_name = aws_lambda_function.BadBotParser[0].function_name\n  principal     = \"apigateway.amazonaws.com\"\n  source_arn    = aws_api_gateway_rest_api.api[0].arn\n}\n\n# ----------------------------------------------------------------------------------------------------------------------\n# API gateway\n# ----------------------------------------------------------------------------------------------------------------------\n\nresource \"aws_api_gateway_rest_api\" \"api\" {\n  count       = var.BadBotProtectionActivated == \"yes\" ? 1 : 0\n  name        = \"WAF Bad Bot API-${random_id.server.hex}\"\n  description = \"API created by AWS WAF Security Automation CloudFormation template. This endpoint will be used to capture bad bots.\"\n  lifecycle {\n    create_before_destroy = true\n  }\n}\n\nresource \"aws_api_gateway_resource\" \"resource\" {\n  parent_id   = aws_api_gateway_rest_api.api[0].root_resource_id\n  path_part   = \"{proxy+}\"\n  rest_api_id = aws_api_gateway_rest_api.api[0].id\n  depends_on = [\n    aws_api_gateway_rest_api.api\n  ]\n}\n\nresource \"aws_api_gateway_method\" \"ApiGatewayBadBotMethodRoot\" {\n  authorization      = \"NONE\"\n  http_method        = \"ANY\"\n  api_key_required   = true\n  resource_id        = aws_api_gateway_rest_api.api[0].root_resource_id\n  rest_api_id        = aws_api_gateway_rest_api.api[0].id\n  request_parameters = { \"method.request.header.X-Forwarded-For\" = false }\n  depends_on = [\n    aws_lambda_permission.LambdaInvokePermissionBadBot,\n    aws_api_gateway_rest_api.api\n  ]\n}\n\nresource \"aws_api_gateway_integration\" \"integrationroot\" {\n  rest_api_id             = aws_api_gateway_rest_api.api[0].id\n  resource_id             = aws_api_gateway_rest_api.api[0].root_resource_id\n  http_method             = aws_api_gateway_method.ApiGatewayBadBotMethodRoot.http_method\n  integration_http_method = \"POST\"\n  type                    = \"AWS_PROXY\"\n  uri                     = \"arn:${data.aws_partition.current.partition}:apigateway:${data.aws_region.current.name}:lambda:path/2015-03-31/functions/${aws_lambda_function.BadBotParser[0].arn}/invocations\"\n  depends_on = [\n    aws_api_gateway_method.ApiGatewayBadBotMethodRoot,\n    aws_api_gateway_rest_api.api\n  ]\n}\n\n\n\nresource \"aws_api_gateway_method\" \"ApiGatewayBadBotMethod\" {\n  authorization      = \"NONE\"\n  http_method        = \"ANY\"\n  api_key_required   = true\n  resource_id        = aws_api_gateway_resource.resource.id\n  rest_api_id        = aws_api_gateway_rest_api.api[0].id\n  request_parameters = { \"method.request.header.X-Forwarded-For\" = false }\n  depends_on = [\n    aws_lambda_permission.LambdaInvokePermissionBadBot\n  ]\n}\n\nresource \"aws_api_gateway_integration\" \"integration\" {\n  rest_api_id             = aws_api_gateway_rest_api.api[0].id\n  resource_id             = aws_api_gateway_resource.resource.id\n  http_method             = aws_api_gateway_method.ApiGatewayBadBotMethod.http_method\n  integration_http_method = \"POST\"\n  type                    = \"AWS_PROXY\"\n  uri                     = \"arn:${data.aws_partition.current.partition}:apigateway:${data.aws_region.current.name}:lambda:path/2015-03-31/functions/${aws_lambda_function.BadBotParser[0].arn}/invocations\"\n  depends_on = [\n    aws_api_gateway_method.ApiGatewayBadBotMethod\n  ]\n}\n\n\nresource \"aws_api_gateway_deployment\" \"deployment\" {\n  rest_api_id = aws_api_gateway_rest_api.api[0].id\n  stage_name  = \"CFDeploymentStage-${random_id.server.hex}\"\n  lifecycle {\n    create_before_destroy = true\n  }\n  depends_on = [\n    aws_api_gateway_method.ApiGatewayBadBotMethod,\n    aws_api_gateway_integration.integration\n    \n  ]\n}\n\n\n\nresource \"aws_cloudwatch_log_group\" \"ApiGatewayBadBotStageAccessLogGroup\" {\n  count             = var.BadBotProtectionActivated == \"yes\" ? 1 : 0\n  name              = \"ApiGatewayBadBotStageAccessLogGroup-${random_id.server.hex}\"\n  retention_in_days = 90\n  kms_key_id        = aws_kms_key.wafkey.arn\n}\n\nresource \"aws_api_gateway_stage\" \"stage\" {\n  count = var.BadBotProtectionActivated == \"yes\" ? 1 : 0\n  deployment_id         = aws_api_gateway_deployment.deployment.id\n  rest_api_id           = aws_api_gateway_rest_api.api[0].id\n  stage_name            = \"ProdStage\"\n  xray_tracing_enabled  = true\n  cache_cluster_enabled = true\n  cache_cluster_size    = 0.5\n  access_log_settings {\n    destination_arn = aws_cloudwatch_log_group.ApiGatewayBadBotStageAccessLogGroup[0].arn\n    format = jsonencode({\n      sourceIp       = \"$context.identity.sourceIp\"\n      caller         = \"$context.identity.caller\"\n      user           = \"$context.identity.user\"\n      requestTime    = \"$context.requestTime\"\n      httpMethod     = \"$context.httpMethod\"\n      resourcePath   = \"$context.resourcePath\"\n      protocol       = \"$context.protocol\"\n      status         = \"$context.status\"\n      responseLength = \"$context.responseLength\"\n      requestId      = \"$context.requestId\"\n      }\n    )\n  }\n}\n\n\nresource \"aws_api_gateway_method_settings\" \"path_specific\" {\n  count       = var.BadBotProtectionActivated == \"yes\" ? 1 : 0\n  rest_api_id = aws_api_gateway_rest_api.api[0].id\n  stage_name  = aws_api_gateway_stage.stage[0].stage_name\n  method_path = \"*/*\"\n\n  settings {\n    metrics_enabled = true\n    logging_level   = \"INFO\"\n    caching_enabled = true\n  }\n}\n\n\nresource \"aws_iam_role\" \"ApiGatewayBadBotCloudWatchRole\" {\n  count = var.BadBotProtectionActivated == \"yes\" ? 1 : 0\n  name  = \"BadBotRole1-${random_id.server.hex}\"\n\n  assume_role_policy = <<EOF\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Action\": \"sts:AssumeRole\",\n      \"Principal\": {\n        \"Service\": \"apigateway.amazonaws.com\"\n      },\n      \"Effect\": \"Allow\",\n      \"Sid\": \"\"\n    }\n  ]\n}\nEOF\n}\n\nresource \"aws_iam_role_policy\" \"ApiGatewayBadBotCloudWatchploicy\" {\n  name   = \"ApiGatewayBadBotCloudWatchpolicy\"\n  role   = aws_iam_role.ApiGatewayBadBotCloudWatchRole[0].id\n  policy = <<EOT\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Action\": [\n                \"logs:CreateLogGroup\",\n                \"logs:CreateLogStream\",\n                \"logs:PutLogEvents\",\n                \"logs:DescribeLogGroups\",\n                \"logs:DescribeLogStreams\",\n                \"logs:GetLogEvents\",\n                \"logs:FilterLogEvents\"\n            ],\n            \"Resource\": [\n                \"arn:${data.aws_partition.current.partition}:logs:${data.aws_region.current.name}:${data.aws_caller_identity.current.account_id}:*\"\n            ],\n            \"Effect\": \"Allow\"\n        }\n    ]\n}\nEOT\n  depends_on = [\n    aws_iam_role.ApiGatewayBadBotCloudWatchRole\n  ]\n}\n\nresource \"aws_api_gateway_account\" \"ApiGatewayBadBotAccount\" {\n  count               = var.BadBotProtectionActivated == \"yes\" ? 1 : 0\n  cloudwatch_role_arn = aws_iam_role.ApiGatewayBadBotCloudWatchRole[0].arn\n  depends_on = [\n    aws_api_gateway_rest_api.api\n  ]\n}\n\n\n# ----------------------------------------------------------------------------------------------------------------------\n# CloudWatch Dashboard\n# ----------------------------------------------------------------------------------------------------------------------\n\n\nresource \"aws_cloudwatch_dashboard\" \"main\" {\n  dashboard_name = \"MonitoringDashboard-${data.aws_region.current.name}\"\n\n  dashboard_body = <<EOF\n{\n  \"widgets\": [\n    {\n      \"type\": \"metric\",\n      \"x\": 0,\n      \"y\": 0,\n      \"width\": 15,\n      \"height\": 10,\n      \"properties\": {\n        \"metrics\":[\n                      [\"WAF\", \"BlockedRequests\", \"WebACL\", \"WAFWebACLMetric\", \"Rule\", \"ALL\", \"Region\", \"${data.aws_region.current.name}\" ],\n                      [\"WAF\", \"AllowedRequests\", \"WebACL\", \"WAFWebACLMetric\", \"Rule\", \"ALL\", \"Region\", \"${data.aws_region.current.name}\" ]\n            ],\n        \"view\": \"timeSeries\",\n        \"stacked\": false,\n        \"stat\": \"Sum\",\n        \"period\": 300,\n        \"region\": \"${data.aws_region.current.name}\"\n      }\n    }\n  ]\n}\nEOF\n}",
    "provider.tf": "terraform {\n  required_providers {\n    aws = {\n      source  = \"hashicorp/aws\"\n      version = \"~> 3.0\"\n    }\n  }\n}\n\n# Configure the AWS Provider\nprovider \"aws\" {\n  region = \"us-east-1\"\n}",
    "var.tf": "variable \"AppAccessLogBucket\" {\n  description = \"Application Access Log Bucket Name\"\n  type        = string\n  default     = \"myownbucket-tam\"\n}\nvariable \"SourceBucket\" {\n  description = \"Lambda source code bucket\"\n  type        = string\n  default     = \"solutions\"\n}\nvariable \"KeyPrefix\" {\n  description = \"Keyprefix values for the lambda source code\"\n  type        = string\n  default     = \"aws-waf-security-automations/v3.2.0\"\n}\nvariable \"LOG_LEVEL\" {\n  description = \"Log level\"\n  type        = string\n  default     = \"INFO\"\n}\n\nvariable \"sse_algorithm\" {\n  description = \"sse_algorithm\"\n  type        = string\n  default     = \"aws:kms\"\n}\n\n#ELigible for switch case\n\nvariable \"ENDPOINT\" {\n  description = \"cloudfront or ALB\"\n  type        = string\n  default     = \"cloudFront\"\n  validation {\n    condition     = contains([\"cloudfront\", \"ALB\"], var.ENDPOINT)\n    error_message = \"Invalid input, options: \\\"cloudfront\\\",\\\"ALB\\\".\"\n  }\n}\n\nlocals {\n  LOG_TYPE = var.ENDPOINT == \"ALB\" ? \"alb\" : \"cloudFront\"\n}\n\nlocals {\n  SCOPE = var.ENDPOINT == \"ALB\" ? \"REGIONAL\" : \"CLOUDFRONT\"\n}\n\nvariable \"USER_AGENT_EXTRA\" {\n  description = \"UserAgent\"\n  type        = string\n  default     = \"AwsSolution/SO0006/v3.2.0\"\n}\nvariable \"SEND_ANONYMOUS_USAGE_DATA\" {\n  description = \"Data collection parameter\"\n  type        = string\n  default     = \"yes\"\n}\nvariable \"MetricsURL\" {\n  description = \"Metrics URL\"\n  type        = string\n  default     = \"https://metrics.awssolutionsbuilder.com/generic\"\n}\nvariable \"SolutionID\" {\n  description = \"UserAgent id value\"\n  type        = string\n  default     = \"SO0006\"\n}\nvariable \"KEEP_ORIGINAL_DATA\" {\n  description = \"S3 original data\"\n  type        = string\n  default     = \"No\"\n}\nvariable \"SendAnonymousUsageData\" {\n  description = \"Data collection parameter\"\n  type        = string\n  default     = \"yes\"\n}\nvariable \"IPRetentionPeriodAllowedParam\" {\n  description = \"IP Retention Settings allowed value\"\n  type        = number\n  default     = -1\n}\nvariable \"IPRetentionPeriodDeniedParam\" {\n  description = \"IP Retention Settings denied value\"\n  type        = number\n  default     = -1\n}\nvariable \"RequestThreshold\" {\n  description = \"request threshold for Log Monitoring Settings\"\n  type        = number\n  default     = 100\n}\nvariable \"WAFBlockPeriod\" {\n  description = \"block period for Log Monitoring Settings\"\n  type        = number\n  default     = 240\n}\nvariable \"ErrorThreshold\" {\n  description = \"error threshold for Log Monitoring Settings\"\n  type        = number\n  default     = 50\n}\n\nvariable \"DeliveryStreamName\" {\n  description = \"Name of the Delivery stream value\"\n  type        = string\n  default     = \"terraform-kinesis-firehose-extended-s3-test-stream\"\n}\n\n\nvariable \"waf_access_logs_columns\" {\n  default = {\n    timestamp                   = \"bigint\"\n    formatversion               = \"int\"\n    webaclid                    = \"string\"\n    terminatingruleid           = \"string\"\n    terminatingruletype         = \"string\"\n    action                      = \"string\"\n    httpsourcename              = \"string\"\n    httpsourceid                = \"string\"\n    rulegrouplist               = \"array<string>\"\n    ratebasedrulelist           = \"array<string>\"\n    nonterminatingmatchingrules = \"array<string>\"\n    httprequest                 = \"struct<clientip:string,country:string,headers:array<struct<name:string,value:string>>,uri:string,args:string,httpversion:string,httpmethod:string,requestid:string>\"\n  }\n}\n\nvariable \"app_access_logs_columns\" {\n  default = {\n    type                     = \"string\"\n    time                     = \"string\"\n    elb                      = \"string\"\n    client_ip                = \"string\"\n    client_port              = \"int\"\n    target_ip                = \"string\"\n    target_port              = \"int\"\n    request_processing_time  = \"double\"\n    response_processing_time = \"double\"\n    target_processing_time   = \"double\"\n    elb_status_code          = \"string\"\n    target_status_code       = \"string\"\n    received_bytes           = \"bigint\"\n    sent_bytes               = \"bigint\"\n    request_verb             = \"string\"\n    request_url              = \"string\"\n    request_proto            = \"string\"\n    user_agent               = \"string\"\n    ssl_cipher               = \"string\"\n    ssl_protocol             = \"string\"\n    target_group_arn         = \"string\"\n    trace_id                 = \"string\"\n    domain_name              = \"string\"\n    chosen_cert_arn          = \"string\"\n    matched_rule_priority    = \"string\"\n    request_creation_time    = \"string\"\n    actions_executed         = \"string\"\n    redirect_url             = \"string\"\n    lambda_error_reason      = \"string\"\n    new_field                = \"string\"\n  }\n}\n\nvariable \"cloudfront_app_access_logs_columns\" {\n  default = {\n    date               = \"date\"\n    time               = \"string\"\n    location           = \"string\"\n    bytes              = \"bigint\"\n    requestip          = \"string\"\n    method             = \"string\"\n    host               = \"string\"\n    uri                = \"string\"\n    status             = \"int\"\n    referrer           = \"string\"\n    useragent          = \"string\"\n    querystring        = \"string\"\n    cookie             = \"string\"\n    resulttype         = \"string\"\n    requestid          = \"string\"\n    hostheader         = \"string\"\n    requestprotocol    = \"string\"\n    requestbytes       = \"bigint\"\n    timetaken          = \"float\"\n    xforwardedfor      = \"string\"\n    sslprotocol        = \"string\"\n    sslcipher          = \"string\"\n    responseresulttype = \"string\"\n    httpversion        = \"string\"\n    filestatus         = \"string\"\n    encryptedfields    = \"int\"\n  }\n}\n\n\nvariable \"SNSEmailParam\" {\n  description = \"SNS notification value\"\n  type        = string\n  default     = \"\"\n}\n\nlocals {\n  SNSEmail = var.SNSEmailParam == \"\" ? \"no\" : \"yes\"\n}\n\n\n\nvariable \"ActivateHttpFloodProtectionParam\" {\n  type    = string\n  default = \"yes - AWS WAF rate based rule\"\n\n  # using contains()\n  validation {\n    condition     = contains([\"yes - AWS Lambda log parser\", \"yes - Amazon Athena log parser\", \"yes - AWS WAF rate based rule\", \"no\"], var.ActivateHttpFloodProtectionParam)\n    error_message = \"Invalid input, options: \\\"yes - AWS Lambda log parser\\\", \\\"yes - Amazon Athena log parser\\\",\\\"yes - AWS WAF rate based rule\\\", \\\"no\\\".\"\n  }\n}\n\nlocals {\n  HttpFloodProtectionRateBasedRuleActivated = var.ActivateHttpFloodProtectionParam == \"yes - AWS WAF rate based rule\" ? \"yes\" : \"no\"\n}\n\nlocals {\n  HttpFloodAthenaLogParser = var.ActivateHttpFloodProtectionParam == \"yes - Amazon Athena log parser\" ? \"yes\" : \"no\"\n}\n\nlocals {\n  HttpFloodLambdaLogParser = var.ActivateHttpFloodProtectionParam == \"yes - AWS Lambda log parser\" ? \"yes\" : \"no\"\n}\n\nlocals {\n  HttpFloodProtectionLogParserActivated = var.ActivateHttpFloodProtectionParam == \"yes - AWS Lambda log parser\" || var.ActivateHttpFloodProtectionParam == \"yes - Amazon Athena log parser\" ? \"yes\" : \"no\"\n}\n\nvariable \"ActivateAWSManagedRulesParam\" {\n  type    = string\n  default = \"no\"\n\n  # using contains()\n  validation {\n    condition     = contains([\"yes\", \"no\"], var.ActivateAWSManagedRulesParam)\n    error_message = \"Invalid input, options: \\\"yes\\\",\\\"no\\\".\"\n  }\n}\n\nvariable \"ActivateSqlInjectionProtectionParam\" {\n  type    = string\n  default = \"yes\"\n\n  # using contains()\n  validation {\n    condition     = contains([\"yes\", \"no\"], var.ActivateSqlInjectionProtectionParam)\n    error_message = \"Invalid input, options: \\\"yes\\\",\\\"no\\\".\"\n  }\n}\n\nvariable \"ActivateCrossSiteScriptingProtectionParam\" {\n  type    = string\n  default = \"yes\"\n\n  # using contains()\n  validation {\n    condition     = contains([\"yes\", \"no\"], var.ActivateCrossSiteScriptingProtectionParam)\n    error_message = \"Invalid input, options: \\\"yes\\\",\\\"no\\\".\"\n  }\n}\n\nvariable \"ActivateReputationListsProtectionParam\" {\n  type    = string\n  default = \"yes\"\n\n  # using contains()\n  validation {\n    condition     = contains([\"yes\", \"no\"], var.ActivateReputationListsProtectionParam)\n    error_message = \"Invalid input, options: \\\"yes\\\",\\\"no\\\".\"\n  }\n}\n\nvariable \"ActivateBadBotProtectionParam\" {\n  type    = string\n  default = \"yes\"\n\n  # using contains()\n  validation {\n    condition     = contains([\"yes\", \"no\"], var.ActivateBadBotProtectionParam)\n    error_message = \"Invalid input, options: \\\"yes\\\",\\\"no\\\".\"\n  }\n}\n\nvariable \"ActivateScannersProbesProtectionParam\" {\n  type    = string\n  default = \"\"\n\n  # using contains()\n  validation {\n    condition     = contains([\"yes - AWS Lambda log parser\", \"yes - Amazon Athena log parser\", \"no\"], var.ActivateScannersProbesProtectionParam)\n    error_message = \"Invalid input, options: \\\"yes - AWS Lambda log parser\\\", \\\"yes - Amazon Athena log parser\\\",\\\"no\\\".\"\n  }\n}\n\nlocals {\n  ScannersProbesAthenaLogParser = var.ActivateScannersProbesProtectionParam == \"yes - Amazon Athena log parser\" ? \"yes\" : \"no\"\n}\n\nlocals {\n  ScannersProbesLambdaLogParser = var.ActivateScannersProbesProtectionParam == \"yes - AWS Lambda log parser\" ? \"yes\" : \"no\"\n}\n\nvariable \"ScannersProbesProtectionActivated\" {\n  type        = string\n  default     = \"yes\"\n  description = \"\"\n}\n\nlocals {\n  AthenaLogParser = var.ActivateHttpFloodProtectionParam == \"yes - Amazon Athena log parser\" && var.ActivateScannersProbesProtectionParam == \"yes - Amazon Athena log parser\" ? \"yes\" : \"no\"\n}\n\nlocals {\n  LogParser = var.ActivateHttpFloodProtectionParam != \"\" && var.ActivateScannersProbesProtectionParam != \"\" ? \"yes\" : \"no\"\n}\n\nvariable \"BadBotProtectionActivated\" {\n  type        = string\n  default     = \"yes\"\n  description = \"\"\n  validation {\n    condition     = contains([\"yes\", \"no\"], var.BadBotProtectionActivated)\n    error_message = \"Invalid input, options: \\\"yes\\\",\\\"no\\\".\"\n  }\n}\n\nvariable \"ReputationListsProtectionActivated\" {\n  type        = string\n  default     = \"yes\"\n  description = \"\"\n  validation {\n    condition     = contains([\"yes\", \"no\"], var.ReputationListsProtectionActivated)\n    error_message = \"Invalid input, options: \\\"yes\\\",\\\"no\\\".\"\n  }\n}\n\nvariable \"IPRetentionPeriod\" {\n  type        = string\n  default     = \"no\"\n  description = \"\"\n  validation {\n    condition     = contains([\"yes\", \"no\"], var.IPRetentionPeriod)\n    error_message = \"Invalid input, options: \\\"yes\\\",\\\"no\\\".\"\n  }\n}\n\nlocals {\n  CustomResourceLambdaAccess = var.ReputationListsProtectionActivated == \"yes\" || local.AthenaLogParser == \"yes\" ? \"yes\" : \"no\"\n}\n\nlocals {\n  ALBScannersProbesAthenaLogParser = var.ActivateScannersProbesProtectionParam == \"yes - Amazon Athena log parser\" && var.ENDPOINT == \"ALB\" ? \"yes\" : \"no\"\n}\n\nlocals {\n  CloudFrontScannersProbesAthenaLogParser = var.ActivateScannersProbesProtectionParam == \"yes - Amazon Athena log parser\" && var.ENDPOINT == \"cloudfront\" ? \"yes\" : \"no\"\n}\n\n"
  }
}