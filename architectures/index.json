{
  "version": 1,
  "architectures": {
    "simple_s3_test": {
      "hash": "simple_s3_test",
      "source_url": "local://simple_s3_test",
      "source_type": "custom",
      "discovered_at": "2026-01-10T17:33:22.095168",
      "services": [
        "s3"
      ],
      "resource_count": 2,
      "name": "Simple S3 Test",
      "description": "Simple standalone S3 bucket for local validation testing",
      "version": "1.0.0",
      "skipped": false,
      "skip_reason": null,
      "original_format": "terraform",
      "terraform_files": {},
      "has_app": true
    },
    "5f63fc2a95796608": {
      "hash": "5f63fc2a95796608",
      "source_url": "https://registry.terraform.io/modules/ViktorUJ/vpc/aws/1.1.0",
      "source_type": "terraform_registry",
      "discovered_at": "2026-01-10T20:16:17.211786",
      "services": [
        "ec2"
      ],
      "resource_count": 28,
      "name": "ViktorUJ/vpc",
      "description": "Terraform Module that defines a VPC with public/private subnets across multiple AZs with Internet Gateways",
      "version": "1.1.0",
      "skipped": false,
      "skip_reason": null,
      "original_format": null,
      "terraform_files": {
        "data.tf": "data \"aws_availability_zones\" \"available\" {}\n",
        "examples/custom/main.tf": "provider \"aws\" {\n  region = \"eu-north-1\"\n}\n\n\nmodule \"vpc\" {\n  source = \"ViktorUJ/vpc/aws\"\n  tags_default = {\n    \"Owner\"       = \"DevOps Team\"\n    \"Terraform\"   = \"true\"\n    \"cost_center\" = \"1111\"\n  }\n  vpc = {\n    name                  = \"test-vpc\"\n    cidr                  = \"10.10.0.0/16\"\n    secondary_cidr_blocks = [\"10.2.0.0/16\", \"10.3.0.0/16\"]\n    tags                  = { \"cost_center\" = \"444\" }\n    dhcp_options = {\n      ipv6_address_preferred_lease_time = \"2147483647\"\n    }\n    nacl_default = {\n      test = {\n        egress      = \"true\"\n        rule_number = \"99\"\n        rule_action = \"allow\"\n        protocol    = \"tcp\"\n        cidr_block  = \"0.0.0.0/0\"\n\n\n      }\n      test2 = {\n        egress      = \"false\"\n        rule_number = \"99\"\n        rule_action = \"allow\"\n        protocol    = \"tcp\"\n        cidr_block  = \"0.0.0.0/0\"\n\n\n      }\n    }\n  }\n\n  subnets = {\n    public = {\n      \"pub1\" = {\n        name                                = \"public-subnet-1\"\n        cidr                                = \"10.10.1.0/24\"\n        az                                  = \"eun1-az1\"\n        type                                = \"qa-test\"\n        tags                                = { \"cost_center\" = \"5555\" }\n        private_dns_hostname_type_on_launch = \"resource-name\"\n        nacl = {\n          test = {\n            egress      = \"true\"\n            rule_number = \"99\"\n            rule_action = \"allow\"\n            protocol    = \"tcp\"\n            cidr_block  = \"0.0.0.0/0\"\n          }\n          test2 = {\n            egress      = \"false\"\n            rule_number = \"99\"\n            rule_action = \"allow\"\n            protocol    = \"tcp\"\n            cidr_block  = \"0.0.0.0/0\"\n          }\n          allow_all_inbound = {\n            egress      = \"false\"\n            rule_number = \"9999\"\n            rule_action = \"allow\"\n            from_port   = \"0\"\n            to_port     = \"0\"\n            protocol    = \"-1\"\n            cidr_block  = \"0.0.0.0/0\"\n          }\n          allow_all_outbound = {\n            egress      = \"true\"\n            rule_number = \"8888\"\n            rule_action = \"allow\"\n            from_port   = \"0\"\n            to_port     = \"0\"\n            protocol    = \"-1\"\n            cidr_block  = \"0.0.0.0/0\"\n          }\n\n\n        }\n      }\n      \"pub2\" = {\n        name        = \"public-subnet-2\"\n        cidr        = \"10.10.2.0/24\"\n        az          = \"eun1-az3\"\n        type        = \"Devops\"\n        nat_gateway = \"DEFAULT\"\n        tags        = { \"cost_center\" = \"1234\" }\n\n      }\n\n    }\n    private = {\n      \"private_no_nat\" = {\n        name                                = \"private-subnet-1\"\n        cidr                                = \"10.10.33.0/24\"\n        az                                  = \"eun1-az1\"\n        type                                = \"qa-test\"\n        tags                                = { \"cost_center\" = \"5555\" }\n        private_dns_hostname_type_on_launch = \"resource-name\"\n        nat_gateway                         = \"NONE\"\n        nacl = {\n          test = {\n            egress      = \"true\"\n            rule_number = \"99\"\n            rule_action = \"allow\"\n            protocol    = \"tcp\"\n            cidr_block  = \"0.0.0.0/0\"\n          }\n          test2 = {\n            egress      = \"false\"\n            rule_number = \"99\"\n            rule_action = \"allow\"\n            protocol    = \"tcp\"\n            cidr_block  = \"0.0.0.0/0\"\n          }\n        }\n      }\n\n      \"private1\" = {\n        name                                = \"private-subnet-1\"\n        cidr                                = \"10.10.11.0/24\"\n        az                                  = \"eun1-az1\"\n        type                                = \"qa-test\"\n        tags                                = { \"cost_center\" = \"5555\" }\n        private_dns_hostname_type_on_launch = \"resource-name\"\n        nat_gateway                         = \"SINGLE\"\n        nacl = {\n          test = {\n            egress      = \"true\"\n            rule_number = \"99\"\n            rule_action = \"allow\"\n            protocol    = \"tcp\"\n            cidr_block  = \"0.0.0.0/0\"\n          }\n          test2 = {\n            egress      = \"false\"\n            rule_number = \"99\"\n            rule_action = \"allow\"\n            protocol    = \"tcp\"\n            cidr_block  = \"0.0.0.0/0\"\n          }\n        }\n\n\n      }\n      \"private2\" = {\n        name        = \"private-subnet-2\"\n        cidr        = \"10.10.12.0/24\"\n        az          = \"eun1-az3\"\n        type        = \"Devops\"\n        tags        = { \"cost_center\" = \"1234\" }\n        nat_gateway = \"SINGLE\"\n\n      }\n      \"private3\" = {\n        name        = \"private-subnet-3\"\n        cidr        = \"10.10.13.0/24\"\n        az          = \"eu-north-1a\"\n        type        = \"Devops\"\n        tags        = { \"cost_center\" = \"1234\" }\n        nat_gateway = \"SINGLE\"\n\n      }\n      \"private4\" = {\n        name        = \"private-subnet-4\"\n        cidr        = \"10.10.14.0/24\"\n        az          = \"eun1-az3\"\n        type        = \"Devops\"\n        tags        = { \"cost_center\" = \"1234\" }\n        nat_gateway = \"SINGLE\"\n\n      }\n\n      \"k8s1\" = {\n        name        = \"private-k8s-1\"\n        cidr        = \"10.10.15.0/24\"\n        az          = \"eun1-az3\"\n        type        = \"k8s\"\n        tags        = { \"cost_center\" = \"1234\" }\n        nat_gateway = \"SINGLE\"\n\n      }\n      \"k8s2\" = {\n        name        = \"private-k8s-2\"\n        cidr        = \"10.10.16.0/24\"\n        az          = \"eun1-az3\"\n        type        = \"k8s\"\n        tags        = { \"cost_center\" = \"1234\" }\n        nat_gateway = \"SINGLE\"\n\n\n      }\n\n    }\n\n\n  }\n\n}\n",
        "examples/custom/output.tf": "# inputs\noutput \"tags_default\" {\n  description = \"Default tags\"\n  value       = module.vpc.tags_default\n}\n\noutput \"subnets_var\" {\n  description = \"for test\"\n  value       = module.vpc.subnets_var\n}\noutput \"vpc_var\" {\n  value = module.vpc.vpc_var\n}\n\n# vpc\noutput \"vpc_raw\" {\n  value = module.vpc.vpc_raw\n}\n\n\n\n# debug\noutput \"az_mapping\" {\n  value = module.vpc.az_mapping\n}\n\n\n#subnets public\n\noutput \"normalized_public_subnets_all\" {\n  value = module.vpc.normalized_public_subnets_all\n}\n\noutput \"subnets_public_raw\" {\n  value = module.vpc.subnets_public_raw\n}\noutput \"public_subnets_by_type\" {\n  value = module.vpc.public_subnets_by_type\n}\n\noutput \"public_subnets_by_az\" {\n  value = module.vpc.public_subnets_by_az\n}\n\noutput \"public_subnets_by_az_id\" {\n  value = module.vpc.public_subnets_by_az_id\n}\n#subnets private\noutput \"normalized_private_subnets_all\" {\n  value = module.vpc.normalized_private_subnets_all\n}\n\noutput \"subnets_private_raw\" {\n  value = module.vpc.subnets_private_raw\n}\n\noutput \"private_subnets_by_type\" {\n  value = module.vpc.private_subnets_by_type\n}\n\noutput \"private_subnets_by_az\" {\n  value = module.vpc.private_subnets_by_az\n}\n\noutput \"private_subnets_by_az_id\" {\n  value = module.vpc.private_subnets_by_az_id\n}\n\n# NACL\noutput \"public_nacl_raw\" {\n  value = module.vpc.public_nacl_raw\n\n}\noutput \"public_nacl_rules_raw\" {\n  value = module.vpc.public_nacl_rules_raw\n}\n\noutput \"private_nacl_raw\" {\n  value = module.vpc.private_nacl_raw\n}\noutput \"private_nacl_rules_raw\" {\n  value = module.vpc.private_nacl_rules_raw\n}\n\n# NAT Gateway\n\noutput \"nat_gateway_single_raw\" {\n  value = module.vpc.nat_gateway_single_raw\n}\n\noutput \"nat_gateway_subnet_raw\" {\n  value = module.vpc.nat_gateway_subnet_raw\n}\n\noutput \"nat_gateway_az_raw\" {\n  value = module.vpc.nat_gateway_az_raw\n}\n\n# Route Table\noutput \"route_table_private_raw\" {\n  value = module.vpc.route_table_private_raw\n}\n\noutput \"route_table_public_raw\" {\n  value = module.vpc.route_table_public_raw\n}\n\n\n# EXAMPLES\n\noutput \"vpc_id\" {\n  value = module.vpc.vpc_raw.id\n}\n\noutput \"vpc_cidr_block\" {\n  value = module.vpc.vpc_raw.cidr_block\n}\n\noutput \"k8s_private_subnets\" {\n  description = \"K8s private subnets\"\n  value       = module.vpc.private_subnets_by_type.k8s.ids\n}\n\noutput \"private_subnets_az_id\" {\n  description = \"privare subnets in AZ iD eun1-az3\"\n  value       = module.vpc.private_subnets_by_az_id.eun1-az3\n}\n\noutput \"private_subnets_az\" {\n  description = \"privare subnets in AZ eu-north-1a\"\n  value       = module.vpc.private_subnets_by_az.eu-north-1a\n}\n",
        "examples/nacl_default/main.tf": "provider \"aws\" {\n  region = \"eu-north-1\"\n}\n\n\nmodule \"vpc\" {\n  source = \"ViktorUJ/vpc/aws\"\n  tags_default = {\n    \"Owner\"       = \"DevOps Team\"\n    \"Terraform\"   = \"true\"\n    \"cost_center\" = \"1111\"\n  }\n  vpc = {\n    name = \"test-vpc\"\n    cidr = \"10.10.0.0/16\"\n    nacl_default = {\n      test = {\n        egress      = \"true\"\n        rule_number = \"99\"\n        rule_action = \"allow\"\n        protocol    = \"tcp\"\n        cidr_block  = \"0.0.0.0/0\"\n\n\n      }\n      test2 = {\n        egress      = \"false\"\n        rule_number = \"99\"\n        rule_action = \"allow\"\n        protocol    = \"tcp\"\n        cidr_block  = \"0.0.0.0/0\"\n\n\n      }\n    }\n  }\n\n  subnets = {\n    public  = {}\n    private = {}\n\n  }\n}\n",
        "examples/nacl_default/output.tf": "output \"vpc_raw\" {\n  value = module.vpc.vpc_raw\n}\n\noutput \"nacl_default_rules_raw\" {\n  value = module.vpc.nacl_default_rules_raw\n}\n",
        "examples/nacl_subnet/main.tf": "provider \"aws\" {\n  region = \"eu-north-1\"\n}\n\n\nmodule \"vpc\" {\n  source = \"ViktorUJ/vpc/aws\"\n  tags_default = {\n    \"Owner\"       = \"DevOps Team\"\n    \"Terraform\"   = \"true\"\n    \"cost_center\" = \"1111\"\n  }\n  vpc = {\n    name = \"test-vpc\"\n    cidr = \"10.10.0.0/16\"\n  }\n\n  subnets = {\n    public = {\n      \"pub1\" = {\n        name = \"public-subnet-1\"\n        cidr = \"10.10.1.0/24\"\n        az   = \"eu-north-1a\"\n      }\n      \"pub2\" = {\n        name = \"public-subnet-2\"\n        cidr = \"10.10.2.0/24\"\n        az   = \"eu-north-1a\"\n      }\n\n    }\n    private = {\n\n      \"private1\" = {\n        name = \"private-subnet-1\"\n        cidr = \"10.10.11.0/24\"\n        az   = \"eu-north-1a\"\n        nacl = {\n          test = {\n            egress      = \"true\"\n            rule_number = \"99\"\n            rule_action = \"allow\"\n            protocol    = \"tcp\"\n            cidr_block  = \"0.0.0.0/0\"\n          }\n          test2 = {\n            egress      = \"false\"\n            rule_number = \"99\"\n            rule_action = \"allow\"\n            protocol    = \"tcp\"\n            cidr_block  = \"0.0.0.0/0\"\n          }\n          allow_all_inbound = {\n            egress      = \"false\"\n            rule_number = \"9999\"\n            rule_action = \"allow\"\n            from_port   = \"0\"\n            to_port     = \"0\"\n            protocol    = \"-1\"\n            cidr_block  = \"0.0.0.0/0\"\n          }\n          allow_all_outbound = {\n            egress      = \"true\"\n            rule_number = \"8888\"\n            rule_action = \"allow\"\n            from_port   = \"0\"\n            to_port     = \"0\"\n            protocol    = \"-1\"\n            cidr_block  = \"0.0.0.0/0\"\n          }\n\n\n        }\n\n      }\n      \"private2\" = {\n        name = \"private-subnet-2\"\n        cidr = \"10.10.12.0/24\"\n        az   = \"eu-north-1a\"\n        nacl = {\n          test = {\n            egress      = \"true\"\n            rule_number = \"99\"\n            rule_action = \"allow\"\n            protocol    = \"tcp\"\n            cidr_block  = \"0.0.0.0/0\"\n          }\n          ssh = {\n            egress      = \"false\"\n            rule_number = \"88\"\n            rule_action = \"allow\"\n            protocol    = \"tcp\"\n            from_port   = \"22\"\n            to_port     = \"22\"\n            cidr_block  = \"0.0.0.0/0\"\n\n          }\n          allow_all_inbound = {\n            egress      = \"false\"\n            rule_number = \"9999\"\n            rule_action = \"allow\"\n            from_port   = \"0\"\n            to_port     = \"0\"\n            protocol    = \"-1\"\n            cidr_block  = \"0.0.0.0/0\"\n          }\n          allow_all_outbound = {\n            egress      = \"true\"\n            rule_number = \"8888\"\n            rule_action = \"allow\"\n            from_port   = \"0\"\n            to_port     = \"0\"\n            protocol    = \"-1\"\n            cidr_block  = \"0.0.0.0/0\"\n          }\n\n\n        }\n      }\n    }\n  }\n}\n",
        "examples/nacl_subnet/output.tf": "output \"private_nacl_raw\" {\n  value = module.vpc.private_nacl_raw\n}\n\noutput \"private_nacl_rules_raw\" {\n  value = module.vpc.private_nacl_rules_raw\n}\n",
        "examples/nat_gateway_az/main.tf": "provider \"aws\" {\n  region = \"eu-north-1\"\n}\n\n\nmodule \"vpc\" {\n  source = \"ViktorUJ/vpc/aws\"\n  tags_default = {\n    \"Owner\"       = \"DevOps Team\"\n    \"Terraform\"   = \"true\"\n    \"cost_center\" = \"1111\"\n  }\n  vpc = {\n    name = \"test-vpc\"\n    cidr = \"10.10.0.0/16\"\n  }\n\n  subnets = {\n    public = {\n      \"pub1\" = {\n        name = \"public-subnet-1\"\n        cidr = \"10.10.1.0/24\"\n        az   = \"eu-north-1a\"\n      }\n      \"pub2\" = {\n        name = \"public-subnet-2\"\n        cidr = \"10.10.2.0/24\"\n        az   = \"eu-north-1b\"\n      }\n\n    }\n    private = {\n\n      \"private1\" = {\n        name        = \"private-subnet-1\"\n        cidr        = \"10.10.11.0/24\"\n        az          = \"eu-north-1a\"\n        nat_gateway = \"AZ\" # it is default . you can remove it\n\n      }\n      \"private2\" = {\n        name = \"private-subnet-2\"\n        cidr = \"10.10.12.0/24\"\n        az   = \"eu-north-1a\"\n        #       nat_gateway                         = \"AZ\"  # it is default . you can remove it\n      }\n      \"private3\" = {\n        name = \"private-subnet-3\"\n        cidr = \"10.10.13.0/24\"\n        az   = \"eu-north-1b\"\n        #       nat_gateway                         = \"AZ\"  # it is default . you can remove it\n      }\n      \"private4\" = {\n        name = \"private-subnet-4\"\n        cidr = \"10.10.14.0/24\"\n        az   = \"eu-north-1b\"\n        #       nat_gateway                         = \"AZ\"  # it is default . you can remove it\n      }\n\n\n    }\n  }\n}\n",
        "examples/nat_gateway_az/output.tf": "output \"nat_gateway_az_raw\" {\n  value = module.vpc.nat_gateway_az_raw\n}\n",
        "examples/nat_gateway_az_existing_eip/main.tf": "provider \"aws\" {\n  region = \"us-west-1\"\n}\n\nmodule \"vpc\" {\n  source = \"ViktorUJ/vpc/aws\"\n  # Using existing EIP IDs here\n  existing_eip_ids_az = {\n    \"us-west-1a\" = \"vpc-0a1b2c3d4e5f6g7h8\"\n    \"us-east-1b\" = \"vpc-0a1b2c3d4e5f6g7h8\"\n  }\n  vpc = {\n    name                  = \"main\"\n    cidr                  = \"10.2.0.0/16\"\n    secondary_cidr_blocks = [\"100.64.0.0/16\"]\n    instance_tenancy      = \"default\"\n    enable_dns_support    = true\n    enable_dns_hostnames  = false\n    tags_default = {\n      \"Environment\" = \"Dev\"\n      \"Name\"        = \"EKS-VPC\"\n      \"Owner\"       = \"DevOps\"\n    }\n    dhcp_options = {\n      domain_name          = \"\"\n      domain_name_servers  = []\n      ntp_servers          = []\n      netbios_name_servers = []\n      netbios_node_type    = \"\"\n    }\n  }\n\n  subnets = {\n    public = {\n      public1 = {\n        name                                           = \"public-1\"\n        cidr                                           = \"10.2.2.0/24\"\n        az                                             = \"us-west-1a\"\n        tags                                           = { \"Name\" = \"public-1\" }\n        type                                           = \"public\"\n        assign_ipv6_address_on_creation                = false\n        customer_owned_ipv4_pool                       = \"\"\n        enable_dns64                                   = false\n        enable_resource_name_dns_aaaa_record_on_launch = false\n        enable_resource_name_dns_a_record_on_launch    = false\n        ipv6_native                                    = false\n        map_customer_owned_ip_on_launch                = false\n        map_public_ip_on_launch                        = true\n        outpost_arn                                    = \"\"\n        private_dns_hostname_type_on_launch            = \"ip-name\"\n        nacl = {\n          default_ingress = {\n            egress      = false\n            rule_number = 100\n            rule_action = \"allow\"\n            from_port   = 0\n            to_port     = 0\n            protocol    = \"-1\"\n            cidr_block  = \"0.0.0.0/0\"\n          }\n          default_egress = {\n            egress      = true\n            rule_number = 100\n            rule_action = \"allow\"\n            from_port   = 0\n            to_port     = 0\n            protocol    = \"-1\"\n            cidr_block  = \"0.0.0.0/0\"\n          }\n        }\n      }\n      public2 = {\n        name                                           = \"public-2\"\n        cidr                                           = \"10.2.3.0/24\"\n        az                                             = \"us-west-1b\"\n        tags                                           = { \"Name\" = \"public-2\" }\n        type                                           = \"public\"\n        assign_ipv6_address_on_creation                = false\n        customer_owned_ipv4_pool                       = \"\"\n        enable_dns64                                   = false\n        enable_resource_name_dns_aaaa_record_on_launch = false\n        enable_resource_name_dns_a_record_on_launch    = false\n        ipv6_native                                    = false\n        map_customer_owned_ip_on_launch                = false\n        map_public_ip_on_launch                        = true\n        outpost_arn                                    = \"\"\n        private_dns_hostname_type_on_launch            = \"ip-name\"\n        nacl = {\n          default_ingress = {\n            egress      = false\n            rule_number = 100\n            rule_action = \"allow\"\n            from_port   = 0\n            to_port     = 0\n            protocol    = \"-1\"\n            cidr_block  = \"0.0.0.0/0\"\n          }\n          default_egress = {\n            egress      = true\n            rule_number = 100\n            rule_action = \"allow\"\n            from_port   = 0\n            to_port     = 0\n            protocol    = \"-1\"\n            cidr_block  = \"0.0.0.0/0\"\n          }\n        }\n      }\n    }\n    private = {\n      eks1 = {\n        name                                           = \"eks-control-plane-1\"\n        cidr                                           = \"10.2.0.0/24\"\n        az                                             = \"us-west-1a\"\n        tags                                           = {}\n        type                                           = \"private\"\n        assign_ipv6_address_on_creation                = false\n        customer_owned_ipv4_pool                       = \"\"\n        enable_dns64                                   = false\n        enable_resource_name_dns_aaaa_record_on_launch = false\n        enable_resource_name_dns_a_record_on_launch    = false\n        ipv6_native                                    = false\n        map_customer_owned_ip_on_launch                = false\n        map_public_ip_on_launch                        = false\n        outpost_arn                                    = \"\"\n        private_dns_hostname_type_on_launch            = \"ip-name\"\n        nacl = {\n          eks_default_ingress = {\n            egress      = false\n            rule_number = 100\n            rule_action = \"allow\"\n            from_port   = 0\n            to_port     = 0\n            protocol    = \"-1\"\n            cidr_block  = \"0.0.0.0/0\"\n          }\n          eks_default_egress = {\n            egress      = true\n            rule_number = 100\n            rule_action = \"allow\"\n            from_port   = 0\n            to_port     = 0\n            protocol    = \"-1\"\n            cidr_block  = \"0.0.0.0/0\"\n          }\n        }\n      }\n      eks2 = {\n        name                                           = \"elk-control-plane-2\"\n        cidr                                           = \"10.2.1.0/24\"\n        az                                             = \"us-west-1b\"\n        tags                                           = {}\n        type                                           = \"private\"\n        assign_ipv6_address_on_creation                = false\n        customer_owned_ipv4_pool                       = \"\"\n        enable_dns64                                   = false\n        enable_resource_name_dns_aaaa_record_on_launch = false\n        enable_resource_name_dns_a_record_on_launch    = false\n        ipv6_native                                    = false\n        map_customer_owned_ip_on_launch                = false\n        map_public_ip_on_launch                        = false\n        outpost_arn                                    = \"\"\n        private_dns_hostname_type_on_launch            = \"ip-name\"\n        nacl = {\n          eks_default_ingress = {\n            egress      = false\n            rule_number = 100\n            rule_action = \"allow\"\n            from_port   = 0\n            to_port     = 0\n            protocol    = \"-1\"\n            cidr_block  = \"0.0.0.0/0\"\n          }\n          eks_default_egress = {\n            egress      = true\n            rule_number = 100\n            rule_action = \"allow\"\n            from_port   = 0\n            to_port     = 0\n            protocol    = \"-1\"\n            cidr_block  = \"0.0.0.0/0\"\n          }\n        }\n      }\n    }\n  }\n\n  tags_default = {\n    \"Environment\" = \"Dev\"\n    \"Name\"        = \"EKS-VPC\"\n    \"Owner\"       = \"DevOps\"\n  }\n}\n",
        "examples/nat_gateway_az_existing_eip/output.tf": "output \"nat_gateway_az_raw\" {\n  value = module.vpc.nat_gateway_az_raw\n}\n",
        "examples/nat_gateway_single/main.tf": "provider \"aws\" {\n  region = \"eu-north-1\"\n}\n\n\nmodule \"vpc\" {\n  source = \"ViktorUJ/vpc/aws\"\n  tags_default = {\n    \"Owner\"       = \"DevOps Team\"\n    \"Terraform\"   = \"true\"\n    \"cost_center\" = \"1111\"\n  }\n  vpc = {\n    name = \"test-vpc\"\n    cidr = \"10.10.0.0/16\"\n  }\n\n  subnets = {\n    public = {\n      \"pub1\" = {\n        name        = \"public-subnet-1\"\n        cidr        = \"10.10.1.0/24\"\n        az          = \"eu-north-1a\"\n        nat_gateway = \"DEFAULT\"\n      }\n      \"pub2\" = {\n        name = \"public-subnet-2\"\n        cidr = \"10.10.2.0/24\"\n        az   = \"eu-north-1a\"\n      }\n\n    }\n    private = {\n\n      \"private1\" = {\n        name        = \"private-subnet-1\"\n        cidr        = \"10.10.11.0/24\"\n        az          = \"eu-north-1a\"\n        nat_gateway = \"SINGLE\"\n\n      }\n      \"private2\" = {\n        name        = \"private-subnet-2\"\n        cidr        = \"10.10.12.0/24\"\n        az          = \"eu-north-1a\"\n        nat_gateway = \"SINGLE\"\n      }\n      \"private3\" = {\n        name        = \"private-subnet-3\"\n        cidr        = \"10.10.13.0/24\"\n        az          = \"eu-north-1b\"\n        nat_gateway = \"SINGLE\"\n      }\n      \"private4\" = {\n        name        = \"private-subnet-4\"\n        cidr        = \"10.10.14.0/24\"\n        az          = \"eu-north-1b\"\n        nat_gateway = \"SINGLE\"\n      }\n\n\n    }\n  }\n}\n",
        "examples/nat_gateway_single/output.tf": "output \"nat_gateway_single_raw\" {\n  value = module.vpc.nat_gateway_single_raw\n}\n",
        "examples/nat_gateway_subnet/main.tf": "provider \"aws\" {\n  region = \"eu-north-1\"\n}\n\n\nmodule \"vpc\" {\n  source = \"ViktorUJ/vpc/aws\"\n  tags_default = {\n    \"Owner\"       = \"DevOps Team\"\n    \"Terraform\"   = \"true\"\n    \"cost_center\" = \"1111\"\n  }\n  vpc = {\n    name = \"test-vpc\"\n    cidr = \"10.10.0.0/16\"\n  }\n\n  subnets = {\n    public = {\n      \"pub1\" = {\n        name = \"public-subnet-1\"\n        cidr = \"10.10.1.0/24\"\n        az   = \"eu-north-1a\"\n      }\n      \"pub2\" = {\n        name = \"public-subnet-2\"\n        cidr = \"10.10.2.0/24\"\n        az   = \"eu-north-1b\"\n      }\n\n    }\n    private = {\n\n      \"private1\" = {\n        name        = \"private-subnet-1\"\n        cidr        = \"10.10.11.0/24\"\n        az          = \"eu-north-1a\"\n        nat_gateway = \"SUBNET\"\n\n      }\n      \"private2\" = {\n        name        = \"private-subnet-2\"\n        cidr        = \"10.10.12.0/24\"\n        az          = \"eu-north-1a\"\n        nat_gateway = \"SUBNET\"\n      }\n      \"private3\" = {\n        name        = \"private-subnet-3\"\n        cidr        = \"10.10.13.0/24\"\n        az          = \"eu-north-1b\"\n        nat_gateway = \"SUBNET\"\n      }\n      \"private4\" = {\n        name        = \"private-subnet-4\"\n        cidr        = \"10.10.14.0/24\"\n        az          = \"eu-north-1b\"\n        nat_gateway = \"NONE\" # this subnet will not have NAT Gateway\n      }\n\n\n    }\n  }\n}\n",
        "examples/nat_gateway_subnet/output.tf": "output \"nat_gateway_subnet_raw\" {\n  value = module.vpc.nat_gateway_subnet_raw\n}\n",
        "examples/output_private_subnet_by_type/main.tf": "provider \"aws\" {\n  region = \"eu-north-1\"\n}\n\n\nmodule \"vpc\" {\n  source = \"ViktorUJ/vpc/aws\"\n  tags_default = {\n    \"Owner\"       = \"DevOps Team\"\n    \"Terraform\"   = \"true\"\n    \"cost_center\" = \"1111\"\n  }\n  vpc = {\n    name = \"test-vpc\"\n    cidr = \"10.10.0.0/16\"\n  }\n\n  subnets = {\n    public = {\n      \"pub1\" = {\n        name = \"public-subnet-1\"\n        cidr = \"10.10.1.0/24\"\n        az   = \"eu-north-1a\"\n      }\n      \"pub2\" = {\n        name = \"public-subnet-2\"\n        cidr = \"10.10.2.0/24\"\n        az   = \"eu-north-1a\"\n      }\n\n    }\n    private = {\n\n      \"rds1\" = {\n        name = \"rds-subnet-1\"\n        cidr = \"10.10.11.0/24\"\n        az   = \"eu-north-1b\"\n        type = \"rds\"\n\n      }\n      \"rds2\" = {\n        name = \"rds-subnet-2\"\n        cidr = \"10.10.12.0/24\"\n        az   = \"eu-north-1a\"\n        type = \"rds\"\n      }\n      \"k8s1\" = {\n        name = \"rds-subnet-1\"\n        cidr = \"10.10.13.0/24\"\n        az   = \"eu-north-1a\"\n        type = \"k8s\"\n      }\n\n      \"k8s2\" = {\n        name = \"rds-subnet-2\"\n        cidr = \"10.10.14.0/24\"\n        az   = \"eu-north-1a\"\n        type = \"k8s\"\n      }\n      \"app1\" = {\n        name = \"app-subnet-1\"\n        cidr = \"10.10.16.0/24\"\n        az   = \"eu-north-1a\"\n        type = \"app\"\n      }\n      \"app2\" = {\n        name = \"app-subnet-2\"\n        cidr = \"10.10.15.0/24\"\n        az   = \"eu-north-1a\"\n        type = \"app\"\n      }\n\n\n    }\n  }\n}\n",
        "examples/output_private_subnet_by_type/output.tf": "output \"private_subnets_by_type\" {\n  value = module.vpc.private_subnets_by_type\n}\n\noutput \"k8s_subnets_id\" {\n  value = module.vpc.private_subnets_by_type.k8s.ids\n}\n\noutput \"rds_subnets_id\" {\n  value = module.vpc.private_subnets_by_type.rds.ids\n}\n\noutput \"app_subnets_id\" {\n  value = module.vpc.private_subnets_by_type.app.ids\n}\n",
        "examples/simple/main.tf": "provider \"aws\" {\n  region = \"eu-north-1\"\n}\n\n\nmodule \"vpc\" {\n  source = \"ViktorUJ/vpc/aws\"\n  tags_default = {\n    \"Owner\"       = \"DevOps Team\"\n    \"Terraform\"   = \"true\"\n    \"cost_center\" = \"1111\"\n  }\n  vpc = {\n    name = \"test-vpc\"\n    cidr = \"10.10.0.0/16\"\n  }\n\n  subnets = {\n    public = {\n      \"pub1\" = {\n        name = \"public-subnet-1\"\n        cidr = \"10.10.1.0/24\"\n        az   = \"eu-north-1a\"\n      }\n      \"pub2\" = {\n        name = \"public-subnet-2\"\n        cidr = \"10.10.2.0/24\"\n        az   = \"eu-north-1a\"\n      }\n\n    }\n    private = {\n\n      \"private1\" = {\n        name = \"private-subnet-1\"\n        cidr = \"10.10.11.0/24\"\n        az   = \"eu-north-1a\"\n\n      }\n      \"private2\" = {\n        name = \"private-subnet-2\"\n        cidr = \"10.10.12.0/24\"\n        az   = \"eu-north-1a\"\n      }\n    }\n  }\n}\n",
        "examples/simple/output.tf": "output \"vpc_id\" {\n  value = module.vpc.vpc_raw.id\n}\n\noutput \"vpc_cidr_block\" {\n  value = module.vpc.vpc_raw.cidr_block\n}\n\n\noutput \"private_subnets_by_type\" {\n  value = module.vpc.private_subnets_by_type\n}\noutput \"public_subnets_by_type\" {\n  value = module.vpc.public_subnets_by_type\n}\n",
        "locals.tf": "locals {\n  az_mapping = {\n    for idx, az in data.aws_availability_zones.available.names : az =>\n    data.aws_availability_zones.available.zone_ids[idx]\n  }\n\n  az_id_to_az = { for az, az_id in local.az_mapping : az_id => az }\n\n  normalized_public_subnets_all = {\n    for k, v in var.subnets.public : k => merge(v, {\n      az = lookup(local.az_id_to_az, v.az, v.az) # modify AZ ID to AZ\n    })\n  }\n\n  normalized_private_subnets_all = {\n    for k, v in var.subnets.private : k => merge(v, {\n      az = lookup(local.az_id_to_az, v.az, v.az) # modify AZ ID to AZ\n    })\n  }\n\n  # group by type and create a list of identifiers\n  private_subnets_by_type = {\n    for type in distinct([for k, v in local.normalized_private_subnets_all : v.type]) : type => {\n      ids  = [for k, v in local.normalized_private_subnets_all : aws_subnet.private[k].id if v.type == type]\n      keys = [for k, v in local.normalized_private_subnets_all : k if v.type == type]\n    }\n  }\n\n  public_subnets_by_type = {\n    for type in distinct([for k, v in var.subnets.public : v.type]) : type => {\n      ids  = [for k, v in local.normalized_public_subnets_all : aws_subnet.public[k].id if v.type == type]\n      keys = [for k, v in local.normalized_public_subnets_all : k if v.type == type]\n    }\n  }\n\n  private_subnets_by_az_output = {\n    for az in distinct([for subnet in local.normalized_private_subnets_all : subnet.az]) : az => [\n      for subnet_key, subnet in local.normalized_private_subnets_all : aws_subnet.private[subnet_key].id\n      if subnet.az == az\n    ]\n  }\n\n  public_subnets_by_az_output = {\n    for az in distinct([for subnet in local.normalized_public_subnets_all : subnet.az]) : az => [\n      for subnet_key, subnet in local.normalized_public_subnets_all : aws_subnet.public[subnet_key].id\n      if subnet.az == az\n    ]\n  }\n\n\n  private_subnets_by_az_id = {\n    for az_id in distinct([for subnet in local.normalized_private_subnets_all : lookup(local.az_mapping, subnet.az)]) : az_id => [\n      for subnet_key, subnet in local.normalized_private_subnets_all : aws_subnet.private[subnet_key].id\n      if lookup(local.az_mapping, subnet.az) == az_id\n    ]\n  }\n\n  public_subnets_by_az_id = {\n    for az_id in distinct([for subnet in local.normalized_public_subnets_all : lookup(local.az_mapping, subnet.az)]) : az_id => [\n      for subnet_key, subnet in local.normalized_public_subnets_all : aws_subnet.public[subnet_key].id\n      if lookup(local.az_mapping, subnet.az) == az_id\n    ]\n  }\n}\n",
        "main.tf": "",
        "outputs.tf": "# inputs\noutput \"tags_default\" {\n  description = \"Default tags\"\n  value       = var.tags_default\n}\n\noutput \"subnets_var\" {\n  description = \"for test\"\n  value       = var.subnets\n}\noutput \"vpc_var\" {\n  value = var.vpc\n}\n\n# vpc\noutput \"vpc_raw\" {\n  value = try(aws_vpc.default, null)\n}\n\n\n# debug\noutput \"az_mapping\" {\n  value = local.az_mapping\n}\n\n\n#subnets public\n\noutput \"normalized_public_subnets_all\" {\n  value = local.normalized_public_subnets_all\n}\n\noutput \"subnets_public_raw\" {\n  value = try(aws_subnet.public, null)\n}\noutput \"public_subnets_by_type\" {\n  value = local.public_subnets_by_type\n}\n\noutput \"public_subnets_by_az\" {\n  value = local.public_subnets_by_az_output\n}\n\noutput \"public_subnets_by_az_id\" {\n  value = local.public_subnets_by_az_id\n}\n#subnets private\noutput \"normalized_private_subnets_all\" {\n  value = local.normalized_private_subnets_all\n}\n\noutput \"subnets_private_raw\" {\n  value = try(aws_subnet.private, null)\n}\n\noutput \"private_subnets_by_type\" {\n  value = local.private_subnets_by_type\n}\n\noutput \"private_subnets_by_az\" {\n  value = local.private_subnets_by_az_output\n}\n\noutput \"private_subnets_by_az_id\" {\n  value = local.private_subnets_by_az_id\n}\n\n# NACL\noutput \"nacl_default_rules_raw\" {\n  value = aws_network_acl_rule.default\n}\noutput \"public_nacl_raw\" {\n  value = try(aws_network_acl.public, null)\n\n}\noutput \"public_nacl_rules_raw\" {\n  value = aws_network_acl_rule.public_rules\n}\n\n\noutput \"private_nacl_raw\" {\n  value = try(aws_network_acl.private, null)\n}\noutput \"private_nacl_rules_raw\" {\n  value = aws_network_acl_rule.private_rules\n}\n\n# NAT Gateway\n\noutput \"nat_gateway_single_raw\" {\n  value = try(aws_nat_gateway.SINGLE_nat_gateway, null)\n}\n\noutput \"nat_gateway_subnet_raw\" {\n  value = try(aws_nat_gateway.SUBNET_nat_gateway, null)\n}\n\noutput \"nat_gateway_az_raw\" {\n  value = try(aws_nat_gateway.az_nat_gateway, null)\n}\n\n# Route Table\noutput \"route_table_private_raw\" {\n  value = try(aws_route_table.private, null)\n}\n\noutput \"route_table_public_raw\" {\n  value = try(aws_route_table.public, null)\n}\n",
        "subnets_private.tf": "resource \"aws_subnet\" \"private\" {\n  vpc_id                  = aws_vpc.default.id\n  for_each                = local.normalized_private_subnets_all\n  map_public_ip_on_launch = \"false\"\n  cidr_block              = each.value.cidr\n\n  assign_ipv6_address_on_creation                = each.value.assign_ipv6_address_on_creation\n  customer_owned_ipv4_pool                       = each.value.customer_owned_ipv4_pool != \"\" ? each.value.customer_owned_ipv4_pool : null\n  enable_dns64                                   = each.value.enable_dns64\n  enable_resource_name_dns_aaaa_record_on_launch = each.value.enable_resource_name_dns_aaaa_record_on_launch\n  enable_resource_name_dns_a_record_on_launch    = each.value.enable_resource_name_dns_a_record_on_launch\n  ipv6_cidr_block                                = each.value.ipv6_cidr_block != \"\" ? each.value.ipv6_cidr_block : null\n  ipv6_native                                    = each.value.ipv6_native\n  map_customer_owned_ip_on_launch                = each.value.map_customer_owned_ip_on_launch ? each.value.map_customer_owned_ip_on_launch : null\n  outpost_arn                                    = each.value.outpost_arn != \"\" ? each.value.outpost_arn : null\n  private_dns_hostname_type_on_launch            = each.value.private_dns_hostname_type_on_launch != \"\" ? each.value.private_dns_hostname_type_on_launch : null\n\n\n\n  availability_zone = each.value.az\n\n  tags = merge(var.tags_default, { \"Name\" = each.value.name }, { \"type\" = each.value.type }, { \"subnet_key\" = each.key }, { \"access_type\" = \"private\" }, each.value.tags)\n}\n\n\n\n\nresource \"aws_route_table\" \"private\" {\n  for_each = local.normalized_private_subnets_all\n  vpc_id   = aws_vpc.default.id\n  tags     = merge(var.tags_default, { \"Name\" = each.value.name }, { \"type\" = each.value.type }, { \"subnet_key\" = each.key }, { \"access_type\" = \"private\" }, each.value.tags)\n}\n\nresource \"aws_route_table_association\" \"private\" {\n  for_each       = local.normalized_private_subnets_all\n  route_table_id = aws_route_table.private[\"${each.key}\"].id\n  subnet_id      = aws_subnet.private[\"${each.key}\"].id\n}\n\n# < Az NAT Gateway\nlocals {\n  normalized_private_subnets_AZ = {\n    for k, v in var.subnets.private : k => merge(v, {\n      az = lookup(local.az_id_to_az, v.az, v.az) # \u041f\u0440\u0435\u043e\u0431\u0440\u0430\u0437\u0443\u0435\u043c AZ ID \u0432 AZ, \u0435\u0441\u043b\u0438 \u044d\u0442\u043e \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e\n    })\n    if v.nat_gateway == \"AZ\" # \u0424\u0438\u043b\u044c\u0442\u0440\u0443\u0435\u043c \u0442\u043e\u043b\u044c\u043a\u043e \u0442\u0435 \u043f\u043e\u0434\u0441\u0435\u0442\u0438, \u0433\u0434\u0435 nat_gateway = \"AZ\"\n  }\n\n\n\n  private_subnets_by_az = {\n    for az in distinct([for s in local.normalized_private_subnets_AZ : s.az]) :\n    az => {\n      ids  = [for k, s in local.normalized_private_subnets_AZ : aws_subnet.private[k].id if s.az == az]\n      keys = [for k, s in local.normalized_private_subnets_AZ : k if s.az == az]\n    }\n  }\n}\n\nresource \"aws_nat_gateway\" \"az_nat_gateway\" {\n  for_each = local.private_subnets_by_az\n\n  allocation_id = length(keys(var.existing_eip_ids_az)) == 0 ? aws_eip.az_nat_gateway_eip[each.key].id : var.existing_eip_ids_az[each.key]\n  subnet_id     = local.public_subnets_by_az_output[each.key][0]\n  tags          = merge(var.tags_default, { \"Name\" = \"az_nat_gateway-${each.key}\" })\n}\n\nresource \"aws_eip\" \"az_nat_gateway_eip\" {\n  for_each = length(keys(var.existing_eip_ids_az)) == 0 ? {\n    for az, data in local.private_subnets_by_az : az => az\n  } : {}\n  domain = \"vpc\"\n  tags   = merge(var.tags_default, { \"Name\" = \"az_nat_gateway-${each.key}\" })\n}\n\nlocals {\n  flat_private_subnet_keys = flatten([\n    for az, data in local.private_subnets_by_az : [\n      for key in data.keys : {\n        key = key\n        az  = az\n        id  = \"${az}-${key}\"\n      }\n    ]\n  ])\n\n  routes_map_private_subnet_az = {\n    for entry in local.flat_private_subnet_keys : entry.id => {\n      key = entry.key\n      az  = entry.az\n    }\n  }\n}\n\nresource \"aws_route\" \"private_route_az\" {\n\n  for_each = local.routes_map_private_subnet_az\n\n  route_table_id         = aws_route_table.private[each.value.key].id\n  destination_cidr_block = \"0.0.0.0/0\"\n  nat_gateway_id         = aws_nat_gateway.az_nat_gateway[each.value.az].id\n}\n\n\n\n\n# Az NAT Gateway >\n\n\n\n# < SUBNET NAT Gateway\n\nlocals {\n  normalized_private_subnets_SUBNET = {\n    for k, v in var.subnets.private : k => merge(v, {\n      az = lookup(local.az_id_to_az, v.az, v.az) # \u041f\u0440\u0435\u043e\u0431\u0440\u0430\u0437\u0443\u0435\u043c AZ ID \u0432 AZ, \u0435\u0441\u043b\u0438 \u044d\u0442\u043e \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e\n    })\n    if v.nat_gateway == \"SUBNET\" # \u0424\u0438\u043b\u044c\u0442\u0440\u0443\u0435\u043c \u0442\u043e\u043b\u044c\u043a\u043e \u0442\u0435 \u043f\u043e\u0434\u0441\u0435\u0442\u0438, \u0433\u0434\u0435 nat_gateway = \"SUBNET\"\n  }\n\n\n}\n\n\nresource \"aws_eip\" \"SUBNET_nat_gateway_eip\" {\n  for_each = local.normalized_private_subnets_SUBNET\n  tags     = merge(var.tags_default, { \"Name\" = \"SUBNET_nat_gateway-${each.key}\" })\n  domain   = \"vpc\"\n}\n\nresource \"aws_nat_gateway\" \"SUBNET_nat_gateway\" {\n  for_each = local.normalized_private_subnets_SUBNET\n\n  allocation_id = aws_eip.SUBNET_nat_gateway_eip[each.key].id\n  subnet_id     = local.public_subnets_by_az_output[each.value.az][0]\n  tags          = merge(var.tags_default, { \"Name\" = \"SUBNET_nat_gateway-${each.key}\" })\n}\n\n\nresource \"aws_route\" \"private_route_SUBNET\" {\n\n  for_each               = local.normalized_private_subnets_SUBNET\n  route_table_id         = aws_route_table.private[each.key].id\n  destination_cidr_block = \"0.0.0.0/0\"\n  nat_gateway_id         = aws_nat_gateway.SUBNET_nat_gateway[each.key].id\n}\n\n\n# SUBNET NAT Gateway >\n\n\n# < SINGLE NAT Gateway\n\nlocals {\n  normalized_private_subnets_SINGLE = {\n    for k, v in var.subnets.private : k => merge(v, {\n      az = lookup(local.az_id_to_az, v.az, v.az) # \u041f\u0440\u0435\u043e\u0431\u0440\u0430\u0437\u0443\u0435\u043c AZ ID \u0432 AZ, \u0435\u0441\u043b\u0438 \u044d\u0442\u043e \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e\n    })\n    if v.nat_gateway == \"SINGLE\" # \u0424\u0438\u043b\u044c\u0442\u0440\u0443\u0435\u043c \u0442\u043e\u043b\u044c\u043a\u043e \u0442\u0435 \u043f\u043e\u0434\u0441\u0435\u0442\u0438, \u0433\u0434\u0435 nat_gateway = \"SUBNET\"\n  }\n\n  normalized_public_subnets_DEFAULT = {\n    for k, v in var.subnets.public : k => merge(v, {\n      az = lookup(local.az_id_to_az, v.az, v.az) # \u041f\u0440\u0435\u043e\u0431\u0440\u0430\u0437\u0443\u0435\u043c AZ ID \u0432 AZ, \u0435\u0441\u043b\u0438 \u044d\u0442\u043e \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e\n    })\n    if v.nat_gateway == \"DEFAULT\" # \u0424\u0438\u043b\u044c\u0442\u0440\u0443\u0435\u043c \u0442\u043e\u043b\u044c\u043a\u043e \u0442\u0435 \u043f\u043e\u0434\u0441\u0435\u0442\u0438, \u0433\u0434\u0435 nat_gateway = \"DEFAULT\"\n  }\n  normalized_public_subnets_DEFAULT_keys             = keys(local.normalized_public_subnets_DEFAULT)\n  normalized_public_subnets_DEFAULT_first_subnet_key = length(local.normalized_public_subnets_DEFAULT_keys) > 0 ? local.normalized_public_subnets_DEFAULT_keys[0] : null\n\n  normalized_public_subnets_DEFAULT_selected = {\n    for k, v in local.normalized_public_subnets_DEFAULT :\n    k => v if k == local.normalized_public_subnets_DEFAULT_first_subnet_key\n  }\n}\n\n\nresource \"aws_eip\" \"SINGLE_nat_gateway_eip\" {\n  for_each = local.normalized_public_subnets_DEFAULT_selected\n  tags     = merge(var.tags_default, { \"Name\" = \"SINGLE_nat_gateway-${each.key}\" })\n  domain   = \"vpc\"\n}\n\n\n\nresource \"aws_nat_gateway\" \"SINGLE_nat_gateway\" {\n  for_each = local.normalized_public_subnets_DEFAULT_selected\n\n  allocation_id = aws_eip.SINGLE_nat_gateway_eip[each.key].id\n  subnet_id     = aws_subnet.public[each.key].id\n  tags          = merge(var.tags_default, { \"Name\" = \"SINGLE_nat_gateway-${each.key}\" })\n}\n\n\nresource \"aws_route\" \"private_route_SINGLE\" {\n\n  for_each               = local.normalized_private_subnets_SINGLE\n  route_table_id         = aws_route_table.private[each.key].id\n  destination_cidr_block = \"0.0.0.0/0\"\n  nat_gateway_id         = aws_nat_gateway.SINGLE_nat_gateway[\"${local.normalized_public_subnets_DEFAULT_first_subnet_key}\"].id\n}\n\n#  SINGLE NAT Gateway  >\n\n\n# NACL\n\n# Local variable to flatten all NACL rules for private subnets\nlocals {\n  private_nacl_rules = flatten([\n    for subnet_key, subnet in var.subnets.private : [\n      for rule_key, rule in subnet.nacl : {\n        subnet_key = subnet_key\n        rule_key   = rule_key\n        rule       = rule\n      }\n    ]\n  ])\n}\n\n# Create a Network ACL for each private subnet if nacl is defined\nresource \"aws_network_acl\" \"private\" {\n  for_each = {\n    for subnet_key, subnet in var.subnets.private :\n    subnet_key => subnet\n    if length(subnet.nacl) > 0\n  }\n\n  vpc_id = aws_vpc.default.id\n\n  tags = merge(var.tags_default, {\n    \"Name\" = \"${each.value.name}-nacl\"\n  })\n}\n\n# Create Network ACL rules for each private subnet's NACL\nresource \"aws_network_acl_rule\" \"private_rules\" {\n  for_each = {\n    for rule in local.private_nacl_rules :\n    \"${rule.subnet_key}-${rule.rule_key}-${rule.rule.rule_number}\" => rule\n    if length(var.subnets.private[rule.subnet_key].nacl) > 0\n  }\n\n  network_acl_id  = aws_network_acl.private[each.value.subnet_key].id\n  rule_number     = each.value.rule.rule_number\n  egress          = each.value.rule.egress == \"true\" ? true : false\n  protocol        = each.value.rule.protocol\n  rule_action     = each.value.rule.rule_action\n  cidr_block      = each.value.rule.cidr_block != \"\" ? each.value.rule.cidr_block : null\n  from_port       = each.value.rule.from_port != \"\" ? tonumber(each.value.rule.from_port) : null\n  to_port         = each.value.rule.to_port != \"\" ? tonumber(each.value.rule.to_port) : null\n  icmp_code       = each.value.rule.icmp_code != \"\" ? tonumber(each.value.rule.icmp_code) : null\n  icmp_type       = each.value.rule.icmp_type != \"\" ? tonumber(each.value.rule.icmp_type) : null\n  ipv6_cidr_block = each.value.rule.ipv6_cidr_block != \"\" ? each.value.rule.ipv6_cidr_block : null\n}\n\n# Associate the NACL with each private subnet if NACL is defined\nresource \"aws_network_acl_association\" \"private_association\" {\n  for_each = {\n    for subnet_key, subnet in var.subnets.private :\n    subnet_key => subnet\n    if length(subnet.nacl) > 0\n  }\n\n  subnet_id      = aws_subnet.private[each.key].id\n  network_acl_id = aws_network_acl.private[each.key].id\n}\n",
        "subnets_pub.tf": "resource \"aws_subnet\" \"public\" {\n  vpc_id                  = aws_vpc.default.id\n  for_each                = local.normalized_public_subnets_all\n  map_public_ip_on_launch = each.value.map_public_ip_on_launch\n  cidr_block              = each.value.cidr\n\n  assign_ipv6_address_on_creation                = each.value.assign_ipv6_address_on_creation\n  customer_owned_ipv4_pool                       = each.value.customer_owned_ipv4_pool != \"\" ? each.value.customer_owned_ipv4_pool : null\n  enable_dns64                                   = each.value.enable_dns64\n  enable_resource_name_dns_aaaa_record_on_launch = each.value.enable_resource_name_dns_aaaa_record_on_launch\n  enable_resource_name_dns_a_record_on_launch    = each.value.enable_resource_name_dns_a_record_on_launch\n  ipv6_cidr_block                                = each.value.ipv6_cidr_block != \"\" ? each.value.ipv6_cidr_block : null\n  ipv6_native                                    = each.value.ipv6_native\n  map_customer_owned_ip_on_launch                = each.value.map_customer_owned_ip_on_launch ? each.value.map_customer_owned_ip_on_launch : null\n  outpost_arn                                    = each.value.outpost_arn != \"\" ? each.value.outpost_arn : null\n  private_dns_hostname_type_on_launch            = each.value.private_dns_hostname_type_on_launch != \"\" ? each.value.private_dns_hostname_type_on_launch : null\n\n\n  availability_zone_id = length(regexall(\"^[a-z]{2}-\", each.value.az)) == 0 ? each.value.az : null\n  availability_zone    = length(regexall(\"^[a-z]{2}-\", each.value.az)) > 0 ? each.value.az : null\n\n  tags = merge(var.tags_default, { \"Name\" = each.value.name }, { \"type\" = each.value.type }, { \"subnet_key\" = each.key }, { \"access_type\" = \"public\" }, each.value.tags)\n}\n\nresource \"aws_route_table\" \"public\" {\n  vpc_id = aws_vpc.default.id\n  tags   = merge(var.tags_default, { \"access_type\" = \"public\" })\n}\n\nresource \"aws_route\" \"public\" {\n  route_table_id         = aws_route_table.public.id\n  destination_cidr_block = \"0.0.0.0/0\"\n  gateway_id             = aws_internet_gateway.default.id\n\n  timeouts {\n    create = \"5m\"\n  }\n}\n\n\nresource \"aws_route_table_association\" \"pub\" {\n  for_each       = var.subnets.public\n  route_table_id = aws_route_table.public.id\n  subnet_id      = aws_subnet.public[\"${each.key}\"].id\n}\n\n\n\n# Local variable to flatten all NACL rules for public subnets\nlocals {\n  public_nacl_rules = flatten([\n    for subnet_key, subnet in local.normalized_public_subnets_all : [\n      for rule_key, rule in subnet.nacl : {\n        subnet_key = subnet_key\n        rule_key   = rule_key\n        rule       = rule\n      }\n      if length(subnet.nacl) > 0\n    ]\n  ])\n}\n\n# Create a Network ACL for each public subnet if nacl is defined and contains rules\nresource \"aws_network_acl\" \"public\" {\n  for_each = {\n    for subnet_key, subnet in local.normalized_public_subnets_all :\n    subnet_key => subnet\n    if length(subnet.nacl) > 0\n  }\n\n  vpc_id = aws_vpc.default.id\n\n  tags = merge(var.tags_default, {\n    \"Name\" = \"${each.value.name}-nacl\"\n  })\n}\n\n# Create Network ACL rules for each public subnet's NACL\nresource \"aws_network_acl_rule\" \"public_rules\" {\n  for_each = {\n    for rule in local.public_nacl_rules :\n    \"${rule.subnet_key}-${rule.rule_key}-${rule.rule.rule_number}\" => rule\n    if length(var.subnets.public[rule.subnet_key].nacl) > 0\n  }\n\n  network_acl_id  = aws_network_acl.public[each.value.subnet_key].id\n  rule_number     = each.value.rule.rule_number\n  egress          = each.value.rule.egress == \"true\" ? true : false\n  protocol        = each.value.rule.protocol\n  rule_action     = each.value.rule.rule_action\n  cidr_block      = each.value.rule.cidr_block != \"\" ? each.value.rule.cidr_block : null\n  from_port       = each.value.rule.from_port != \"\" ? tonumber(each.value.rule.from_port) : null\n  to_port         = each.value.rule.to_port != \"\" ? tonumber(each.value.rule.to_port) : null\n  icmp_code       = each.value.rule.icmp_code != \"\" ? tonumber(each.value.rule.icmp_code) : null\n  icmp_type       = each.value.rule.icmp_type != \"\" ? tonumber(each.value.rule.icmp_type) : null\n  ipv6_cidr_block = each.value.rule.ipv6_cidr_block != \"\" ? each.value.rule.ipv6_cidr_block : null\n}\n\n# Associate the NACL with each public subnet if NACL is defined and contains rules\nresource \"aws_network_acl_association\" \"public_association\" {\n  for_each = {\n    for subnet_key, subnet in local.normalized_public_subnets_all :\n    subnet_key => subnet\n    if length(subnet.nacl) > 0\n  }\n\n  subnet_id      = aws_subnet.public[each.key].id\n  network_acl_id = aws_network_acl.public[each.key].id\n}\n",
        "variables.tf": "variable \"vpc\" {\n  type = object({\n    name                  = string\n    cidr                  = string\n    secondary_cidr_blocks = optional(list(string), [])\n    tags                  = optional(map(string), {})\n    instance_tenancy      = optional(string, \"default\") # default, dedicated\n    enable_dns_support    = optional(bool, true)        # true, false\n    enable_dns_hostnames  = optional(bool, true)        # true, false\n    nacl_default = optional(map(object({\n      egress      = string # true, false\n      rule_number = string # ACL entries are processed in ascending order by rule number\n      rule_action = string # allow | deny\n      from_port   = optional(string, \"\")\n      to_port     = optional(string, \"\")\n      icmp_code   = optional(string, \"\")\n      # (Optional) ICMP protocol: The ICMP type. Required if specifying ICMP for the protocolE.g., -1\n      icmp_type = optional(string, \"\")\n      # (Optional) ICMP protocol: The ICMP code. Required if specifying ICMP for the protocolE.g., -1\n      protocol   = string # A value of -1 means all protocols , tcp  - 6 ,\n      cidr_block = optional(string, \"\")\n      # The network range to allow or deny, in CIDR notation (for example 172.16.0.0/24 ).\n      ipv6_cidr_block = optional(string, \"\")\n\n    })), {})\n    dhcp_options = optional(object({\n      domain_name                       = optional(string, \"\")\n      domain_name_servers               = optional(list(string), [])\n      ntp_servers                       = optional(list(string), [])\n      netbios_name_servers              = optional(list(string), [])\n      netbios_node_type                 = optional(string, \"\")    # 1, 2, 4, 8  . default 2 . http://www.ietf.org/rfc/rfc2132.txt\n      ipv6_address_preferred_lease_time = optional(string, \"140\") # 140 .. 2147483647 seconds . default 140\n      tags                              = optional(map(string), {})\n    }), {})\n  })\n\n  # Validation for CIDR format\n  validation {\n    condition     = can(cidrsubnet(var.vpc.cidr, 0, 0))\n    error_message = \"Invalid CIDR block format for VPC. CIDR block must be a valid subnet, e.g., 10.0.0.0/16.\"\n  }\n\n  # Validation for netbios_node_type field\n  validation {\n    condition = var.vpc.dhcp_options.netbios_node_type == \"\" || contains([\n      \"1\", \"2\", \"4\", \"8\"\n    ], var.vpc.dhcp_options.netbios_node_type)\n    error_message = \"Invalid value for netbios_node_type. Must be one of: 1, 2, 4, 8.\"\n  }\n\n  # Validation for ipv6_address_preferred_lease_time\n  validation {\n    condition = (\n      var.vpc.dhcp_options.ipv6_address_preferred_lease_time == \"\" ||\n      (\n        length(var.vpc.dhcp_options.ipv6_address_preferred_lease_time) > 0 &&\n        can(tonumber(var.vpc.dhcp_options.ipv6_address_preferred_lease_time)) &&\n        tonumber(var.vpc.dhcp_options.ipv6_address_preferred_lease_time) >= 140 &&\n        tonumber(var.vpc.dhcp_options.ipv6_address_preferred_lease_time) <= 2147483647\n      )\n    )\n    error_message = \"Invalid value for ipv6_address_preferred_lease_time. Must be a number between 140 and 2147483647 seconds.\"\n  }\n}\n\nvariable \"tags_default\" {\n  type    = map(string)\n  default = {}\n}\n\n\nvariable \"subnets\" {\n  type = object({\n    public = optional(map(object({\n      name = string\n      cidr = string\n      az   = string # Availability Zone or Availability Zone ID\n      tags = optional(map(string), {})\n      type = optional(string, \"public\") # any sort key for grouping . example , DB , WEB , APP , etc\n\n      assign_ipv6_address_on_creation                = optional(bool, false)\n      customer_owned_ipv4_pool                       = optional(string, \"\")\n      enable_dns64                                   = optional(bool, false)\n      enable_resource_name_dns_aaaa_record_on_launch = optional(bool, false)\n      enable_resource_name_dns_a_record_on_launch    = optional(bool, true)\n      ipv6_cidr_block                                = optional(string, \"\")\n      ipv6_native                                    = optional(bool, false)\n      map_customer_owned_ip_on_launch                = optional(bool, false)\n      map_public_ip_on_launch                        = optional(bool, true)\n      outpost_arn                                    = optional(string, \"\")\n      private_dns_hostname_type_on_launch            = optional(string, \"ip-name\") #  The type of hostnames to assign to instances in the subnet at launch. For IPv6-only subnets, an instance DNS name must be based on the instance ID. For dual-stack and IPv4-only subnets, you can specify whether DNS names use the instance IPv4 address or the instance ID . Valid values:  ip-name, resource-name.\n      nat_gateway                                    = optional(string, \"\")        #  DEFAULT - default nat gateway for all AZ  with SINGLE value\n      nacl = optional(map(object({\n        egress          = string # true, false\n        rule_number     = string # ACL entries are processed in ascending order by rule number\n        rule_action     = string # allow | deny\n        from_port       = optional(string, \"\")\n        to_port         = optional(string, \"\")\n        icmp_code       = optional(string, \"\") # (Optional) ICMP protocol: The ICMP type. Required if specifying ICMP for the protocolE.g., -1\n        icmp_type       = optional(string, \"\") # (Optional) ICMP protocol: The ICMP code. Required if specifying ICMP for the protocolE.g., -1\n        protocol        = string               # A value of -1 means all protocols , tcp  - 6 ,\n        cidr_block      = optional(string, \"\") # The network range to allow or deny, in CIDR notation (for example 172.16.0.0/24 ).\n        ipv6_cidr_block = optional(string, \"\")\n\n      })), {})\n\n    })))\n    private = optional(map(object({\n      name                                           = string\n      cidr                                           = string\n      az                                             = string # Availability Zone or Availability Zone ID\n      tags                                           = optional(map(string), {})\n      type                                           = optional(string, \"private\") # any sort key for grouping . example , DB , WEB , APP , etc\n      nat_gateway                                    = optional(string, \"AZ\")      # AZ - nat gateway for  each AZ , SINGLE - single nat gateway for all AZ (for this option you need to set nat_gateway=DEFAULT in one of the public networks)  ,SUBNET - dedicate nat gateway for each  subnet with SUBNET  type   ,  NONE - no nat gateway\n      assign_ipv6_address_on_creation                = optional(bool, false)\n      customer_owned_ipv4_pool                       = optional(string, \"\")\n      enable_dns64                                   = optional(bool, false)\n      enable_resource_name_dns_aaaa_record_on_launch = optional(bool, false)\n      enable_resource_name_dns_a_record_on_launch    = optional(bool, false)\n      ipv6_cidr_block                                = optional(string, \"\")\n      ipv6_native                                    = optional(bool, false)\n      map_customer_owned_ip_on_launch                = optional(bool, false)\n      map_public_ip_on_launch                        = optional(bool, true)\n      outpost_arn                                    = optional(string, \"\")\n      private_dns_hostname_type_on_launch            = optional(string, \"ip-name\") #  The type of hostnames to assign to instances in the subnet at launch. For IPv6-only subnets, an instance DNS name must be based on the instance ID. For dual-stack and IPv4-only subnets, you can specify whether DNS names use the instance IPv4 address or the instance ID . Valid values:  ip-name, resource-name.\n      nacl = optional(map(object({\n        egress          = string # true, false\n        rule_number     = string # ACL entries are processed in ascending order by rule number\n        rule_action     = string # allow | deny\n        from_port       = optional(string, \"\")\n        to_port         = optional(string, \"\")\n        icmp_code       = optional(string, \"\") # (Optional) ICMP protocol: The ICMP type. Required if specifying ICMP for the protocolE.g., -1\n        icmp_type       = optional(string, \"\") # (Optional) ICMP protocol: The ICMP code. Required if specifying ICMP for the protocolE.g., -1\n        protocol        = string               # A value of -1 means all protocols , tcp  - 6 ,\n        cidr_block      = optional(string, \"\") # The network range to allow or deny, in CIDR notation (for example 172.16.0.0/24 ).\n        ipv6_cidr_block = optional(string, \"\")\n\n      })), {})\n\n    })))\n  })\n  default = {\n    public  = {}\n    private = {}\n  }\n\n  validation {\n    condition = alltrue([\n      for _, subnet in coalesce(var.subnets.private, {}) : contains([\"AZ\", \"SINGLE\", \"DEFAULT\", \"SUBNET\", \"NONE\"], subnet.nat_gateway)\n    ])\n    error_message = \"nat_gateway must be one of: AZ, SINGLE, DEFAULT, SUBNET, NONE.\"\n  }\n\n  validation {\n    condition = alltrue([\n      for _, subnet in coalesce(var.subnets.private, {}) : can(cidrsubnet(subnet.cidr, 0, 0))\n    ])\n    error_message = \"Invalid CIDR block format. CIDR block must be a valid subnet, e.g., 10.10.16.0/24.\"\n  }\n\n  validation {\n    condition = alltrue([\n      for _, subnet in coalesce(var.subnets.private, {}) : contains([\"ip-name\", \"resource-name\"], subnet.private_dns_hostname_type_on_launch)\n    ])\n    error_message = \"Invalid value for private_dns_hostname_type_on_launch. Must be one of: ip-name, resource-name.\"\n  }\n\n  validation {\n    condition = alltrue([\n      for _, subnet in coalesce(var.subnets.public, {}) : can(cidrsubnet(subnet.cidr, 0, 0))\n    ])\n    error_message = \"Invalid CIDR block format. CIDR block must be a valid subnet, e.g., 10.10.16.0/24.\"\n  }\n\n  validation {\n    condition = alltrue([\n      for _, subnet in coalesce(var.subnets.public, {}) : contains([\"ip-name\", \"resource-name\"], subnet.private_dns_hostname_type_on_launch)\n    ])\n    error_message = \"Invalid value for private_dns_hostname_type_on_launch. Must be one of: ip-name, resource-name.\"\n  }\n}\n\nvariable \"existing_eip_ids_az\" {\n  description = \"A map of existing Elastic IPs IDs to associate with the NAT Gateways where key is the AZ, value is the EIP ID\"\n  type        = map(string)\n  default     = {}\n\n  validation {\n    condition = alltrue([\n      for az, eip in var.existing_eip_ids_az : can(regex(\"^eipalloc-[0-9a-fA-F]{17}$\", eip))\n    ])\n    error_message = \"Each value in existing_eip_ids_az must be a valid Elastic IP ID (eipalloc-xxxxxxxxxxxxxxxxx).\"\n  }\n\n  validation {\n    condition = alltrue([\n      for az, eip in var.existing_eip_ids_az : can(regex(\"^[a-z]{2}-[a-z]+-[0-9]{1}[a-z]$\", az))\n    ])\n    error_message = \"Each key in existing_eip_ids_az must be a valid Availability Zone (e.g., eu-west-1a).\"\n  }\n}\n",
        "versions.tf": "terraform {\n  required_version = \">= 1.0\"\n\n  required_providers {\n    aws = {\n      source  = \"hashicorp/aws\"\n      version = \">= 5.46\"\n    }\n  }\n}\n",
        "vpc.tf": "resource \"aws_vpc\" \"default\" {\n  cidr_block           = var.vpc.cidr\n  enable_dns_support   = var.vpc.enable_dns_support\n  enable_dns_hostnames = var.vpc.enable_dns_hostnames\n  tags                 = merge(var.tags_default, { \"Name\" = var.vpc.name }, var.vpc.tags)\n}\n\nresource \"aws_internet_gateway\" \"default\" {\n  vpc_id = aws_vpc.default.id\n  tags   = merge(var.tags_default, { \"Name\" = var.vpc.name }, var.vpc.tags)\n}\n\nresource \"aws_vpc_ipv4_cidr_block_association\" \"default\" {\n  for_each   = toset(var.vpc.secondary_cidr_blocks)\n  vpc_id     = aws_vpc.default.id\n  cidr_block = each.value\n}\n\nresource \"aws_network_acl_rule\" \"default\" {\n  for_each        = var.vpc.nacl_default\n  network_acl_id  = aws_vpc.default.default_network_acl_id\n  rule_number     = each.value.rule_number\n  egress          = each.value.egress\n  protocol        = each.value.protocol\n  rule_action     = each.value.rule_action\n  cidr_block      = each.value.cidr_block != \"\" ? each.value.cidr_block : null\n  from_port       = each.value.from_port != \"\" ? each.value.from_port : null\n  to_port         = each.value.to_port != \"\" ? each.value.to_port : null\n  ipv6_cidr_block = each.value.ipv6_cidr_block != \"\" ? each.value.ipv6_cidr_block : null\n}\n\n\nlocals {\n  # Check if any DHCP option is defined (for strings and lists)\n  dhcp_options_defined = (\n    var.vpc.dhcp_options.domain_name != \"\" ||\n    length(var.vpc.dhcp_options.domain_name_servers) > 0 ||\n    length(var.vpc.dhcp_options.ntp_servers) > 0 ||\n    length(var.vpc.dhcp_options.netbios_name_servers) > 0 ||\n    var.vpc.dhcp_options.netbios_node_type != \"\" ||\n    var.vpc.dhcp_options.ipv6_address_preferred_lease_time != \"140\"\n  )\n}\n\nresource \"aws_vpc_dhcp_options\" \"default\" {\n  for_each                          = local.dhcp_options_defined ? toset([\"enable\"]) : toset([])\n  domain_name                       = var.vpc.dhcp_options.domain_name != \"\" ? var.vpc.dhcp_options.domain_name : null\n  domain_name_servers               = length(var.vpc.dhcp_options.domain_name_servers) > 0 ? var.vpc.dhcp_options.domain_name_servers : null\n  ntp_servers                       = length(var.vpc.dhcp_options.ntp_servers) > 0 ? var.vpc.dhcp_options.ntp_servers : null\n  netbios_name_servers              = length(var.vpc.dhcp_options.netbios_name_servers) > 0 ? var.vpc.dhcp_options.netbios_name_servers : null\n  netbios_node_type                 = var.vpc.dhcp_options.netbios_node_type != \"\" ? var.vpc.dhcp_options.netbios_node_type : null\n  ipv6_address_preferred_lease_time = var.vpc.dhcp_options.ipv6_address_preferred_lease_time != \"140\" ? var.vpc.dhcp_options.ipv6_address_preferred_lease_time : null\n  tags                              = merge(var.tags_default, { \"Name\" = var.vpc.name }, var.vpc.tags)\n}\n\nresource \"aws_vpc_dhcp_options_association\" \"default\" {\n  for_each        = local.dhcp_options_defined ? toset([\"enable\"]) : toset([])\n  vpc_id          = aws_vpc.default.id\n  dhcp_options_id = aws_vpc_dhcp_options.default[each.key].id\n}\n"
      },
      "has_app": true
    },
    "ad03f95fc72b1791": {
      "hash": "ad03f95fc72b1791",
      "source_url": "https://github.com/aws-samples/serverless-patterns/tree/main/apigw-lambda-dynamodb-terraform",
      "source_type": "github_repos",
      "discovered_at": "2026-01-11T08:20:41.719236",
      "services": [
        "dynamodb",
        "cloudwatch",
        "lambda",
        "apigateway",
        "iam",
        "s3"
      ],
      "resource_count": 15,
      "name": "aws-samples/serverless-patterns/apigw-lambda-dynamodb-terraform",
      "description": "Serverless patterns. Learn more at the website: https://serverlessland.com/patterns.",
      "version": "main",
      "skipped": false,
      "skip_reason": null,
      "original_format": null,
      "terraform_files": {
        "main.tf": "terraform {\n  required_providers {\n    aws = {\n      source  = \"hashicorp/aws\"\n      version = \"~> 5.0\"\n    }\n    random = {\n      source  = \"hashicorp/random\"\n      version = \"~> 3.1.0\"\n    }\n    archive = {\n      source  = \"hashicorp/archive\"\n      version = \"~> 2.2.0\"\n    }\n  }\n\n  required_version = \">= 0.14.9\"\n}\n\nprovider \"aws\" {\n  profile = \"default\"\n  region = var.aws_region\n}\n\nresource \"random_string\" \"random\" {\n  length           = 4\n  special          = false\n}\n\nresource \"aws_dynamodb_table\" \"movie_table\" {\n  name           = var.dynamodb_table\n  billing_mode   = \"PROVISIONED\"\n  read_capacity  = 20\n  write_capacity = 20\n  hash_key       = \"year\"\n  range_key      = \"title\"\n\n  attribute {\n    name = \"year\"\n    type = \"N\"\n  }\n  \n  attribute {\n    name = \"title\"\n    type = \"S\"\n  }\n\n}\n\n#========================================================================\n// lambda setup\n#========================================================================\n\nresource \"aws_s3_bucket\" \"lambda_bucket\" {\n  bucket_prefix = var.s3_bucket_prefix\n  force_destroy = true\n}\n\nresource \"aws_s3_bucket_public_access_block\" \"private_bucket\" {\n  bucket = aws_s3_bucket.lambda_bucket.id\n\n  block_public_acls       = true\n  block_public_policy     = true\n  ignore_public_acls      = true\n  restrict_public_buckets = true\n}\n\ndata \"archive_file\" \"lambda_zip\" {\n  type = \"zip\"\n\n  source_dir  = \"${path.module}/src\"\n  output_path = \"${path.module}/src.zip\"\n}\n\nresource \"aws_s3_object\" \"this\" {\n  bucket = aws_s3_bucket.lambda_bucket.id\n\n  key    = \"src.zip\"\n  source = data.archive_file.lambda_zip.output_path\n\n  etag = filemd5(data.archive_file.lambda_zip.output_path)\n}\n\n//Define lambda function\nresource \"aws_lambda_function\" \"apigw_lambda_ddb\" {\n  function_name = \"${var.lambda_name}-${random_string.random.id}\"\n  description = \"serverlessland pattern\"\n\n  s3_bucket = aws_s3_bucket.lambda_bucket.id\n  s3_key    = aws_s3_object.this.key\n\n  runtime = \"python3.14\"\n  handler = \"app.lambda_handler\"\n\n  source_code_hash = data.archive_file.lambda_zip.output_base64sha256\n\n  role = aws_iam_role.lambda_exec.arn\n  \n  environment {\n    variables = {\n      DDB_TABLE = var.dynamodb_table\n    }\n  }\n  depends_on = [aws_cloudwatch_log_group.lambda_logs]\n  \n}\n\nresource \"aws_cloudwatch_log_group\" \"lambda_logs\" {\n  name = \"/aws/lambda/${var.lambda_name}-${random_string.random.id}\"\n\n  retention_in_days = var.lambda_log_retention\n}\n\nresource \"aws_iam_role\" \"lambda_exec\" {\n  name = \"LambdaDdbPost\"\n\n  assume_role_policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [{\n      Action = \"sts:AssumeRole\"\n      Effect = \"Allow\"\n      Sid    = \"\"\n      Principal = {\n        Service = \"lambda.amazonaws.com\"\n      }\n      }\n    ]\n  })\n}\n\nresource \"aws_iam_policy\" \"lambda_exec_role\" {\n  name = \"lambda-tf-pattern-ddb-post\"\n\n  policy = <<POLICY\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"dynamodb:GetItem\",\n                \"dynamodb:PutItem\",\n                \"dynamodb:UpdateItem\"\n            ],\n            \"Resource\": \"arn:aws:dynamodb:*:*:table/${var.dynamodb_table}\"\n        },\n        {\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"logs:CreateLogGroup\",\n                \"logs:CreateLogStream\",\n                \"logs:PutLogEvents\"\n            ],\n            \"Resource\": \"*\"\n        }\n    ]\n}\nPOLICY\n}\n\nresource \"aws_iam_role_policy_attachment\" \"lambda_policy\" {\n  role       = aws_iam_role.lambda_exec.name\n  policy_arn = aws_iam_policy.lambda_exec_role.arn\n}\n\n#========================================================================\n// API Gateway section\n#========================================================================\n\nresource \"aws_apigatewayv2_api\" \"http_lambda\" {\n  name          = \"${var.apigw_name}-${random_string.random.id}\"\n  protocol_type = \"HTTP\"\n}\n\nresource \"aws_apigatewayv2_stage\" \"default\" {\n  api_id = aws_apigatewayv2_api.http_lambda.id\n\n  name        = \"$default\"\n  auto_deploy = true\n\n  access_log_settings {\n    destination_arn = aws_cloudwatch_log_group.api_gw.arn\n\n    format = jsonencode({\n      requestId               = \"$context.requestId\"\n      sourceIp                = \"$context.identity.sourceIp\"\n      requestTime             = \"$context.requestTime\"\n      protocol                = \"$context.protocol\"\n      httpMethod              = \"$context.httpMethod\"\n      resourcePath            = \"$context.resourcePath\"\n      routeKey                = \"$context.routeKey\"\n      status                  = \"$context.status\"\n      responseLength          = \"$context.responseLength\"\n      integrationErrorMessage = \"$context.integrationErrorMessage\"\n      }\n    )\n  }\n  depends_on = [aws_cloudwatch_log_group.api_gw]\n}\n\nresource \"aws_apigatewayv2_integration\" \"apigw_lambda\" {\n  api_id = aws_apigatewayv2_api.http_lambda.id\n\n  integration_uri    = aws_lambda_function.apigw_lambda_ddb.invoke_arn\n  integration_type   = \"AWS_PROXY\"\n  integration_method = \"POST\"\n}\n\nresource \"aws_apigatewayv2_route\" \"post\" {\n  api_id = aws_apigatewayv2_api.http_lambda.id\n\n  route_key = \"POST /movies\"\n  target    = \"integrations/${aws_apigatewayv2_integration.apigw_lambda.id}\"\n}\n\nresource \"aws_cloudwatch_log_group\" \"api_gw\" {\n  name = \"/aws/api_gw/${var.apigw_name}-${random_string.random.id}\"\n\n  retention_in_days = var.apigw_log_retention\n}\n\nresource \"aws_lambda_permission\" \"api_gw\" {\n  statement_id  = \"AllowExecutionFromAPIGateway\"\n  action        = \"lambda:InvokeFunction\"\n  function_name = aws_lambda_function.apigw_lambda_ddb.function_name\n  principal     = \"apigateway.amazonaws.com\"\n\n  source_arn = \"${aws_apigatewayv2_api.http_lambda.execution_arn}/*/*\"\n}\n",
        "outputs.tf": "# Output value definitions\n\noutput \"apigwy_url\" {\n  description = \"URL for API Gateway stage\"\n\n  value = aws_apigatewayv2_stage.default.invoke_url\n}\n\noutput \"lambda_log_group\" {\n  description = \"Name of the CloudWatch logs group for the lambda function\"\n\n  value = aws_cloudwatch_log_group.lambda_logs.id\n}\n\noutput \"apigwy_log_group\" {\n  description = \"Name of the CloudWatch logs group for the lambda function\"\n\n  value = aws_cloudwatch_log_group.api_gw.id\n}",
        "variables.tf": "# Input variable definitions\n\nvariable \"aws_region\" {\n  description = \"AWS region for all resources.\"\n\n  type    = string\n  default = \"us-east-1\"\n}\n\nvariable \"s3_bucket_prefix\" {\n  description = \"S3 bucket prefix\"\n  type = string\n  default = \"apigw-lambda-ddb\"\n  \n}\n\nvariable \"dynamodb_table\" {\n  description = \"name of the ddb table\"\n  type = string\n  default = \"Movies\"\n  \n}\n\nvariable \"lambda_name\" {\n  description = \"name of the lambda function\"\n  type = string\n  default = \"pattern-movies-post\"\n  \n}\n\nvariable \"apigw_name\" {\n  description = \"name of the lambda function\"\n  type = string\n  default = \"apigw-http-lambda\"\n  \n}\n\nvariable \"lambda_log_retention\" {\n  description = \"lambda log retention in days\"\n  type = number\n  default = 7\n}\n\nvariable \"apigw_log_retention\" {\n  description = \"api gwy log retention in days\"\n  type = number\n  default = 7\n}"
      },
      "has_app": true
    },
    "ced9dfcb174c6a53": {
      "hash": "ced9dfcb174c6a53",
      "source_url": "https://github.com/aws-samples/serverless-patterns/tree/main/s3-lambda-terraform",
      "source_type": "github_repos",
      "discovered_at": "2026-01-11T08:20:42.768302",
      "services": [
        "iam",
        "lambda",
        "s3"
      ],
      "resource_count": 5,
      "name": "aws-samples/serverless-patterns/s3-lambda-terraform",
      "description": "Serverless patterns. Learn more at the website: https://serverlessland.com/patterns.",
      "version": "main",
      "skipped": false,
      "skip_reason": null,
      "original_format": null,
      "terraform_files": {
        "main.tf": "terraform {\n  required_providers {\n    aws = {\n      source  = \"hashicorp/aws\"\n      version = \"~> 3.27\"\n    }\n    random = {\n      source  = \"hashicorp/random\"\n      version = \"3.1.0\"\n    }\n  }\n\n  required_version = \">= 0.14.9\"\n}\n\nprovider \"aws\" {\n  profile = \"default\"\n  region  = \"us-east-1\"\n}\n\nresource \"random_string\" \"random\" {\n  length  = 8\n  special = false\n  lower   = true\n  number  = true\n  upper   = false\n}\n\nresource \"aws_lambda_function\" \"lambda_s3_handler\" {\n  function_name    = \"process-s3-new-objects\"\n  filename         = data.archive_file.lambda_zip_file.output_path\n  source_code_hash = data.archive_file.lambda_zip_file.output_base64sha256\n  handler          = \"index.handler\"\n  role             = aws_iam_role.iam_for_lambda.arn\n  runtime          = \"nodejs16.x\"\n}\n\ndata \"archive_file\" \"lambda_zip_file\" {\n  type        = \"zip\"\n  source_file = \"${path.module}/src/index.js\"\n  output_path = \"${path.module}/lambda.zip\"\n}\n\nresource \"aws_iam_role\" \"iam_for_lambda\" {\n  name = \"iam_for_lambda\"\n\n  assume_role_policy = <<EOF\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Action\": \"sts:AssumeRole\",\n      \"Principal\": {\n        \"Service\": \"lambda.amazonaws.com\"\n      },\n      \"Effect\": \"Allow\",\n      \"Sid\": \"\"\n    }\n  ]\n}\nEOF\n  inline_policy {\n    name   = \"lambda_logs_policy\"\n    policy = <<EOF\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n        \"Sid\": \"AllowLambdaFunctionToCreateLogs\",\n        \"Action\": [ \n            \"logs:*\" \n        ],\n        \"Effect\": \"Allow\",\n        \"Resource\": [ \n            \"arn:aws:logs:*:*:*\" \n        ]\n    }\n  ]\n}\nEOF\n  }\n}\n\nresource \"aws_lambda_permission\" \"allow_bucket_invoke_lambda\" {\n  statement_id  = \"AllowExecutionFromS3Bucket\"\n  action        = \"lambda:InvokeFunction\"\n  function_name = aws_lambda_function.lambda_s3_handler.arn\n  principal     = \"s3.amazonaws.com\"\n  source_arn    = aws_s3_bucket.my_bucket.arn\n}\n\nresource \"aws_s3_bucket\" \"my_bucket\" {\n  bucket = \"my-bucket-${random_string.random.result}\"\n}\n\nresource \"aws_s3_bucket_notification\" \"bucket_notification\" {\n  bucket = aws_s3_bucket.my_bucket.id\n\n  lambda_function {\n    lambda_function_arn = aws_lambda_function.lambda_s3_handler.arn\n    events              = [\"s3:ObjectCreated:*\"]\n  }\n\n  depends_on = [aws_lambda_permission.allow_bucket_invoke_lambda]\n}\n\noutput \"name_of_bucket\" {\n  value       = aws_s3_bucket.my_bucket.bucket\n  description = \"The name of the bucket\"\n}\n"
      },
      "has_app": true
    },
    "d02637494b9688ec": {
      "hash": "d02637494b9688ec",
      "source_url": "https://github.com/aws-samples/serverless-patterns/tree/main/eventbridge-lambda-terraform",
      "source_type": "github_repos",
      "discovered_at": "2026-01-11T08:20:43.824327",
      "services": [
        "iam",
        "lambda",
        "cloudwatch"
      ],
      "resource_count": 6,
      "name": "aws-samples/serverless-patterns/eventbridge-lambda-terraform",
      "description": "Serverless patterns. Learn more at the website: https://serverlessland.com/patterns.",
      "version": "main",
      "skipped": false,
      "skip_reason": null,
      "original_format": null,
      "terraform_files": {
        "main.tf": "terraform {\n  required_providers {\n\taws = {\n\t  source  = \"hashicorp/aws\"\n\t  version = \"~> 5.0\"\n\t}\n  }\n\n  required_version = \">= 0.14.9\"\n}\n\nprovider \"aws\" {\n  profile = \"default\"\n  region  = \"us-east-1\"\n}\n\nresource \"aws_lambda_function\" \"lambda_function\" {\n  function_name    = \"ConsumerFunction\"\n  filename         = data.archive_file.lambda_zip_file.output_path\n  source_code_hash = data.archive_file.lambda_zip_file.output_base64sha256\n  handler          = \"app.handler\"\n  role             = aws_iam_role.lambda_iam_role.arn\n  runtime          = \"nodejs24.x\"\n}\n\ndata \"archive_file\" \"lambda_zip_file\" {\n  type        = \"zip\"\n  source_file = \"${path.module}/src/app.js\"\n  output_path = \"${path.module}/lambda.zip\"\n}\n\ndata \"aws_iam_policy\" \"lambda_basic_execution_role_policy\" {\n  name = \"AWSLambdaBasicExecutionRole\"\n}\n\nresource \"aws_iam_role\" \"lambda_iam_role\" {\n  name_prefix         = \"EventBridgeLambdaRole-\"\n\n  assume_role_policy = <<EOF\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n\t{\n\t  \"Action\": \"sts:AssumeRole\",\n\t  \"Principal\": {\n\t\t\"Service\": \"lambda.amazonaws.com\"\n\t  },\n\t  \"Effect\": \"Allow\",\n\t  \"Sid\": \"\"\n\t}\n  ]\n}\nEOF\n}\n\nresource \"aws_iam_role_policy_attachment\" \"lambda_basic_execution\" {\n  role       = aws_iam_role.lambda_iam_role.name\n  policy_arn = data.aws_iam_policy.lambda_basic_execution_role_policy.arn\n}\n\nresource \"aws_cloudwatch_event_rule\" \"event_rule\" {\n\tname_prefix = \"eventbridge-lambda-\"\n  event_pattern = <<EOF\n{\n  \"detail-type\": [\"transaction\"],\n  \"source\": [\"custom.myApp\"],\n  \"detail\": {\n\t\"location\": [{\n\t  \"prefix\": \"EUR-\"\n\t}]\n  }\n}\nEOF\n}\n\nresource \"aws_cloudwatch_event_target\" \"target_lambda_function\" {\n  rule = aws_cloudwatch_event_rule.event_rule.name\n  arn  = aws_lambda_function.lambda_function.arn\n}\n\nresource \"aws_lambda_permission\" \"allow_cloudwatch\" {\n  action        = \"lambda:InvokeFunction\"\n  function_name = aws_lambda_function.lambda_function.function_name\n  principal     = \"events.amazonaws.com\"\n  source_arn    = aws_cloudwatch_event_rule.event_rule.arn\n}\n\noutput \"ConsumerFunction\" {\n  value       = aws_lambda_function.lambda_function.arn\n  description = \"ConsumerFunction function name\"\n}\n"
      },
      "has_app": true
    },
    "331b83bdbfe63d75": {
      "hash": "331b83bdbfe63d75",
      "source_url": "https://github.com/aws-samples/serverless-patterns/tree/main/apigw-http-api-lambda-terraform",
      "source_type": "github_repos",
      "discovered_at": "2026-01-11T08:20:46.397004",
      "services": [
        "cloudwatch",
        "lambda",
        "apigateway",
        "iam",
        "s3"
      ],
      "resource_count": 13,
      "name": "aws-samples/serverless-patterns/apigw-http-api-lambda-terraform",
      "description": "Serverless patterns. Learn more at the website: https://serverlessland.com/patterns.",
      "version": "main",
      "skipped": false,
      "skip_reason": null,
      "original_format": null,
      "terraform_files": {
        "main.tf": "terraform {\n  required_providers {\n    aws = {\n      source  = \"hashicorp/aws\"\n      version = \"~> 4.0.0\"\n    }\n    random = {\n      source  = \"hashicorp/random\"\n      version = \"~> 3.1.0\"\n    }\n    archive = {\n      source  = \"hashicorp/archive\"\n      version = \"~> 2.2.0\"\n    }\n  }\n\n  required_version = \"~> 1.0\"\n}\n\nprovider \"aws\" {\n  profile = \"default\"\n  region = var.aws_region\n}\n\n\nresource \"aws_s3_bucket\" \"lambda_bucket\" {\n  bucket_prefix = var.s3_bucket_prefix\n  force_destroy = true\n}\n\nresource \"aws_s3_bucket_acl\" \"private_bucket\" {\n  bucket = aws_s3_bucket.lambda_bucket.id\n  acl    = \"private\"\n}\n\ndata \"archive_file\" \"lambda_zip\" {\n  type = \"zip\"\n\n  source_dir  = \"${path.module}/src\"\n  output_path = \"${path.module}/src.zip\"\n}\n\nresource \"aws_s3_object\" \"lambda_app\" {\n  bucket = aws_s3_bucket.lambda_bucket.id\n\n  key    = \"source.zip\"\n  source = data.archive_file.lambda_zip.output_path\n\n  etag = filemd5(data.archive_file.lambda_zip.output_path)\n}\n\n//Define lambda function\nresource \"aws_lambda_function\" \"app\" {\n  function_name = var.lambda_name\n  description = \"apigwy-http-api serverlessland pattern\"\n\n  s3_bucket = aws_s3_bucket.lambda_bucket.id\n  s3_key    = aws_s3_object.lambda_app.key\n\n  runtime = \"python3.14\"\n  handler = \"app.lambda_handler\"\n\n  source_code_hash = data.archive_file.lambda_zip.output_base64sha256\n\n  role = aws_iam_role.lambda_exec.arn\n  depends_on = [aws_cloudwatch_log_group.lambda_log]\n}\n\nresource \"aws_cloudwatch_log_group\" \"lambda_log\" {\n  name = \"/aws/lambda/${var.lambda_name}\"\n\n  retention_in_days = var.lambda_log_retention\n}\n\nresource \"aws_iam_role\" \"lambda_exec\" {\n  name = \"serverless_lambda\"\n\n  assume_role_policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [{\n      Action = \"sts:AssumeRole\"\n      Effect = \"Allow\"\n      Sid    = \"\"\n      Principal = {\n        Service = \"lambda.amazonaws.com\"\n      }\n      }\n    ]\n  })\n}\n\nresource \"aws_iam_role_policy_attachment\" \"lambda_policy\" {\n  role       = aws_iam_role.lambda_exec.name\n  policy_arn = \"arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole\"\n}\n\n// API Gateway stuff\n\nresource \"aws_apigatewayv2_api\" \"lambda\" {\n  name          = \"apigw-http-lambda\"\n  protocol_type = \"HTTP\"\n  description   = \"Serverlessland API Gwy HTTP API and AWS Lambda function\"\n\n  cors_configuration {\n      allow_credentials = false\n      allow_headers     = []\n      allow_methods     = [\n          \"GET\",\n          \"HEAD\",\n          \"OPTIONS\",\n          \"POST\",\n      ]\n      allow_origins     = [\n          \"*\",\n      ]\n      expose_headers    = []\n      max_age           = 0\n  }\n}\n\n\nresource \"aws_apigatewayv2_stage\" \"default\" {\n  api_id = aws_apigatewayv2_api.lambda.id\n\n  name        = \"$default\"\n  auto_deploy = true\n\n  access_log_settings {\n    destination_arn = aws_cloudwatch_log_group.api_gw.arn\n\n    format = jsonencode({\n      requestId               = \"$context.requestId\"\n      sourceIp                = \"$context.identity.sourceIp\"\n      requestTime             = \"$context.requestTime\"\n      protocol                = \"$context.protocol\"\n      httpMethod              = \"$context.httpMethod\"\n      resourcePath            = \"$context.resourcePath\"\n      routeKey                = \"$context.routeKey\"\n      status                  = \"$context.status\"\n      responseLength          = \"$context.responseLength\"\n      integrationErrorMessage = \"$context.integrationErrorMessage\"\n      }\n    )\n  }\n  depends_on = [aws_cloudwatch_log_group.api_gw]\n}\n\nresource \"aws_apigatewayv2_integration\" \"app\" {\n  api_id = aws_apigatewayv2_api.lambda.id\n\n  integration_uri    = aws_lambda_function.app.invoke_arn\n  integration_type   = \"AWS_PROXY\"\n}\n\nresource \"aws_apigatewayv2_route\" \"any\" {\n  api_id = aws_apigatewayv2_api.lambda.id\n  route_key = \"$default\"\n  target    = \"integrations/${aws_apigatewayv2_integration.app.id}\"\n}\n\nresource \"aws_cloudwatch_log_group\" \"api_gw\" {\n  name = \"/aws/api_gw/${aws_apigatewayv2_api.lambda.name}\"\n\n  retention_in_days = var.apigw_log_retention\n}\n\nresource \"aws_lambda_permission\" \"api_gw\" {\n  statement_id  = \"AllowExecutionFromAPIGateway\"\n  action        = \"lambda:InvokeFunction\"\n  function_name = aws_lambda_function.app.function_name\n  principal     = \"apigateway.amazonaws.com\"\n\n  source_arn = \"${aws_apigatewayv2_api.lambda.execution_arn}/*/*\"\n}",
        "outputs.tf": "# Output value definitions\n\noutput \"apigwy_url\" {\n  description = \"URL for API Gateway stage\"\n\n  value = aws_apigatewayv2_api.lambda.api_endpoint\n}\n",
        "variables.tf": "# Input variable definitions\n\nvariable \"aws_region\" {\n  description = \"AWS region for all resources.\"\n  type    = string\n  default = \"us-east-1\"\n}\n\nvariable \"s3_bucket_prefix\" {\n  description = \"S3 bucket prefix for lambda code\"\n  type = string\n  default = \"apigw-http-api-lambda\"\n  \n}\n\nvariable \"lambda_name\" {\n  description = \"name of lambda function\"\n  type = string\n  default = \"test_apigw_integration\"\n}\n\nvariable \"lambda_log_retention\" {\n  description = \"lambda log retention in days\"\n  type = number\n  default = 7\n}\n\nvariable \"apigw_log_retention\" {\n  description = \"api gwy log retention in days\"\n  type = number\n  default = 7\n}\n"
      },
      "has_app": true
    },
    "62707d3237ff9c70": {
      "hash": "62707d3237ff9c70",
      "source_url": "https://github.com/aws-samples/serverless-patterns/tree/main/dynamodb-streams-lambda-terraform",
      "source_type": "github_repos",
      "discovered_at": "2026-01-11T08:20:47.528565",
      "services": [
        "iam",
        "lambda",
        "dynamodb"
      ],
      "resource_count": 5,
      "name": "aws-samples/serverless-patterns/dynamodb-streams-lambda-terraform",
      "description": "Serverless patterns. Learn more at the website: https://serverlessland.com/patterns.",
      "version": "main",
      "skipped": false,
      "skip_reason": null,
      "original_format": null,
      "terraform_files": {
        "main.tf": "terraform {\n  required_providers {\n    aws = {\n      source  = \"hashicorp/aws\"\n      version = \"~> 5.0\"\n    }\n  }\n\n  required_version = \">= 0.14.9\"\n}\n\nprovider \"aws\" {\n  profile = \"default\"\n  region  = \"us-east-1\"\n}\n\nresource \"aws_dynamodb_table\" \"dynamodb_table_users\" {\n  name             = \"UsersIds\"\n  billing_mode     = \"PROVISIONED\"\n  read_capacity    = 5\n  write_capacity   = 5\n  stream_enabled   = true\n  stream_view_type = \"NEW_AND_OLD_IMAGES\"\n  hash_key         = \"UserId\"\n\n  attribute {\n    name = \"UserId\"\n    type = \"S\"\n  }\n\n  tags = {\n    Name        = \"dynamodb-test-table\"\n    Environment = \"dev\"\n  }\n}\n\nresource \"aws_lambda_function\" \"lambda_dynamodb_stream_handler\" {\n  function_name    = \"process-usersids-records\"\n  filename         = data.archive_file.lambda_zip_file.output_path\n  source_code_hash = data.archive_file.lambda_zip_file.output_base64sha256\n  handler          = \"index.handler\"\n  role             = aws_iam_role.iam_for_lambda.arn\n  runtime          = \"nodejs24.x\"\n}\n\ndata \"archive_file\" \"lambda_zip_file\" {\n  type        = \"zip\"\n  source_file = \"${path.module}/src/index.js\"\n  output_path = \"${path.module}/lambda.zip\"\n}\n\nresource \"aws_lambda_event_source_mapping\" \"lambda_dynamodb\" {\n  event_source_arn  = aws_dynamodb_table.dynamodb_table_users.stream_arn\n  function_name     = aws_lambda_function.lambda_dynamodb_stream_handler.arn\n  starting_position = \"LATEST\"\n}\n\nresource \"aws_iam_role\" \"iam_for_lambda\" {\n  name = \"iam_for_lambda\"\n\n  assume_role_policy = <<EOF\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Action\": \"sts:AssumeRole\",\n      \"Principal\": {\n        \"Service\": \"lambda.amazonaws.com\"\n      },\n      \"Effect\": \"Allow\",\n      \"Sid\": \"\"\n    }\n  ]\n}\nEOF\n}\n\nresource \"aws_iam_role_policy\" \"dynamodb_lambda_policy\" {\n  name   = \"lambda-dynamodb-policy\"\n  role   = aws_iam_role.iam_for_lambda.id\n  policy = <<EOF\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n        \"Sid\": \"AllowLambdaFunctionToCreateLogs\",\n        \"Action\": [ \n            \"logs:*\" \n        ],\n        \"Effect\": \"Allow\",\n        \"Resource\": [ \n            \"arn:aws:logs:*:*:*\" \n        ]\n    },\n    {\n        \"Sid\": \"AllowLambdaFunctionInvocation\",\n        \"Effect\": \"Allow\",\n        \"Action\": [\n            \"lambda:InvokeFunction\"\n        ],\n        \"Resource\": [\n            \"${aws_dynamodb_table.dynamodb_table_users.arn}/stream/*\"\n        ]\n    },\n    {\n        \"Sid\": \"APIAccessForDynamoDBStreams\",\n        \"Effect\": \"Allow\",\n        \"Action\": [\n            \"dynamodb:GetRecords\",\n            \"dynamodb:GetShardIterator\",\n            \"dynamodb:DescribeStream\",\n            \"dynamodb:ListStreams\"\n        ],\n        \"Resource\": \"${aws_dynamodb_table.dynamodb_table_users.arn}/stream/*\"\n    }\n  ]\n}\nEOF\n}\n\noutput \"dynamodb_usersIds_arn\" {\n  value = aws_dynamodb_table.dynamodb_table_users.arn\n    description = \"The ARN of the DynamoDB Users Ids table\"\n}\n\noutput \"lambda_processing_arn\" {\n  value = aws_lambda_function.lambda_dynamodb_stream_handler.arn\n    description = \"The ARN of the Lambda function processing the DynamoDB stream\"\n}\n"
      },
      "has_app": true
    }
  }
}