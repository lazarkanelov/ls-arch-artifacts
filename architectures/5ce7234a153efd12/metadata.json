{
  "hash": "5ce7234a153efd12",
  "source_url": "https://registry.terraform.io/modules/transcend-io/lambda-at-edge/aws/0.5.0",
  "source_type": "terraform_registry",
  "discovered_at": "2026-01-11T21:32:51.618374",
  "services": [
    "ssm",
    "cloudwatch",
    "s3",
    "iam",
    "lambda"
  ],
  "resource_count": 8,
  "name": "transcend-io/lambda-at-edge",
  "description": "Terraform module for making a Lambda@Edge function in terraform",
  "version": "0.5.0",
  "skipped": false,
  "skip_reason": null,
  "original_format": null,
  "terraform_files": {
    "main.tf": "/**\n * Creates a Lambda@Edge function to integrate with CloudFront distributions.\n */\n\n/**\n * Lambdas are uploaded to via zip files, so we create a zip out of a given directory.\n * In the future, we may want to source our code from an s3 bucket instead of a local zip.\n */\ndata \"archive_file\" \"zip_file_for_lambda\" {\n  type        = \"zip\"\n  output_path = \"${var.local_file_dir}/${var.name}.zip\"\n\n  dynamic \"source\" {\n    for_each = distinct(flatten([\n      for blob in var.file_globs :\n      fileset(var.lambda_code_source_dir, blob)\n    ]))\n    content {\n      content = try(\n        file(\"${var.lambda_code_source_dir}/${source.value}\"),\n        filebase64(\"${var.lambda_code_source_dir}/${source.value}\"),\n      )\n      filename = source.value\n    }\n  }\n\n  # Optionally write a `config.json` file if any plaintext params were given\n  dynamic \"source\" {\n    for_each = length(keys(var.plaintext_params)) > 0 ? [\"true\"] : []\n    content {\n      content  = jsonencode(var.plaintext_params)\n      filename = var.config_file_name\n    }\n  }\n}\n\n/**\n * Upload the build artifact zip file to S3.\n *\n * Doing this makes the plans more resiliant, where it won't always\n * appear that the function needs to be updated\n */\nresource \"aws_s3_bucket_object\" \"artifact\" {\n  bucket = var.s3_artifact_bucket\n  key    = \"${var.name}.zip\"\n  source = data.archive_file.zip_file_for_lambda.output_path\n  etag   = data.archive_file.zip_file_for_lambda.output_md5\n  tags   = var.tags\n}\n\n/**\n * Create the Lambda function. Each new apply will publish a new version.\n */\nresource \"aws_lambda_function\" \"lambda\" {\n  function_name = var.name\n  description   = var.description\n\n  # Find the file from S3\n  s3_bucket         = var.s3_artifact_bucket\n  s3_key            = aws_s3_bucket_object.artifact.id\n  s3_object_version = aws_s3_bucket_object.artifact.version_id\n  source_code_hash  = filebase64sha256(data.archive_file.zip_file_for_lambda.output_path)\n\n  publish = true\n  handler = var.handler\n  runtime = var.runtime\n  role    = aws_iam_role.lambda_at_edge.arn\n  tags    = var.tags\n\n  lifecycle {\n    ignore_changes = [\n      last_modified,\n    ]\n  }\n}\n\n/**\n * Policy to allow AWS to access this lambda function.\n */\ndata \"aws_iam_policy_document\" \"assume_role_policy_doc\" {\n  statement {\n    sid    = \"AllowAwsToAssumeRole\"\n    effect = \"Allow\"\n\n    actions = [\"sts:AssumeRole\"]\n\n    principals {\n      type = \"Service\"\n\n      identifiers = [\n        \"edgelambda.amazonaws.com\",\n        \"lambda.amazonaws.com\",\n      ]\n    }\n  }\n}\n\n/**\n * Make a role that AWS services can assume that gives them access to invoke our function.\n * This policy also has permissions to write logs to CloudWatch.\n */\nresource \"aws_iam_role\" \"lambda_at_edge\" {\n  name               = \"${var.name}-role\"\n  assume_role_policy = data.aws_iam_policy_document.assume_role_policy_doc.json\n  tags               = var.tags\n}\n\n/**\n * Allow lambda to write logs.\n */\ndata \"aws_iam_policy_document\" \"lambda_logs_policy_doc\" {\n  statement {\n    effect    = \"Allow\"\n    resources = [\"*\"]\n    actions = [\n      \"logs:CreateLogStream\",\n      \"logs:PutLogEvents\",\n\n      # Lambda@Edge logs are logged into Log Groups in the region of the edge location\n      # that executes the code. Because of this, we need to allow the lambda role to create\n      # Log Groups in other regions\n      \"logs:CreateLogGroup\",\n    ]\n  }\n}\n\n/**\n * Attach the policy giving log write access to the IAM Role\n */\nresource \"aws_iam_role_policy\" \"logs_role_policy\" {\n  name   = \"${var.name}at-edge\"\n  role   = aws_iam_role.lambda_at_edge.id\n  policy = data.aws_iam_policy_document.lambda_logs_policy_doc.json\n}\n\n/**\n * Creates a Cloudwatch log group for this function to log to.\n * With lambda@edge, only test runs will log to this group. All\n * logs in production will be logged to a log group in the region\n * of the CloudFront edge location handling the request.\n */\nresource \"aws_cloudwatch_log_group\" \"log_group\" {\n  name = \"/aws/lambda/${var.name}\"\n  tags = var.tags\n  kms_key_id = var.cloudwatch_log_groups_kms_arn\n}\n\n/**\n * Create the secret SSM parameters that can be fetched and decrypted by the lambda function.\n */\nresource \"aws_ssm_parameter\" \"params\" {\n  for_each = var.ssm_params\n\n  description = \"param ${each.key} for the lambda function ${var.name}\"\n\n  name  = each.key\n  value = each.value\n\n  type = \"SecureString\"\n  tier = length(each.value) > 4096 ? \"Advanced\" : \"Standard\"\n\n  tags = var.tags\n}\n\n/**\n * Create an IAM policy document giving access to read and fetch the SSM params\n */\ndata \"aws_iam_policy_document\" \"secret_access_policy_doc\" {\n  count = length(var.ssm_params) > 0 ? 1 : 0\n\n  statement {\n    sid    = \"AccessParams\"\n    effect = \"Allow\"\n    actions = [\n      \"ssm:GetParameter\",\n      \"secretsmanager:GetSecretValue\",\n    ]\n    resources = [\n      for name, outputs in aws_ssm_parameter.params :\n      outputs.arn\n    ]\n  }\n}\n\n/**\n * Create a policy from the SSM policy document\n */\nresource \"aws_iam_policy\" \"ssm_policy\" {\n  count = length(var.ssm_params) > 0 ? 1 : 0\n\n  name        = \"${var.name}-ssm-policy\"\n  description = \"Gives the lambda ${var.name} access to params from SSM\"\n  policy      = data.aws_iam_policy_document.secret_access_policy_doc[0].json\n}\n\n/**\n * Attach the policy giving SSM param access to the Lambda IAM Role\n */\nresource \"aws_iam_role_policy_attachment\" \"ssm_policy_attachment\" {\n  count = length(var.ssm_params) > 0 ? 1 : 0\n\n  role       = aws_iam_role.lambda_at_edge.id\n  policy_arn = aws_iam_policy.ssm_policy[0].arn\n}\n",
    "outputs.tf": "// ARN of the lambda function with the most recently built version attached.\noutput \"arn\" {\n  value = \"${aws_lambda_function.lambda.arn}:${aws_lambda_function.lambda.version}\"\n}\n\noutput \"function_arn\" {\n  value = aws_lambda_function.lambda.arn\n}\noutput \"function_name\" {\n  value = var.name\n}\n\noutput execution_role_name {\n  value = aws_iam_role.lambda_at_edge.name\n}\n\noutput execution_role_arn {\n  value = aws_iam_role.lambda_at_edge.arn\n}\n",
    "variables.tf": "variable name {\n  description = \"Name of the Lambda@Edge Function\"\n}\n\nvariable description {\n  description = \"Description of what the Lambda@Edge Function does\"\n}\n\nvariable s3_artifact_bucket {\n  description = \"Name of the S3 bucket to upload versioned artifacts to\"\n}\n\nvariable tags {\n  type        = map(string)\n  description = \"Tags to apply to all resources that support them\"\n  default     = {}\n}\n\nvariable lambda_code_source_dir {\n  description = \"An absolute path to the directory containing the code to upload to lambda\"\n}\n\nvariable file_globs {\n  type        = list(string)\n  default     = [\"index.js\", \"node_modules/**\", \"yarn.lock\", \"package.json\"]\n  description = \"list of files or globs that you want included from the lambda_code_source_dir\"\n}\n\nvariable local_file_dir {\n  description = \"A path to the directory to store plan time generated local files\"\n  default     = \".\"\n}\n\nvariable runtime {\n  description = \"The runtime of the lambda function\"\n  default     = \"nodejs14.x\"\n}\n\nvariable handler {\n  description = \"The path to the main method that should handle the incoming requests\"\n  default     = \"index.handler\"\n}\n\nvariable config_file_name {\n  description = \"The name of the file var.plaintext_params will be written to as json\"\n  default     = \"config.json\"\n}\n\nvariable plaintext_params {\n  type        = map(string)\n  default     = {}\n  description = <<EOF\n  Lambda@Edge does not support env vars, so it is a common pattern to exchange Env vars for values read from a config file.\n\n  So instead of using env vars like:\n  `const someEnvValue = process.env.SOME_ENV`\n\n  you would have lookups from a config file:\n  ```\n  const config = JSON.parse(readFileSync('./config.json'))\n  const someConfigValue = config.SomeKey\n  ```\n\n  Compared to var.ssm_params, you should use this variable when you have non-secret things that you want very quick access\n  to during the execution of your lambda function.\n  EOF\n}\n\nvariable ssm_params {\n  type        = map(string)\n  default     = {}\n  description = <<EOF\n  Lambda@Edge does not support env vars, so it is a common pattern to exchange Env vars for SSM params.\n\n  So instead of using env vars like:\n  `const someEnvValue = process.env.SOME_ENV`\n\n  you would have lookups in SSM, like:\n  `const someEnvValue = await ssmClient.getParameter({ Name: 'SOME_SSM_PARAM_NAME', WithDecryption: true })`\n\n  These params should have names that are unique within an AWS account, so it is a good idea to use a common\n  prefix in front of the param names, such as:\n\n  ```\n  params = {\n    COMMON_PREFIX_REGION = \"eu-west-1\"\n    COMMON_PREFIX_NAME   = \"Joeseph Schreibvogel\"\n  }\n  ```\n\n  Compared to var.plaintext_params, you should use this variable when you have secret data that you don't want written in plaintext in a file\n  in your lambda .zip file. These params will need to be fetched via a Promise at runtime, so there may be small performance delays.\n  EOF\n}\n\nvariable cloudwatch_log_groups_kms_arn {\n  type        = string\n  description = \"KMS ARN to encrypt the log group in cloudwatch\"\n  default     = null\n}\n\n",
    "versions.tf": "terraform {\n  required_providers {\n    archive = {\n      source = \"hashicorp/archive\"\n    }\n    aws = {\n      source = \"hashicorp/aws\"\n    }\n  }\n  required_version = \">= 0.13\"\n}\n"
  }
}